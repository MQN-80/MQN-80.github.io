const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":84,\"nextId\":84,\"documentIds\":{\"0\":\"v-79fdd481\",\"1\":\"v-0e503981\",\"2\":\"v-3341bfb0\",\"3\":\"v-3341bfb0#前言\",\"4\":\"v-3341bfb0#总览\",\"5\":\"v-3341bfb0#整体架构\",\"6\":\"v-3341bfb0#代码结构\",\"7\":\"v-3341bfb0#参考资料\",\"8\":\"v-34f6984f\",\"9\":\"v-34f6984f#缓存池\",\"10\":\"v-34f6984f#淘汰策略\",\"11\":\"v-34f6984f#缓存管理器\",\"12\":\"v-34f6984f#参考资料\",\"13\":\"v-36ab70ee\",\"14\":\"v-36ab70ee#并发-b-树\",\"15\":\"v-36ab70ee#b-树定义\",\"16\":\"v-36ab70ee#b-树设计\",\"17\":\"v-36ab70ee#b-树搜索\",\"18\":\"v-36ab70ee#b-树插入\",\"19\":\"v-36ab70ee#b-树删除\",\"20\":\"v-36ab70ee#crabbing-协议\",\"21\":\"v-36ab70ee#小结\",\"22\":\"v-36ab70ee#参考资料\",\"23\":\"v-3860498d\",\"24\":\"v-3860498d#执行器\",\"25\":\"v-3860498d#处理模型\",\"26\":\"v-3860498d#执行计划\",\"27\":\"v-3860498d#参考资料\",\"28\":\"v-3a15222c\",\"29\":\"v-3a15222c#并发控制\",\"30\":\"v-3a15222c#事务\",\"31\":\"v-3a15222c#事务隔离级别\",\"32\":\"v-3a15222c#二阶段事务\",\"33\":\"v-3a15222c#锁管理器\",\"34\":\"v-3a15222c#死锁\",\"35\":\"v-3a15222c#实现\",\"36\":\"v-3a15222c#执行器\",\"37\":\"v-3a15222c#参考资料\",\"38\":\"v-3bc9facb\",\"39\":\"v-3bc9facb#日志和恢复\",\"40\":\"v-3bc9facb#日志\",\"41\":\"v-3bc9facb#恢复\",\"42\":\"v-3bc9facb#参考资料\",\"43\":\"v-4af18e38\",\"44\":\"v-f7182570\",\"45\":\"v-23a61b90\",\"46\":\"v-1ff12a92\",\"47\":\"v-1ff12a92#线上聊天室\",\"48\":\"v-0826edd7\",\"49\":\"v-0826edd7#tcp-概述\",\"50\":\"v-0826edd7#tcp-简单介绍\",\"51\":\"v-0826edd7#面向连接\",\"52\":\"v-0826edd7#可靠性\",\"53\":\"v-0826edd7#基于字节流\",\"54\":\"v-0826edd7#全双工\",\"55\":\"v-0826edd7#sponge-协议介绍\",\"56\":\"v-0826edd7#socket-api\",\"57\":\"v-0826edd7#用户态协议\",\"58\":\"v-0826edd7#sponge-协议概览\",\"59\":\"v-0826edd7#sponge-协议实现\",\"60\":\"v-0826edd7#bytestream\",\"61\":\"v-0826edd7#streamreassembler\",\"62\":\"v-0826edd7#tcpreceiver\",\"63\":\"v-0826edd7#tcpsender\",\"64\":\"v-0826edd7#tcpconnection\",\"65\":\"v-0826edd7#sponge-使用\",\"66\":\"v-0826edd7#总结\",\"67\":\"v-0826edd7#参考资料\",\"68\":\"v-65704aec\",\"69\":\"v-65704aec#buffer-sharing-in-multi-tenant-database-environment\",\"70\":\"v-65704aec#_1-overview-of-task-demand\",\"71\":\"v-65704aec#_2-solution\",\"72\":\"v-65704aec#_2-1-the-algorithm-to-choose-user-to-be-dispatch\",\"73\":\"v-65704aec#_2-2-the-algorithm-to-choose-block\",\"74\":\"v-65704aec#_3-improvement\",\"75\":\"v-047ef8aa\",\"76\":\"v-047ef8aa#_1-问题定义\",\"77\":\"v-047ef8aa#_2-问题分析\",\"78\":\"v-047ef8aa#_3-实际求解\",\"79\":\"v-5f688ebf\",\"80\":\"v-e1e3da16\",\"81\":\"v-76d185f2\",\"82\":\"v-b6b78c94\",\"83\":\"v-ac8a80e6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,19],\"1\":[1],\"2\":[3],\"3\":[1,84],\"4\":[1],\"5\":[1,77],\"6\":[1,73],\"7\":[1,7],\"8\":[3],\"9\":[1,22],\"10\":[1,130],\"11\":[1,284],\"12\":[1,11],\"13\":[3],\"14\":[2,11],\"15\":[1,96],\"16\":[1,212],\"17\":[1,85],\"18\":[1,212],\"19\":[1,237],\"20\":[2,208],\"21\":[1,18],\"22\":[1,17],\"23\":[3],\"24\":[1,36],\"25\":[1,85],\"26\":[1,230],\"27\":[1,12],\"28\":[3],\"29\":[1,20],\"30\":[1,26],\"31\":[1,83],\"32\":[1,85],\"33\":[1,45],\"34\":[1,44],\"35\":[1,198],\"36\":[1,125],\"37\":[1,23],\"38\":[3],\"39\":[1,39],\"40\":[1,47],\"41\":[1,47],\"42\":[1,9],\"43\":[1],\"44\":[1],\"45\":[1,178],\"46\":[2],\"47\":[1],\"48\":[3],\"49\":[2,46],\"50\":[2,4],\"51\":[1,32],\"52\":[1,29],\"53\":[1,22],\"54\":[1,22],\"55\":[2],\"56\":[2,55],\"57\":[1,51],\"58\":[2,114],\"59\":[2,46],\"60\":[1,111],\"61\":[1,237],\"62\":[1,290],\"63\":[1,326],\"64\":[1,418],\"65\":[2,255],\"66\":[1,21],\"67\":[1,14],\"68\":[2],\"69\":[7,17],\"70\":[5,44],\"71\":[2],\"72\":[9,57],\"73\":[6,68],\"74\":[2,35],\"75\":[1],\"76\":[2,6],\"77\":[2,9],\"78\":[2,14],\"79\":[1],\"80\":[1],\"81\":[1],\"82\":[1],\"83\":[1]},\"averageFieldLength\":[1.6309523809523807,84.23061729812375],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"过去二十年时间，敏捷宣言（Agile Manifesto）和精益创业（Lean startup）对软件社区最大的负面影响就是，一大堆外行或者并没有深刻理解软件工程的从业者，\\n过分追求速度，过度曲解 MVP（Minimum Viable Product），而忽视了从起点出发前，必不可少的架构和设计功夫，导致大部分技术债实际上是架构和设计阶段的债务。\"]},\"1\":{\"h\":\"幻灯片页\"},\"2\":{\"h\":\"谈谈关系数据库的设计与实现(1)——总览\"},\"3\":{\"h\":\"前言\",\"t\":[\"数据库是一个老生常谈的话题，类别众多，如内存数据库(Redis)，文档数据库(MongoDB)，时序数据库(InfluxDB)，图数据库(Neo4j)等，还有目前使用最广泛、最重要的关系数据库(MySQL、PostgreSQL 等)，这也有今天的主角——关系数据库。\",\"对于关系数据库，与它有关的论文、书籍、博文都数不胜数，但是大部分书籍和博文都在教开发者如何去使用一款数据库，鲜有去教开发者如何去弄懂数据库系统架构设计、原理和实现的。\",\"《Database System Concepts》正是这样一本书(中文名：《数据库系统概念》)，而恰好也有这么一门课程 CMU15445，来教我们如何去弄懂数据库原理，掌握数据库系统设计，甚至去实现一个小巧的数据库—— bustub 。\",\"而这恰好也是本文主题——关系数据库的设计与实现。本文不会去介绍如何写 SQL，如何用索引，如何数据备份，而是希望通过剖许 bustub 这个精巧的关系数据库来告诉你：数据库系统架构是什么样的？为什么要这么设计？它又是如何实现的？\",\"在正式介绍数据库设计和实现之前，请你先尝试回答如下几个问题：\",\"数据库会预读数据到缓冲池中，缓冲池是如何实现的，它有何作用？\",\"B+树似乎是数据库组织数据的最常用数据结构，它又是如何实现的？B+树一个节点究竟能存储多少项？B+树又是如何支持并发访问的？\",\"数据库是如何执行 SQL 的，执行器究竟是如何实现的？\",\"数据库事务隔离级别有哪几个？不同级别又是如何实现？数据库是如何处理并发访问控制的？ 如果你能迅速回答出这几个问题，那么本文可能不适合你，可是如果你还有疑惑，想要尝试从源码级别上来搞懂这几个问题，那么希望你能耐心阅读完本文，相信你能从中自己发掘出答案。\",\"注意：bustub 是 CMU 数据库组开源的一款关系数据库，用于 CMU15445 课程实验。目前 bustub 开源于 Github，代码虽然开源，但是由于涉及到课程实验作业，因此开源的只有一部分，为了保护课程，避免抄袭，本文只会贴出部分实现代码进行剖析，其它部分只会用画图的方式来说明。\"]},\"4\":{\"h\":\"总览\"},\"5\":{\"h\":\"整体架构\",\"t\":[\"bustub 究竟有哪些模块，这些模块负责哪些功能，模块之间如何协调？下面，我们一起来看看。\",\"bustub 整体架构图如下：\",\"图 1 bustub 架构图\",\"bustub 暂时没有 SQL 解析器、优化器等，其着重点在于数据库后端部分，即上图 1 中的查询处理、存储管理和磁盘存储三大部分，这三部分又包含了数据库很多模块：\",\"执行器(executor)：负责执行查询、插入等计划(plan)，bustub 暂时并未实现 SQL 解析器，无法将 SQL 语句转化为执行计划，因此需直接写代码构建执行计划来执行；\",\"缓存管理器(buffer_pool_manager)：从磁盘中读取页数据并缓存在内存中，避免每次查询、更改都读写磁盘，是数据库性能提升的核心组件；\",\"磁盘管理器(disk_manager)：负责向磁盘写数据页、日志，或者从磁盘读数据页、日志；\",\"事务管理器(transaction_manager)：bustub 支持数据库事务，保证数据操作的原子性、一致性等；\",\"日志管理器(log_manager)：为避免物理机突然崩溃，bustub 实现了日志记录功能，用于故障后数据恢复；\",\"快照管理器(checkpoint_manager)：实现数据库数据快照功能；\",\"磁盘存储：由磁盘管理器和宿主机操作系统共同完成。 在这个架构下，bustub 每执行一次查询(或更新、插入)的流程就如图 1 中的箭头所示：\",\"应用程序构建执行计划，并将执行计划交给执行器；\",\"执行器根据执行计划，请求事务管理器获取事务，然后以事务的方式请求缓存管理器获取数据页；\",\"缓存管理器判断数据页是否已在缓存中，如已在，则直接返回页数据，不存在则调用文件管理器读取对应页然后再返回；\",\"执行器根据执行计划中过滤条件筛选数据返回给应用程序。 当然这个过程中还伴随着索引、锁、日志、缓存淘汰等操作，这些将在后面详细介绍。\"]},\"6\":{\"h\":\"代码结构\",\"t\":[\"了解了 bustub 整体架构后，我们一起来看一下其代码结构，对项目整体有一个基本认识。如下：\",\"./src ├── buffer // 缓存模块，如缓存管理器，淘汰算法LRU ├── catalog // 数据库目录，如数据列、数据表定义 ├── common // 公共模块 ├── concurrency // 并发控制，如事务管理器、锁管理器 ├── execution // 执行模块，如查询执行器、插入执行器等 ├── include // 头文件 ├── recovery // 故障恢复模块，如快照管理器，日志管理器 ├── storage // 存储模块 │ ├── disk // 磁盘存储，磁盘管理器 │ ├── index // 索引，B+树 │ ├── page // 数据页，如B+树索引页，数据表页，元数据页 │ └── table // 数据表，数据记录，数据表迭代器 └── type // 字段类型，如整型、bool类型等 \",\"每个目录后面用注释说明了当前模块的作用和功能，这些模块将按照如下顺序依次介绍：\",\"缓存池：buffer 目录，缓存池、LRU 算法实现；\",\"并发 B+树：storage 目录，B+树实现及并发；\",\"执行器：execution 目录，执行期实现；\",\"并发控制：concurrency 目录，事务管理器、锁管理器实现；\",\"故障恢复：recovery 目录，日志记录、快照实现。 下面，我们来依次详细介绍这些模块的作用和实现。\"]},\"7\":{\"h\":\"参考资料\",\"t\":[\"CMU15445-fall2020\",\"Database System Concepts, 6th Edition\"]},\"8\":{\"h\":\"谈谈关系数据库的设计与实现(2)——缓存池\"},\"9\":{\"h\":\"缓存池\",\"t\":[\"减少磁盘和内存之间的数据 IO 次数是数据库提升查询效率的主要途径之一，也是数据设计的主要目标。\",\"为了达到这个目标，数据库需要在内存中保留尽可能多的数据页，最大限度地提高在内存中处理数据查询的机会，减少磁盘访问次数。\",\"但不可能将所有页都保存在内存中，我们需要一个管理内存与磁盘数据的中介组件——缓存池。\",\"磁盘上保存的数据实则是缓存池数据的副本。缓存池中的基本单位是页(对应操作系统 IO 的基本单位也是页)，每一页在磁盘上都有一个副本，磁盘上的副本可能是老数据(脏页)，负责分配缓存池的组件被称为缓存管理器(buffer_manager)。\"]},\"10\":{\"h\":\"淘汰策略\",\"t\":[\"相较于磁盘而言，内存是非常有限的，数据库不可能将所有数据页装在内存中，只能尽可能的将热点数据存储在缓冲池中，因此一旦缓存池满了，那么就需要淘汰一部分数据页将其刷到磁盘中，再从磁盘读取新的页。\",\"常见的淘汰算法有 FIFO、 LRU 和 LFU 等。数据库可以实现多种淘汰算法，在不同场景中选择合适的淘汰策略，这里我们来详细介绍 LRU 算法。\",\"LRU(Least recently used)，全称最近最少使用算法，是目前最常见的页面置换算法。LRU 算法会选择最近最少使用的页淘汰，缓存管理器会将其从缓存池中淘汰，并刷到磁盘中，然后从磁盘上读取新的数据页。\",\"LRU 的核心点在于最近、最少两个字，选择合适的数据结构就能解决这个问题。这里，笔者选择了最常见的双向链表+哈希表法，原理也很简单：\",\"新增(新访问)页将其保存在链表头部，并写入哈希表供快速查询；\",\"待页慢需要淘汰时，从链表尾部得到淘汰页，并从哈希表中删除。 由于每次访问或者新增页时，都会将页保存在链表头部，那么链表尾部自然就成为了最近最少使用的页，当缓存池满了需要淘汰时，直接将链表尾部页淘汰即可。\",\"bustub 中的 LRUReplacer 定义如下：\",\"class LRUReplacer : public Replacer { public: // ... // 淘汰一个页，并将淘汰页的 frame_id 返回 bool Victim(frame_id_t *frame_id) override; // 从 LRU 淘汰策略中删除一个页，不受淘汰约束 void Pin(frame_id_t frame_id) override; // 将一个页加入 LRU 淘汰策略 void Unpin(frame_id_t frame_id) override; // 当前 LRU 中有多少页 size_t Size() override; private: size_t num_pages; // 最大页数量 std::list<frame_id_t> list_; // 双向链表 std::unordered_map<frame_id_t, std::list<frame_id_t>::iterator> _map; // 哈希表 std::mutex mu; // 锁 }; \",\"LRUReplacer 实现并不困难，也不复杂，不过需要注意以下两点：\",\"LRUReplacer 需要保证并发安全，故每个函数操作都需加锁；\",\"缓存管理器会调用 Unpin 方法向 LRUReplacer 中加入需要被淘汰的页，也会调用 Pin 方法删除页，一经删除后，该页不再受 LRU 约束。 LRUReplacer 中的三个核心方法伪代码如下：\",\"void LRUReplacer::Unpin(frame_id_t frame_id) { lock(); // 加锁 // 如果超过了最大数量，或者已经包含了 frame_id，则直接返回 if (size >= num_pages || _map.contains(frame_id)) { return; } // 将 frame_id 加入到 LRU 中 front = list_.push_front(frame_id); _map[frame_id] = front; } void LRUReplacer::Pin(frame_id_t frame_id) { lock(); // 加锁 if (!_map.contains(frame_id)) { return; // 没有则直接返回 } it = _map[frame_id]; // 删除这个节点 _list.erase(it); _map.erase(frame_id); } bool LRUReplacer::Victim(frame_id_t *frame_id) { lock(); // 加锁 if (_map.empty()) { return false; } // 删除尾部 *frame_id = _list.pop_back(); _map.erase(*frame_id); return true; } \"]},\"11\":{\"h\":\"缓存管理器\",\"t\":[\"缓存管理器负责协同内存、磁盘之间的数据交换，且数据基本单位是页。缓存管理器负责将新数据页刷新到磁盘中，也会从磁盘中读取数据页到内存。如下图 2 所示：\",\"图 2 缓存管理器内存、磁盘\",\"缓存管理器是内存、磁盘之间的数据通道，元数据、表数据、索引数据都会通过缓存管理器来管理，对应 bustub 中的 BufferPoolManager 类。定义如下：\",\"class BufferPoolManager { public: // ... // 获取所有数据页 Page *GetPages() { return pages_; } // 缓存池大小 size_t GetPoolSize() { return pool_size_; } protected: // 通过 page_id 获取对应页 Page *FetchPageImpl(page_id_t page_id); // Unpin 一个页，is_dirty 表示是否脏页 bool UnpinPageImpl(page_id_t page_id, bool is_dirty); // 将页刷到磁盘 bool FlushPageImpl(page_id_t page_id); // 新建一个页 Page *NewPageImpl(page_id_t *page_id); // 从缓存中删除一个页 bool DeletePageImpl(page_id_t page_id); // 将缓存中所有页到刷到磁盘 void FlushAllPagesImpl(); // 缓存池大小 size_t pool_size_; // 缓存池中的页 Page *pages_; // 磁盘管理器 DiskManager *disk_manager_ __attribute__((__unused__)); // 日志管理器，暂不关注 LogManager *log_manager_ __attribute__((__unused__)); // 页表，page_id => frame_id std::unordered_map<page_id_t, frame_id_t> page_table_; // 置换器，如 LRUReplacer Replacer *replacer_; // 空闲页列表 std::list<frame_id_t> free_list_; // 锁 std::mutex latch_; }; \",\"BufferPoolManager 中由 pages_ 负责缓存数据页，其本质为一个 Page 数组，数组中的每一项被称为帧(frame)，每一项对应的数组序号称为 frame_id；\",\"page_table_ 负责维护 frame_id 与 page_id 之间的关系，pages_ 数组是有限的，frame_id 是数据页在内存中的标识，而 page_id 是数据页在磁盘上的标识；\",\"free_list_ 是空闲页列表，表示当前缓存池还有多少帧是空闲的，可以用于缓存页数据；\",\"BufferPoolManager 上的操作也需要保证并发安全，因此锁(latch_) 也是必须的。 这里需要额外说明的是，数据存储在磁盘上被称为页，但是被加载到内存 pages_ 后，又给它取了一个新名字，叫做帧，由 frame_id 来表示，当然其数据本身还是由 Page 来表示，因此后面还是会统一称作页。frame_id 是页在内存中暂时的 id 而已，当页被淘汰，就会有新页来继续使用这个 frame_id。\",\"BufferPoolManager 的意义在于，任何内存与磁盘之间的交互都需要通过它来进行，无论是获取数据页(FetchPage)，删除数据页(DeletePage)，新建数据页(NewPage)，刷数据页(FlushPage)都被它垄断，这样就能最大程度的利用缓存，提高访问性能。\",\"BufferPoolManager 的主要作用点在于操作数据页，有如下几个核心方法：\",\"获取数据页(FetchPage)；\",\"删除数据页(DeletePage)；\",\"新建数据页(NewPage)；\",\"将数据页刷至磁盘(FlushPage)。 以 FetchPage 方法为例，以 page_id 为参数调用 FetchPage 来获取对应的数据页，如果缓存中已有该页，则 Pin 该页(避免被 LRU 淘汰)并增加 pin_count 直接返回；如缓存中没有，则判断空闲列表是否有空闲页，如有直接获取空闲页，若无则淘汰一个页并且拿到该页；如果该页是脏页，则刷至磁盘，最后重置页数据，并从磁盘中读取新页。流程图如下图 3：\",\"图 3 FetchPage 流程图\",\"FetchPage 伪代码实现如下：\",\"Page *BufferPoolManager::FetchPageImpl(page_id_t page_id) { lock(); // 加锁，保证线程安全 page = page_table_.find(page_id); if (page) { // 缓存中已有 page replacer.Pin(page.frame_id); // Pin frame，frame 不会再淘汰 page.pin_count_++; // pin_count += 1 return page; // 返回 page } // 缓存中没有 page，未找到 Page frame_id_t free_frame_id; if (!free_list_.empty()) { // 从空闲列表中获取 free_frame_id = free_list_.pop_front(); } else { // 如果 free_list 中没有则淘汰一个页 replacer_.Victim(&free_frame_id); } // 得到空闲页 page = pages_[free_frame_id]; // 如果 free_frame_id 的页是脏的，则刷至磁盘 if (page.IsDirty()) { disk_manager.WritePage(page); page.is_dirty_ = false; } // 更新 page_table_ page_table_[page_id] = free_frame_id; // 更新 P 的元数据 page.reset(); // 从磁盘中读取 page_id 对应的页数据到 page disk_manager_.ReadPage(page_id, page); return page; } \",\"其它方法，这里就不再赘述了，感兴趣的可以点击 这里 查看其说明。这里贴出笔者实现的伪代码：\",\"bool BufferPoolManager::UnpinPageImpl(page_id_t page_id, bool is_dirty) { lock(); // 加锁 page = page_table_.find(page_id); // 寻找 page if (not page) { return false; // 未找到，返回 false } if (page.pin_count_ < 0) { // 如果 pin_count < 0，返回 false return false; } if (page.pin_count_ > 0) { // 如果 > 0，则 -1 page->pin_count_--; } if (page.pin_count_ == 0) { // 如果 == 0，则证明无人使用该页，加入到 replacer 中 replacer_.Unpin(frame_id); // Unpin 后，该页可能会被替换 } if (is_dirty) { page.is_dirty_ = is_dirty; // 是否脏页，即是否更改了该页数据 } return true; } bool BufferPoolManager::FlushPageImpl(page_id_t page_id) { lock(); // 加锁 page = page_table_.find(page_id); // 寻找数据页 if (not page) { return false; } if (page.IsDirty()) { // 是否脏页 disk_manager_.WritePage(page); // 脏页记得写回磁盘 page.is_dirty_ = false; } return true; } Page *BufferPoolManager::NewPageImpl(page_id_t *page_id) { lock(); *page_id = disk_manager_.AllocatePage(); // 分配新的 page_id // 寻找新的 frame_id frame_id_t free_frame_id; if (!free_list_.empty()) { free_frame_id = free_list_.pop_front(); // 从空闲列表中拿到 } else { // 如果 free_list 中没有则淘汰一个页 replacer_.Victim(&free_frame_id); } page = pages_[free_frame_id]; // 如果 free_frame_id 的页是脏的，则刷至磁盘 if (page.IsDirty()) { // 写到 page disk_manager_.WritePage(page); page.is_dirty_ = false; } page_table_[*page_id] = free_frame_id; // 更新 page_table // 重置 P 的元数据 page.reset() return pages_[free_frame_id]; } bool BufferPoolManager::DeletePageImpl(page_id_t page_id) { lock(); page = page_table_.find(page_id); if (not page) { return true; // 不存在，直接返回 } if (page.pin_count_ > 0) { return false; // 注意：pin_count > 0 证明有人正在使用，不能删除 } if (page.IsDirty()) { disk_manager_.WritePage(page); page.is_dirty_ = false; } // 元数据重置 page->reset(); // 删除 page_table_.erase(page_id); // 从 page_table 中删除 free_list_.push_back(frame_id); // 加入到空闲列表 disk_manager_->DeallocatePage(page_id); // 释放该页，并刷回磁盘 return true; } void BufferPoolManager::FlushAllPagesImpl() { lock(); for page in pages_ { // 刷每一页 FlushPage(page); } } \",\"额外说明：\",\"UnpinPage 需要注意 pin_count，pin_count 不可能为负，当有人拿到数据页，就会 pin_count += 1，一旦 pin_count 为 0，就证明无人使用该页，那么该页就应该被加入到 replacer 中，可以被淘汰；\",\"FlushPage 和 FlushAllPages 需要注意脏页，若是脏页，则必须刷回磁盘；\",\"NewPage 与 FetchPage 类似，都需要检查空闲列表，如果没有空闲页，那么则需要淘汰一个页；\",\"DeletePage 时也需要注意脏页，另外如果 pin_count > 0，那么证明有人正在使用该页，不能删除。 从伪代码中，我们可以发现 FetchPage 和 UnpinPage 实则为一对反操作，FetchPage 会增加页的 pin_count，而 UnpinPage 会减少 pin_count，并且页最后能否被删除取决于 pin_count 是否为 0，所以请切记：一旦你调用了 FetchPage 获取了数据页，操作完成后，不再使用，一定记得 UnpinPage，否则页永远不能删除，缓存的淘汰策略就名存实亡了。\"]},\"12\":{\"h\":\"参考资料\",\"t\":[\"Buffer Pools\",\"Database System Concepts 10.8\",\"PROJECT #1 - BUFFER POOL\"]},\"13\":{\"h\":\"谈谈关系数据库的设计与实现(3)——并发B+树\"},\"14\":{\"h\":\"并发 B+树\",\"t\":[\"主流关系数据库(如 MySQL、PostgreSQL 等)在数据组织和索引组织上几乎都选择了 B+树或其变种。B+树在关系数据库上的重要性不言而喻，这里我们先简单的来介绍一下 B+树 。\"]},\"15\":{\"h\":\"B+树定义\",\"t\":[\"B+树是一种多路自平衡树，不同于二叉树，B+树可以拥有多个子节点，并且能够一直保持完美的自平衡。一颗 B+树包括根节点、内部节点、叶子节点三种节点，根节点既可以是内部节点，也可以作为叶子节点。如下图 4 所示：\",\"图 4 根节点\",\"图 4 左边，树有且只有一个节点，即根节点，此时根节点在树的底部，因此根节点也是叶子结点，图 4 右边，树有三个节点，树的底部是叶子结点，树的内部是内部节点，此时根节点是内部节点。\",\"一颗 m 阶 B+树，必须满足如下几个条件：\",\"每个节点最多只有 m 个子节点；\",\"每个非叶子节点(除了根)具有至少 m/2 子节点；\",\"如果根不是叶节点，则根至少有两个子节点；\",\"具有 k 个子节点的内部叶节点包含 k - 1 个键；\",\"所有叶子节点高(深)度一致。 首先，我们需要明确 m 的含义，前面谈到 B+ 树可以拥有多个子节点，如图 5 所示是一棵 6 阶 B+树：\",\"图 5 六阶 B+树\",\"这棵 6 阶 B+树，其 m 就是 6，表示树中的每个节点最多只能有 6 个子节点，最少得有 3(6/2 取整) 个子节点，这条规则被称为半满。\",\"当然也有例外，如果是根节点不必满足半满这个条件，它最少只需有 2 个子节点。\",\"对于条件 4，一个内部节点有 k 个孩子节点(对应图中的箭头，每一个箭头指向一个孩子节点)，那么该内部节点只有 k-1 个键(对应图中节点里面的数字)，内部节点的第一个键可以理解为是空的，如图中内部节点的第一个空键，指向孩子节点的指针则是值。\",\"但是对于叶子结点，情况就不一样了，叶子节点没有子节点，有 k 个键，也有 k 个值，键即是图中的数字，值则是插入到 B+ 树中的数据。\",\"因此，可以得出 B+的一条性质，B+树中只有叶子结点才会存储真正的数据，内部节点只会存储键和子节点指针，如需对 B+树查询数据，那么最后必然会搜索到叶子结点上。\"]},\"16\":{\"h\":\"B+树设计\",\"t\":[\"简单介绍 B+树后，我们来看看 B+树的实现。bustub 中，B+树实现花了大量篇幅，涉及到好几个类和几千行代码，对 B+树的抽象非常优美，在具体的 B+树实现之前，我们先来看看其精美的代码设计，领略大师风采。\",\"首先，B+树在代码中被抽象定义为 BPlusTree 类：\",\"INDEX_TEMPLATE_ARGUMENTS class BPlusTree { using InternalPage = BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>; // 内部节点 using LeafPage = BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>; // 叶子节点 public: explicit BPlusTree(std::string name, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator, int leaf_max_size = LEAF_PAGE_SIZE, int internal_max_size = INTERNAL_PAGE_SIZE); // ... } \",\"BPlusTree 支持 Key，Value，KeyComparator 三种范型参数，如下：\",\"// k-v，k-comparator 类型，如何比较 k #define INDEX_TEMPLATE_ARGUMENTS template <typename KeyType, typename ValueType, typename KeyComparator> \",\"KeyType：树中键的类型，如 int；\",\"ValueType：树中值的类型，如 string；\",\"KeyComparator：键比较器类型，用于 key 之间的排序。 B+树节点可分为内部节点、叶子节点两种，分别是 InternalPage 和 LeafPage，其中 InternalPage 类的值类型为 page_id_t，表示内部节点中值上存储页 id，而叶子结点的值类型与 BPlusTree 的值类型为 ValueType。一个具体的 BPlusTree 例子可以为：\",\"template class BPlusTree<GenericKey<8>, RID, GenericComparator<8>>; \",\"KeyType 为 GenericKey<8>，ValueType 为 RID，KeyComparator 为 GenericComparator<8>；这样，BPlusTree 树就可以用于存储 RID。 构造 BPlusTree 时，name 参数用于指定树名称，也可以看作索引的名称，参数 leaf_max_size 和 internal_max_size 分别表示叶子节点和内部节点能够拥有的最大子节点个数，最大子节点个数是根据页大小，Key、Value 大小计算而来的：\",\"// k-v 类型 #define MappingType std::pair<KeyType, ValueType> // 叶子节点能容纳的 k-v 数量 #define LEAF_PAGE_SIZE ((PAGE_SIZE - LEAF_PAGE_HEADER_SIZE) / sizeof(MappingType)) \",\"这样就能保证一个叶子节点数据刚好能够存储在一个页中，由于操作系统 IO 的基本单位是页，所以每次 IO 恰好能获取一个节点的数据。 B+树结构类图如图 6 所示：\",\"图 6 B+树类图\",\"说明：\",\"BPlusTree 作为主类，向外提供 B+树的搜索、插入、删除 API；\",\"BPlusTreeLeafPage 和 BPlusTreeInternalPage 是对叶子节点和内部节点的抽象；\",\"BufferPoolManager 是 BPlusTree 读取、存储页数据的唯一途径。 BPlusTree 在内部通过调用 BufferPoolManager 的函数获取 Page 数据，那么这些 Page 数据是如何转化为叶子结点 BPlusTreeLeafPage 和 内部节点 BPlusTreeInternalPage 了？\",\"很简单，通过 reinterpret_cast：\",\"Page page = FindXXX(...); // 叶子结点 LeafPage *leaf_node = reinterpret_cast<LeafPage *>(page->GetData()); // 内部节点 InternalPage *leaf_node = reinterpret_cast<InternalPage *>(page->GetData()); \",\"Page 类是对数据页的代码抽象，其内部的 data 字段才是真正的物理页数据，因此可将该字段通过 reinterpret_cast 转化为 LeafPage 或者 InternalPage。 LeafPage 和 InternalPage 虽然是物理页数据，但不可能只保存键值对，还会保存页的元数据，被称为 header，这些元数据被抽象为了 LeafPage 和 InternalPage 的父类 BPlusTreePage：\",\"class BPlusTreePage { / // ... private: // member variable, attributes that both internal and leaf page share IndexPageType page_type_ __attribute__((__unused__)); // 页类型，是内部节点，还是叶子节点 lsn_t lsn_ __attribute__((__unused__)); // log sequence number int size_ __attribute__((__unused__)); // 页中 k-v 对的数量 int max_size_ __attribute__((__unused__)); // k-v 对的最大数量 page_id_t parent_page_id_ __attribute__((__unused__)); // 父节点 id page_id_t page_id_ __attribute__((__unused__)); // 节点 id }; \",\"有了这些元数据，Page 被读取转换后才能知道其 id，节点类型、最大子节点个数和父节点 id。 LeafPage 和 InternalPage 中用于保存键值对的字段是 array 数组字段，如下：\",\"class BPlusTreeInternalPage : public BPlusTreePage { // kv 数据数组 MappingType array[0]; }; \",\"这里利用了 C 语言特性，长度为 0 的数组实则可以任意扩容，而 array 的真正长度由 size_ 字段来维护。\"]},\"17\":{\"h\":\"B+树搜索\",\"t\":[\"在对 B+树一番介绍后，我们来一起看看 B+树搜索是如何实现的。搜索是 B+树中最简单的部分，合理利用好二分查找就足够了。B+树中搜索函数 GetValue 伪代码如下：\",\"Value GetValue(key) { // 树为空，直接返回 if (IsEmpty()) { return null; } // 寻找包含 key 的 Page page = FindLeafPage(key); if (not page) { return null; } // 将 data 转化为叶子结点 leaf_node = reinterpret_cast<LeafPage>(page->GetData()); val = leaf_node.Lookup(key); // 只要一个页使用完毕后，那么一定要 Unpin 一下，进入 LRU buffer_pool_manager_.UnpinPage(page); return val; } \",\"GetValue 会尝试从树中搜索 key 对应的值，由于 B+树将所有值存储在了叶子结点中，因此需先调用 FindLeafPage 获得 key 所在的叶子结点，然后调用 Lookup 从叶子结点上寻找值。如下：\",\"Page FindLeafPage(key) { page = buffer_pool_manager_.FetchPage(root_page_id); while (!page.IsLeafPage()) { page = page.Lookup(key); } return page; } ValueType Lookup(key) { // 二分查找 sz = GetSize(); st = 1; ed = sz - 1; while (st <= ed) { int mid = (ed - st) / 2 + st; if (array[mid].key <= key) { st = mid + 1; } else { ed = mid - 1; } } return array[st - 1].value; } \",\"B+树在搜索时，二分查找主要运用在如下两点：\",\"节点之间是有序的，左孩子节点小于当前 key，右孩子节点大于等于当前 key，通过 key 就能快速锁定是左边节点还是右边节点；\",\"节点中的键值对也是有序的，可直接通过二分查找找到对应的值。\"]},\"18\":{\"h\":\"B+树插入\",\"t\":[\"相较于查询，B+树插入会复杂一些，难点在于节点分裂。在 前面 也谈到了，B+树节点最多只能拥有 m 个子节点，最少要拥有 m/2 个子节点(根节点除外)，B+树在插入数据时，会不断的扩容节点，势必会导致节点的子节点个数超过 m。为了仍然保证 B+树性质，节点需要分裂。\",\"节点分裂可分为如下两种情况：\",\"基本情况，节点 A 子节点个数 >= m(叶子节点是值的个数 >= m)，节点 A 平分为两个节点 A 和 A1，若节点 A 有父节点，那么向父节点中加入指向 A1 节点的指针，父节点的子节点个数+1；\",\"递归情况，在基本情况的基础上，节点 A 的父节点子节点个数 +1 后，个数也 >= m，因此父节点也需要继续分裂，分裂过程与基本情况一致；同样地，如果再次分裂后，祖先节点可能仍需分离，因此递归情况需分裂到不可分裂为止； 如图 7 所示，是一棵 6 阶 B+树，节点 A 为叶子节点，已有 5 个值，节点 B 为内部节点，己有 5 个子节点。此时，向树中插入一个新数据 15。\",\"图 7\",\"通过搜索，发现 15 的插入点正好在节点 A 的末尾(按照排序来)，如图 8：\",\"图 8\",\"向(叶子)节点 A 插入 15 后，发现节点 A 已经拥有 6 个值了，按照分裂情况 1，需要对节点 A 进行分裂，如图 9：\",\"图 9\",\"节点 A 被分裂成 A 和 A1 后，父节点 B 中新增了指向 A1 的指针，此时节点 B 拥有了 6 个子节点，按照分裂情况 2，节点 B 也必须分裂。如图 10 所示：\",\"图 10\",\"节点 B 被分裂为 B、B1，并且 B1 节点上的第一个键上移到节点 C 中，节点 C 的子节点个数+1，此时节点 C(根节点)只有 3 个子节点，无需再次分裂，分裂完毕。\",\"在 B+树中插入数据 15 后，引起了两次节点分裂，第一次是叶子节点 A 分裂，第二次是内部节点 B 分裂；节点分裂后会使父节点的孩子节点个数增加，从而可能引发父节点再次分裂。\",\"B+树插入伪代码如下：\",\"bool Insert(key, value) { // 空树，那么新建 if (IsEmpty()) { StartNewTree(key, value); return true; } // 非空，插入至叶子节点 return InsertIntoLeaf(key, value, transaction); } \",\"B+树插入对外暴露 Insert API，如果当前仍是空树，那么将新建一棵 B+树，如下：\",\"void StartNewTree(key, value) { // 新建 root_page root_page = buffer_pool_manager_.NewPage(); // 将根节点数据视为叶子节点 root_node = reinterpret_cast<LeafPage>(root_page.GetData()); // 初始化根节点 root_node.Init(); // 向根节点中插入数据 root_node.Insert(key, value); } \",\"StartNewTree 会从缓冲池中获取一个新页作为根节点页，然后将页数据视为叶子(根)节点，对其初始化，并插入 kv。 如果当前树不为空，那么将 kv 插入到叶子节点中，如下：\",\"bool InsertIntoLeaf(key, value) { // 寻找 key 所在的叶子节点页 leaf_page = FindLeafPage(key); // 得到叶子结点 leaf_node = reinterpret_cast<LeafPage>(leaf_page.GetData()); // 向叶子节点中插入 kv ok = leaf_node.Insert(key, value); // 插入失败 if (!ok) { return false; } // 判断节点大小是否小于叶子节点最大个数 if (leaf_node.size < leaf_max_size) { // 小于，不用分裂，直接返回 return true; } // 分裂，new_node 是右半部分 new_node = Split(leaf_node); InsertIntoParent(leaf_node, new_node.FirstKey, new_node); return true; } void InsertIntoParent(old_node, first_key, new_node) { if (old_node.IsRootPage()) { // 那么重新申请一个页作为新的根节点，也作为 old_node 和 new_node 的父节点 new_page = buffer_pool_manager_.NewPage(); new_root_node = reinterpret_cast<InternalPage>(new_page.GetData()); // 初始化新的根节点，并且设置指向子节点的指针 new_root_node.Init(); // 更新 new_node 和 old_node 的父节点 old_node.SetParentPageId(new_page.GetPageId()); new_node.SetParentPageId(new_page.GetPageId()); return; } // 不是根节点，得到 old_node 的父节点 parent_page = old_node->GetParentPage(); // 拿到父节点，父节点一定是内部节点 parent_node = reinterpret_cast<InternalPage>(parent_page.GetData()); new_node.SetParentPageId(parent_id); // new_node 设置父节点 // 将 new_node 的 page_id 插入父节点 size = parent_node.InsertNewKey(new_node.FirstKey); if (size < internal_max_size_) { // 父节点无需分裂，直接返回 return; } // 分裂 parent 节点 parent_sibling = Split(parent_node); // 递归 InsertIntoParent(parent_node, parent_sibling.FirstKey, parent_sibling); } \",\"数据若要插入到叶子节点，需先找到该叶子结点，插入后判断是否需要分裂，若需要，还需要判断父节点是否需要分裂，依次向上递归，直至无需分裂后返回。插图流程图如图 11 所示： \",\"图 11\"]},\"19\":{\"h\":\"B+树删除\",\"t\":[\"B+树删除是 B+操作中最复杂的一部分。在删除的过程中，节点大小会变小，可能会出现 < size/2 的情况(半满)，那么对于这样的节点，有如下的处理方式：\",\"如果节点 A(删除后)与其兄弟节点 B，二者的子节点(值)个数加起来 > max_size，则将 A、B 与 A 的节点 C 进行重组(Redistribute)；\",\"如果节点 A(删除后)与其兄弟节点 B，二者的子节点(值)个数加起来 <= max_size，则将 A、B 节点合并(Coalesce)；\",\"如果在重组或者合并后，发现父节点未满足半满的性质，那么对父节点仍然递归的执行 1、2 操作；\",\"如果节点 A(删除后)是根节点： \",\"如果 A 是内部节点，且只有一个子节点，那么该子节点成为新的根节点；\",\"如果 A 是叶子结点，且无任何子节点，那么 B+树已被清空。 如图 12 所示，是一棵 6 阶 B+树，节点 A 大小为 3，刚好处于半满状态，节点 B 大小为 5，节点 C 是 A、B 的父节点，且也处于半满状态。\",\"图 12\",\"现在从树中删除 10，10 位于节点 A 中，删除后，A 节点大小为 2，不满足半满性质，因此需要重组或合并。B 节点是 A 的兄弟节点，其大小为 5，A、B 节点加起来的大小为 7，大于 6，因此需要重组而不是合并(合并后大小仍然大于 6，故不能合并)。如图 13 所示：\",\"图 13\",\"重组过程比较简单，B 节点将自己的末尾项 9，借给兄弟节点 A，A 将 9 加入到节点头部，并且更新父节点 C 节点中指向 A 节点的键(以前为 10，重组后为 9)。\",\"现在再从树中删除 15，如图 14 所示：\",\"图 14\",\"15 在节点 D 中，被删除后，节点 D 大小只有 2，不满足半满性质，且其兄弟节点 A 大小为 3，二者大小加起来也只有 5，小于 6，因此节点 D、A 需要合并，如下图 15 所示：\",\"图 15\",\"A、D 节点合并后成为节点 A，删除节点 C 中指向 D 的指针，并且更新 A 节点指向兄弟节点的指针。节点 C 删除一个子节点后，也无法满足半满性质，其兄弟节点 E 大小只有 3，因此 C、E 节点也需要合并，如图 16 所示。\",\"图 16\",\"节点 C、E 合并成为节点 C 后，其父节点 F(根节点)删除指向 E 的指针，虽然节点 F 也不满足半满的性质，但是 F 是根节点，最少只需要两个节点，因此合并完毕。\",\"在这个例子中，10 删除引发了节点重组，15 删除引发了两次节点合并，删除的复杂性大大高于插入。删除对应的 API 如下：\",\"void Remove(key) { // 如果是一棵空树，直接返回 if (IsEmpty()) { return; } page = FindLeafPage(key); leaf_node = reinterpret_cast<LeafPage>(page.GetData()); // 删除 entry ok = leaf_node->RemoveAndDeleteRecord(key); if (!ok) { // 删除失败 return; } // coalesce(合并) 或者 redistribute(重组) CoalesceOrRedistribute(leaf_node); } \",\"删除时，如果为空树则直接返回，否则找到含 key 的叶子结点，并从中删除 key，随后根据删除后的节点大小来决定重组、合并。如下：\",\"void CoalesceOrRedistribute(node) { if (node.IsRootPage()) { return AdjustRoot(node); } // 判断一下 if (node.GetSize() >= node.GetMinSize()) { return; } // 得到父节点、兄弟节点 parent = FindParentNode(node); sibling_node = FindSiblingNode(node); // 重组 if (node.GetSize() + sibling_node.GetSize() > node.GetMaxSize()) { Redistribute(sibling_node, node, parent); return; // no deletion happens } // 合并 Coalesce(sibling_node, node, parent); } void Coalesce(neighbor_node, node, parent) { // 合并以后可能还需要合并或者重组 // node 所有项移动到 neighbor_node node.MoveAllTo(neighbor_node); // 从 parent 中删除 node parent.Remove(node); // 判断 parent 是否需要合并或者重组 return CoalesceOrRedistribute(parent); } void Redistribute(neighbor_node, node, parent) { // 将 neighbor_internal_node \\b末尾移到 node 的最前面 // 或者将 node 的开始项移到 neighbor_internal_node 末尾 neighbor_internal_node.MoveLastToFrontOf(node); // 更新父节点指针 parent.SetKeyAt(index, neighbor_node); } void AdjustRoot(old_root_node) { // 根节点还不是最后一个节点，仍然是内部节点，且有一个孩子节点 if (old_root_node->GetSize() == 1 && !old_root_node->IsLeafPage()) { // 孩子节点成为新的根节点，然后删除旧的根节点 new_root_node = NewRootNode(); DeleteOldRootPage(); UpdateRootPageId(new_root_node); return; } // 只剩下根节点了，且已经没有子节点了 if (old_root_node.IsLeafPage() && old_root_node.GetSize() == 0) { // 删除根节点 root_page_id_ = INVALID_PAGE_ID; } } \",\"如果是根节点，则进入 AdjustRoot，判断是否需要删除根节点；\",\"如果节点与兄弟节点加起来大于 max_size，则重组否则合并；\",\"重组、合并都是可以递归向上执行的，直到满足半满为止。 删除流程图如图 17 所示：\",\"图 17\",\"提示：实际的代码实现其实比较复杂，伪代码只为说明过程和原理。\"]},\"20\":{\"h\":\"Crabbing 协议\",\"t\":[\"前面实现的 B+树可以满足单线程下任意读写，但如果是多线程，B+树该如何支持并发访问了？\",\"在实际的数据库场景中，并发访问索引是极其常见的，思考一下，如果我们在 BPlusTree 类中定义一把锁，该锁确实可以保证树在多线程是数据安全的，但也导致了单位时间内只有一个线程能够访问该索引，如果是真实环境，那么性能将是十分的低下。\",\"因此我们需要一种算法(或者协议)来让 B+树支持多线程并发访问、更新、删除，并且尽可能的提高并发性能。\",\"而 Crabbing 正是这样的一个协议。协议也十分好理解(实现起来有难度)，如下：\",\"当寻找一个 key 时，以共享锁锁住根节点，沿着树向下遍历，获取子节点，并对子节点加上共享锁后，释放父节点上的锁，重复这个过程，直至寻找到包含 key 的叶子结点，并释放锁；\",\"当更新、删除、插入一个 kv 时，以独占锁锁住根节点，向下遍历，获取子节点，对子节点加独占锁后，如果子节点是「安全」的，那么释放父节点锁，否则一直持有，重复这个过程，操作成功后，释放所有节点上的锁；\",\"如果在删除的过程中，发生重组、合并，那么也必须对兄弟节点加独占锁。 节点「安全」的定义如下：\",\"如果是插入操作，那么节点大小必须 < max_size -1(插入后不会超过 max_size，因此不回分裂，所以是安全的)；\",\"如果是删除操作，那么节点大小必须 > min_size(删除后，仍然满足半满性质，不会发生重组、合并，所以是安全的)；\",\"如果是删除操作，且为根节点，那么节点大小必须 > 2(删除后，根节点不用更新，所以是安全的)。 Crabbing 协议的向下查找方式像极了螃蟹走路，先移动一条腿，然后移动另外一条，因此也被称为「蟹行协议」。\",\"Crabbing 协议的核心点在于，如果是查询，那么只需要共享锁，且所有节点无需变更，都是安全的，因此每得到一个锁，就可以释放上一个锁，锁的「粒度」从树级别下降到了页级别，且共享锁是共享的，别人也可以同时访问。\",\"而如果是删除、插入操作，Crabbing 协议则复杂一些，每访问一个节点都必须先加独占锁，然后在判断子节点安全后，才能释放祖先节点的锁，如果不安全，那么将一直持有整条路线上的锁，对于重组、合并，还必须得兄弟节点加独占锁，待操作完毕后，才能释放所有持有的锁。\",\"注意：Crabbing 协议也有很多优化点，比如更新时，可以先加共享锁，然后升级为独占锁，这些本文不做讨论，感兴趣的可以自行查阅资料。 如图 18 所示，在 B+树中查询 18，从根节点 A 开始加共享锁，然后获取节点 B，对 B 加共享锁，释放 A 的锁，然后获取节点 C，对 C 加锁，释放 B 的锁，最后找到 18，释放 C 的锁。\",\"图 18\",\"查询过程中，无论是加锁、还是解锁都十分简单，那么如果是删除则复杂一些，如图 19 所示，\",\"图 19\",\"如图 19 所示，我们需要删除 46 号元素，从根节点 A 开始，加独占锁，然后获取节点 B，加独占锁，但是 B 不安全，大小为 3，所以无法释放 A 的锁，然后获取节点 C，读 C 加独占锁，而 C 也不安全，因此无法释放 A、B 上的锁，此时 A、B、C 全部加锁；但是删除元素 46 后，发现节点 C、D 需要合并，因此也需要对 D 加独占锁，此时 A、B、C、D 全被锁住了，当所以合并操作完成后，这次删除操作才能释放所有节点上的锁。\",\"因此，可以看到删除操作加锁比查询加锁要复杂的多，而且锁的粒度可能很大。\",\"对于 Crabbing 协议的实现，重点在于搜索时根据操作类型来选择锁的方式，并通过判断节点是否安全来决定是否释放祖先节点上的锁，其核心伪代码如下：\",\"Page FindLeafPageByOperation(key, op_type) { page = GetRootPage(); // 根节点页 if (op_type == OperationType::SEARCH) { page.RLatch(); // 搜索，加读锁 } else { page.WLatch(); // 其他操作，加独占锁 } // 如果不是叶子节点，那么继续向下搜索 while (!node.IsLeafPage()) { child_page = page.Lookup(key); if (op_type == OperationType::SEARCH) { child_page.RLatch(); // 子节点加锁 page->RUnlatch(); // 父节点解锁 } else { child_page->WLatch(); // 子节点枷锁 if (IsSafety(child_node, op_type)) { ReleaseAllAncestorLocks(); // 如果节点安全，则释放祖先节点的锁 } } page = child_page; node = child_node; } return page; } \",\"而在重组、合并时，需记得对兄弟节点加独占锁，这里就不展示相关的伪代码了。\"]},\"21\":{\"h\":\"小结\",\"t\":[\"B+树，尤其是支持并发的 B+树，在实现上其实是非常复杂的，有很多小细节都需要考虑和完善，笔者在实现的过程中，被虐的死去活来；尤其是加上 Crabbing 协议后，并发的 BUG 往往十分诡异，肉眼很难捕捉，往往花了好久才能定位问题，但是付出是值得的，实现过如此复杂的数据结构后，就很难再对数据结构产生畏惧。\"]},\"22\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 11.3~11.4\",\"Database System Concepts 15.10\",\"PROJECT #2 - B+TREE\",\"Trees Indexes I\",\"Trees Indexes II\",\"B+ tree\"]},\"23\":{\"h\":\"谈谈关系数据库的设计与实现(4)——执行器\"},\"24\":{\"h\":\"执行器\",\"t\":[\"前面的两个小节中，分别介绍了缓存池组件以及支持存储引擎的 B+树，本节的主角是执行器。\",\"数据库系统从客户端接收到 SQL 语句后，对语句解析、优化并得到该语句的「查询计划」，而执行器的作用就是按照查询计划来执行查询操作。\",\"这里的查询操作，并不单单指数据查询，它包括如下几类操作：\",\"访问、查询，如表遍历，记录查询等；\",\"更改，如数据更新、插入、删除等；\",\"其它，如 Limit、Offset、聚合函数，Join 等；\",\"注意：bustub 中不会实现 SQL 解析器、优化器，这里也不做介绍。\"]},\"25\":{\"h\":\"处理模型\",\"t\":[\"「处理模型」规定了执行器如何去执行查询计划。常见的处理模型有：\",\"Iterator Model(迭代器模型)\",\"Materialization Model\",\"Vectorized / Batch Model(批处理模型) bustub 实现了迭代器模型，其核心思想是：每一个执行器都实现 Next 方法。\",\"每次调用 Next 方法，执行器都会返回一条数据记录(Tuple)，如果没有则返回空；\",\"执行器可以拥有子执行器，父执行器在 Next 被调用时可以调用子执行器的 Next 方法，获取子执行器数据记录后，进一步处理返回。 bustub 通过 ExecutionEngine 类实例来执行查询计划，并获取查询结果，其定义如下：\",\"class ExecutionEngine { public: // ... bool Execute(const AbstractPlanNode *plan, std::vector<Tuple> *result_set, Transaction *txn, ExecutorContext *exec_ctx) { // construct executor auto executor = ExecutorFactory::CreateExecutor(exec_ctx, plan); // prepare executor->Init(); // execute try { Tuple tuple; RID rid; while (executor->Next(&tuple, &rid)) { if (result_set != nullptr) { result_set->push_back(tuple); } } } catch (Exception &e) { } return true; } // ... } \",\"ExecutionEngine 对外只暴露一个 Execute 方法，该方法接收四个参数：\",\"plan：查询计划；\",\"result：数据记录容器；\",\"txn：当前查询事务；\",\"exec_ctx：执行上下文。 AbstractPlanNode 是所有执行计划的父类，可用来表示所有类型的执行计划，通过调用 ExecutorFactory::CreateExecutor 方法可根据 plan 类型来生成对应的执行器，然后初始化该执行器，并不断调用 Next 方法来获取所有符合条件的数据记录(Tuple)。\"]},\"26\":{\"h\":\"执行计划\",\"t\":[\"为了支持各类查询计划(比如 select 查询计划)，bustub 定义了 AbstractPlanNode 作为所有查询计划的父类，其定义如下：\",\"class AbstractPlanNode { public: // ... AbstractPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children) : output_schema_(output_schema), children_(std::move(children)) {} virtual ~AbstractPlanNode() = default; // ... / private: // 数据表范式 const Schema *output_schema_; // 子查询计划 std::vector<const AbstractPlanNode *> children_; }; \",\"AbstractPlanNode 类有两个重要字段：\",\"output_schema_：数据表范式(定义)，查询数据组织方式，如：a int, b bool；\",\"children_：子查询计划列表； 每一类查询(如全表扫描)计划都有一个对应的查询计划类，以全表扫描的 SeqScanPlanNode 为例：\",\"class SeqScanPlanNode : public AbstractPlanNode { public: SeqScanPlanNode(const Schema *output, const AbstractExpression *predicate, table_oid_t table_oid) : AbstractPlanNode(output, {}), predicate_{predicate}, table_oid_(table_oid) {} PlanType GetType() const override { return PlanType::SeqScan; } const AbstractExpression *GetPredicate() const { return predicate_; } table_oid_t GetTableOid() const { return table_oid_; } private: // 谓词 const AbstractExpression *predicate_; // 数据表 id table_oid_t table_oid_; }; \",\"SeqScanPlanNode 表示全表扫描查询计划，即 SQL 中的 select 语句，其核心字段有两个：\",\"predicate_：断言，也可理解为查询条件，如 where id > 1；\",\"table_oid_：数据表 id，用来唯一标识一张表，即对哪张表进行全表扫描。 全表扫描查询计划保存了当前查询的表 id、查询条件等，那么该查询计划又是如何被执行器执行的呢？\",\"无独有偶，与查询计划一样，所有执行器也有一个公共父类 AbstractExecutor：\",\"class AbstractExecutor { public: explicit AbstractExecutor(ExecutorContext *exec_ctx) : exec_ctx_{exec_ctx} {} virtual ~AbstractExecutor() = default; virtual void Init() = 0; virtual bool Next(Tuple *tuple, RID *rid) = 0; virtual const Schema *GetOutputSchema() = 0; ExecutorContext *GetExecutorContext() { return exec_ctx_; } protected: ExecutorContext *exec_ctx_; }; \",\"AbstractExecutor 有且只有一个核心字段 exec_ctx_，即执行器上下文。执行器上下文上保存了执行器所需的环境、数据等信息，如：\",\"缓冲池管理器(BufferPoolManager)：执行器需访问数据页；\",\"目录(Catalog)：存储表、索引元数据；\",\"等等。 AbstractExecutor 还定义了执行器的基本方法 Init、Next 等，ExecutionEngine 就是通过 Next 方法来获取数据记录的。\",\"因此任何一个执行器，其核心其实都是 Next 方法，仍以全表扫描为例，其核心实现如下：\",\"SeqScanExecutor::SeqScanExecutor(ExecutorContext *exec_ctx, const SeqScanPlanNode *plan) : AbstractExecutor(exec_ctx), plan_(plan) { table_metadata_ = exec_ctx->GetCatalog()->GetTable(plan->GetTableOid()); } void SeqScanExecutor::Init() { table_iterator_ = std::make_unique<TableIterator>(table_metadata_->table_->Begin(exec_ctx_->GetTransaction())); } bool SeqScanExecutor::Next(Tuple *tuple, RID *rid) { Tuple tup; do { // 到末尾了，直接返回 if (*table_iterator_ == table_metadata_->table_->End()) { return false; } tup = *(*table_iterator_); // 得到当前 tuple ++(*table_iterator_); // 下一个 } while (plan_->GetPredicate() != nullptr && // 执行 !plan_->GetPredicate()->Evaluate(&tup, &(table_metadata_->schema_)).GetAs<bool>()); // 一个 Tuple 是一条记录，values 是字段值，schema 是字段名称 std::vector<Value> values; std::transform(plan_->OutputSchema()->GetColumns().begin(), plan_->OutputSchema()->GetColumns().end(), std::back_inserter(values), [&tup, &table_metadata_ = table_metadata_](const Column &col) { // Column 是数据列，即字段的定义，调用 Evaluate 获取列数据 return col.GetExpr()->Evaluate(&tup, &(table_metadata_->schema_)); }); // 赋值 *tuple = Tuple{values, plan_->OutputSchema()}; *rid = tup.GetRid(); return true; } \",\"SeqScanExecutor 构造函数、Init 方法分别用来初始化表元数据、表迭代器。其核心 Next 方法主要流程如下：\",\"判断迭代器是否结束，若结束，返回 false；\",\"迭代器++，若查询谓词为空，或者当前表记录(Tuple)满足查询条件(Predicate)，那么结束 while 循环，否则迭代器继续 ++；\",\"将表字段数据(Value)按照执行计划上的表范式(output_schema)包装为表记录(Tuple)返回。 不同的查询计划对应不同的执行器，bustub 通过 ExecutionEngine、AbstractExecutor 和 AbstractPlanNode 巧妙将其解耦；执行器执行时从上下文中获取查询所需的环境、数据等信息，然后通过谓词判断记录是否符合查询条件，若符合则取出值，并包装为表记录返回给执行引擎。\",\"执行器运行流程图如图 20 所示：\",\"图 20\",\"当然，bustub 有多种查询计划、执行器，如下：\",\"./src/execution ├── aggregation_executor.cpp ├── delete_executor.cpp ├── executor_factory.cpp ├── index_scan_executor.cpp ├── insert_executor.cpp ├── limit_executor.cpp ├── nested_index_join_executor.cpp ├── nested_loop_join_executor.cpp ├── seq_scan_executor.cpp └── update_executor.cpp \",\"全表扫描仅仅只是其中最简单的一种，得益于 bustub 精妙的抽象，我们只需实现一个简单的执行器就能领略到数据库执行器的风采，篇幅有限，其它执行器的实现这里就不再赘述了，感兴趣的可以点开参考资料查阅。\"]},\"27\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 12\",\"PROJECT #3 - QUERY EXECUTION\",\"Query Execution I\",\"Query Execution II\"]},\"28\":{\"h\":\"谈关系数据库的设计与实现(5)——并发控制\"},\"29\":{\"h\":\"并发控制\",\"t\":[\"在并发 B+树这一节中，我们实现了支持并发访问的 B+树，B+树可用于存储索引，但是数据库还有更加重要的数据部分——数据表记录(Tuple)。\",\"在 bustub 中，是通过 TransactionManager(事务管理器) 和 LockManager(锁管理器) 来实现 Tuple 并发访问控制和数据库事务的。\"]},\"30\":{\"h\":\"事务\",\"t\":[\"事务是数据库访问、更新数据的一个基本执行单元，它可由多个数据库操作组成，且多个操作不可分割，要么全部成功，要么全部失败。\",\"事务具有如下四个特性(摘自维基百科)，习惯上被称之为 ACID特性 。\",\"原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\",\"一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。\",\"隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\",\"持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。\"]},\"31\":{\"h\":\"事务隔离级别\",\"t\":[\"多事务并发执行的情况下，可能会出现如下几个问题：\",\"脏读（dirty read）：A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据；\",\"不可重复读（non-repeatable read）：A 事务第一次读取数据 1，然后 B 事务更改了数据 1 为 2，然后 A 事务再次读取，发现数据变成了 2；\",\"幻读（phantom read）：幻读发生在其他事务 insert 数据，A 事务第一次查询有 100 条，第二次查询却发现有 200 条，原因在于其它事务插入了数据。 为了解决这些问题，就有了「事务隔离级别」这个概念。隔离级别用于控制多个事务并发访问时，彼此的隔离状态，级别越高，隔离度也越好，但是整体运行效率也越低。\",\"读未提交：一个事务还没提交，其变更就能被其它事务看到。\",\"读提交：一个事务提交之后，其变更才能被其它事务看到。\",\"可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。\",\"串行化：后访问的事务必须等前一个事务执行完成，才能继续执行。 隔离级别越高，所能解决的问题就越多，但同样的，效率也就越低。如下表 1 所示，读未提交无法解决脏读、不可重复读、幻读中的任何一个，而串行化能够解决它们。\",\"脏读\",\"不可重复读\",\"幻读\",\"读未提交\",\"✖️\",\"✖️\",\"✖️\",\"读提交\",\"☑️\",\"✖️\",\"✖️\",\"可重复读\",\"☑️\",\"☑️\",\"✖️\",\"串行化\",\"☑️\",\"☑️\",\"☑️\",\"表 1\",\"那么是不是隔离级别越高越好了？显然不是的，如 MySQL 默认的隔离级别是 RR(可重复读)，而 PostgreSQL 默认隔离级别是 RC(读提交)，性能是数据库一个重要的考量指标，而不可重读等问题实际上出现的并不多，很少有人在一个事务过程中，多次读取同一条记录。\"]},\"32\":{\"h\":\"二阶段事务\",\"t\":[\"介绍事务基本概念后，又该如何实现事务了？\",\"一个事务访问数据库时，可能会对多个数据页加锁并读取数据，那么又该如何保证事务之间不发生数据冲突了？\",\"在 bustub 中，是通过「二阶段事务」来解决这两个问题的。事务一般有三个操作：\",\"开始(Begin)：启动一个事务；\",\"提交(Commit)：提交一个事务；\",\"回滚(Rollback)：回滚一个事务。 二阶段事务沿用了这三个操作，在 bustub 中也可以通过 Begin 开始一个事务，Commit 提交一个事务，如果发生问题，也可以通过 Rollback 回滚事务。\",\"但二阶段事务却有 4 个状态：\",\"Growing：获取锁阶段，事务向锁管理器请求锁；\",\"Shrinking：释放锁阶段，事务不能再获取锁，只能释放锁；\",\"Commited：提交阶段，事务已提交；\",\"Aborted：终止阶段，事务已终止。 事务是数据访问的基本单位，任何一个连接建立后，数据库系统都会为其分配一个事务(由事务 id 唯一标识)，此后该连接对数据的访问都会以此事务作为基本单位。\",\"因此对于并发连接的数据访问控制，实则就是对事务的控制。、\",\"两阶段锁定协议（2PL）是一种并发控制协议，决定事务是否可以动态地访问数据库中的对象。\",\"2PL 两个阶段：\",\"Growing： \",\"每个事务当需要时向锁管理器请求锁；\",\"锁管理器负责向事务授予锁、或者阻塞事物。\",\"Shrinking： \",\"事务无法再获取新的锁(也不能升级)，只能释放原来获取的锁。 \",\"2PL 仍然会存在：\",\"脏读问题，解决方案是 Strong Strict 2PL；\",\"死锁问题，解决方案是检测、预防。 为什么会存在脏读？因为再 shrinking 阶段，若事务释放了一个数据的锁，那么该锁可以被其它事务获取，而当前事务还未提交，因此其它事务可能读到脏数据。\",\"强二阶段锁定协议示意图如下：\",\"强二阶段锁规定，shrinkong 阶段不能释放某一个锁，只能在结束时释放所有的锁。\"]},\"33\":{\"h\":\"锁管理器\",\"t\":[\"锁是为了解决不同事务并发操作的隔离性问题，如下：\",\"事务 T1 最后访问 A 的同时，T2 更新了 A 并提交了，因此 T1 会读到脏数据。\",\"我们需要一种机制来保证所有事务执行是正确的（即事务本身觉得是序列化执行的），事务不用关系其它事务之间的数据依赖。\",\"解决办法：使用锁来保护数据对象。如下：\",\"事务 T1 来访问 A 时，必须对 A 加锁，加锁后，T2 不能访问 A，必须等待 T1 释放锁后，才能对 A 加锁，然后再更改。\",\"锁可分为如下两种类型：\",\"S：共享锁，其它事务可读；\",\"X：独占锁，其它事物不可读、不可写。 锁管理器的执行机制如下：\",\"事务请求(或者升级)锁；\",\"锁管理器授予事务锁、或者阻塞事务执行；\",\"事务释放锁；\",\"锁管理器在内部维护了事务锁表：跟踪哪些事务持有哪些锁以及哪些事务正在等待获取其它锁。\"]},\"34\":{\"h\":\"死锁\",\"t\":[\"当事务之间存在数据依赖，并且发生了环等待，就会产生死锁。解决死锁的方法有两种：\",\"死锁检测\",\"死锁预防 锁管理器在内部维护一个名为 wait-for 的图，用来记录事务正在等待获取的锁：\",\"图中的节点是事务；\",\"如果 T1 正在等待 T2 释放锁，那么 T1 有一条边指向 T2。 数据库系统会周期性地检查 wait-for 图，找到死锁，并决定如何打破它。\",\"如图所示：\",\"T1 等待 T2 释放锁，T2 等待 T3 释放锁，而 T3 又在等待 T1 释放锁，因此会出现环形等待，即死锁。\",\"当系统检测到死锁时，它会选择一个事务回滚以打破循环等待。回滚事务将重新启动或中止，这取决于具体情况。\",\"事务淘汰策略有多种，比如：\",\"By age，长事务先淘汰；\",\"By number of locks，锁多的先淘汰；\",\"等等\"]},\"35\":{\"h\":\"实现\",\"t\":[\"锁管理器(LockManager)负责对维护事务与数据表记录之间的锁联系，任何事务在访问数据记录之前，必须先尝试获取该记录的锁，这个过程被称为「请求锁」，请求成功后，锁管理器会赋予事务锁，否则返回失败。\",\"比如，事务获取某条记录的共享锁：\",\"bool LockManager::LockShared(Transaction *txn, const RID &rid) { // 事务共享锁加入 rid // Transaction txn tries to take a shared lock on record id rid. // This should be blocked on waiting and should return true when granted. // Return false if transaction is rolled back (aborts). // 如果是读未提交，那么直接 abort if (txn->GetIsolationLevel() == IsolationLevel::READ_UNCOMMITTED) { AbortImplicitly(txn, AbortReason::LOCKSHARED_ON_READ_UNCOMMITTED); return false; } // 如果是可重复读，且事务处于 shrinking 状态，那么直接 abort // 因为 shrinking 状态下，事务不能再加锁 if (txn->GetIsolationLevel() == IsolationLevel::REPEATABLE_READ && txn->GetState() == TransactionState::SHRINKING) { AbortImplicitly(txn, AbortReason::LOCK_ON_SHRINKING); return false; } // 如果 rid 已经被锁了，那么直接返回 true if (txn->IsSharedLocked(rid) || txn->IsExclusiveLocked(rid)) { return true; } // latch_ 用来保护 lock_table // lock_table 中保存了 rid 对应的锁队列 std::unique_lock<std::mutex> latch(latch_); auto &lock_request_queue = lock_table_[rid]; latch.unlock(); // 解锁 // 操作 rid 对应的队列，对队列加锁 std::unique_lock<std::mutex> queue_latch(lock_request_queue.latch_); // 将事务 id 和加锁模式加入到队列 auto &lock_request = lock_request_queue.request_queue_.emplace_back(txn->GetTransactionId(), LockManager::LockMode::SHARED); // 加入后等待 lock_request_queue.cv_.wait(queue_latch, [&lock_request_queue, &lock_request, &txn] { // 如果事务 abort，或者当前锁请求与队列中的其它锁兼容，比如都是共享锁，那么直接停止等待，继续执行 return LockManager::IsLockCompatible(lock_request_queue, lock_request) || txn->GetState() == TransactionState::ABORTED; }); // abort，直接返回 if (txn->GetState() == TransactionState::ABORTED) { AbortImplicitly(txn, AbortReason::DEADLOCK); } // 授予锁 lock_request.granted_ = true; txn->GetSharedLockSet()->emplace(rid); return true; } \",\"LockShared 方法接受两个参数：\",\"RID：每一条数据记录都由 RID 唯一标识；\",\"Transaction：事务，即当前请求共享锁的事务实例。 当调用 LockShared 方法时，txn 向锁管理器请求 rid 记录的共享锁。方法会根据事务隔离级别、以及事务阶段来判断是否授予锁。同理锁管理器还提供了 LockExclusive，LockUpgrade，Unlock 等方法分别用于互斥锁、锁升级和解锁等操作。\",\"而对于死锁检测，锁管理器维护了一个 waits_for_ 等待列表，并启动一个后台线程专门用于检查事务之间的依赖关系，如下：\",\"void LockManager::RunCycleDetection() { // 检查是否存在死锁 // You should not be maintaining a graph, it should be built and destroyed every time the thread wakes up. while (enable_cycle_detection_) { std::this_thread::sleep_for(cycle_detection_interval); { std::unique_lock<std::mutex> latch(latch_); if (!enable_cycle_detection_) { break; } waits_for_.clear(); BuildWaitsForGraph(); txn_id_t txn_id; while (HasCycle(&txn_id)) { // 得到死锁的 txn_id auto txn = TransactionManager::GetTransaction(txn_id); txn->SetState(TransactionState::ABORTED); // abort // 清除 txn_id 上的锁 // 得到 txn_id 上所有的边 for (const auto &wait_on_txn_id : waits_for_[txn_id]) { auto wait_on_txn = TransactionManager::GetTransaction(wait_on_txn_id); // 得到事务上的所有 share、exclusive 的 RID std::unordered_set<RID> lock_set; lock_set.insert(wait_on_txn->GetSharedLockSet()->begin(), wait_on_txn->GetSharedLockSet()->end()); lock_set.insert(wait_on_txn->GetExclusiveLockSet()->begin(), wait_on_txn->GetExclusiveLockSet()->end()); for (auto locked_rid : lock_set) { // 通知 lock_table_[locked_rid].cv_.notify_all(); } } // 重新建立图 waits_for_.clear(); BuildWaitsForGraph(); } } } } \",\"后台线程每隔一段时间就会构建出事务之间的依赖图，然后判断事务之间是否存在循环依赖(Cycle)，如果存在则将事务的状态设置为 Abort。\"]},\"36\":{\"h\":\"执行器\",\"t\":[\"在上一讲中，我们介绍了 bustub 如何通过执行器来执行 SQL 查询计划，但很显然，前面的执行器是无法支持事务隔离的，因此我们需要通过锁管理器来完善执行器的事务支持。\",\"仍然以全表扫描为例，SeqScanExecutor 是如何来支持事务的呢？在 Next 函数中，加上事务隔离级别的判断，如下：\",\"bool SeqScanExecutor::Next(Tuple *tuple, RID *rid) { Tuple tup; // 谓词不为空，而且执行 ok // tuples are returned if predicate(tuple) = true or predicate = nullptr do { // 到末尾了，直接返回 if (*table_iterator_ == table_metadata_->table_->End()) { return false; } tup = *(*table_iterator_); // 得到当前 tuple ++(*table_iterator_); // 下一个 } while (plan_->GetPredicate() != nullptr && // 执行 !plan_->GetPredicate()->Evaluate(&tup, &(table_metadata_->schema_)).GetAs<bool>()); // 判断事务隔离级别 + switch (exec_ctx_->GetTransaction()->GetIsolationLevel()) { + case IsolationLevel::READ_UNCOMMITTED: + break; // 读未提交，未加任何锁，直接 break + case IsolationLevel::READ_COMMITTED: + // 读已提交 + // 1.没有加读锁; + // 2.也没有加写锁; + // 3.不能加读锁后，立即解锁成功 + if (!exec_ctx_->GetTransaction()->IsSharedLocked(tup.GetRid()) && + !exec_ctx_->GetTransaction()->IsExclusiveLocked(tup.GetRid()) && + !(exec_ctx_->GetLockManager()->LockShared(exec_ctx_->GetTransaction(), tup.GetRid()) && + exec_ctx_->GetLockManager()->Unlock(exec_ctx_->GetTransaction(), tup.GetRid()))) { + return false; + } + break; + case IsolationLevel::REPEATABLE_READ: + // 可重读读 + // 1. 没有加读锁 + // 2. 没有加写锁 + // 3. 且不能加读锁 + if (!exec_ctx_->GetTransaction()->IsSharedLocked(tup.GetRid()) && + !exec_ctx_->GetTransaction()->IsExclusiveLocked(tup.GetRid()) && + !exec_ctx_->GetLockManager()->LockShared(exec_ctx_->GetTransaction(), tup.GetRid())) { + return false; + } + break; + default: + break; } // 一个 Tuple 是一条记录，values 是字段值，schema 是字段名称 std::vector<Value> values; std::transform(plan_->OutputSchema()->GetColumns().begin(), plan_->OutputSchema()->GetColumns().end(), std::back_inserter(values), [&tup, &table_metadata_ = table_metadata_](const Column &col) { // Column 是数据列，即字段的定义，调用 Evaluate 获取列数据 return col.GetExpr()->Evaluate(&tup, &(table_metadata_->schema_)); }); // 赋值 *tuple = Tuple{values, plan_->OutputSchema()}; *rid = tup.GetRid(); return true; } \",\"对于三个事务隔离级别的处理方式如下：\",\"读未提交，未加任何锁，直接 break；\",\"读已提交，没有加读、写锁，且无法加读锁，并能解锁；\",\"可重复读：没有加读、写锁，切无法加读锁 TODO 还未完全理清楚\"]},\"37\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 15\",\"PROJECT #4 - CONCURRENCY CONTROL\",\"Concurrency Control Theory\",\"Two-Phase Locking Concurrency Control\",\"https://www.bdwms.com/?p=741\",\"https://zhuanlan.zhihu.com/p/362061406\"]},\"38\":{\"h\":\"谈谈关系数据库的设计与实现(6)——日志和恢复\"},\"39\":{\"h\":\"日志和恢复\",\"t\":[\"计算机容易发生各种故障，如磁盘故障、宕机、软件错误等。一旦计算机故障就容易引起运行其内的数据库丢失数据，因此数据库必须预先采取措施以保证即使发生故障，数据仍然找回。\",\"恢复机制是数据库必不可少的一部分，它能保证数据库即使在故障发生的情况下，仍然恢复到发生前的状态，保证前后数据的一致性，保证数据库的高可用性。\",\"恢复算法是确保数据库一致性、原子性和持久性的关键技术。\",\"恢复算法主要工作包括如下两部分：\",\"记录事务处理期间的操作，以确保 DBMS 可以从故障中恢复；\",\"将数据库恢复到某个失败后的状态，确保操作的原子性、一致性和持久性。 恢复算法主要思路：\",\"预写日志(WAL)：\",\"任何数据更改在应用到数据库之前，必须先由日志写入磁盘。\",\"必须使用 STEAL + NO-FORCE 缓冲池策略。\",\"在重做期间恢复历史数据：在重新启动时，重做操作并将数据库恢复到崩溃前的状态。\",\"撤消期间记录更改：将撤消操作记录到日志中以确保操作不会在重复失败的情况下重复执行。\"]},\"40\":{\"h\":\"日志\",\"t\":[\"在 bustub 中通过 LogManager 来实现WAL日志记录。类定义如下：\",\"class LogManager { public: explicit LogManager(DiskManager *disk_manager) : next_lsn_(0), persistent_lsn_(INVALID_LSN), disk_manager_(disk_manager) { log_buffer_ = new char[LOG_BUFFER_SIZE]; flush_buffer_ = new char[LOG_BUFFER_SIZE]; } ~LogManager() { delete[] log_buffer_; delete[] flush_buffer_; log_buffer_ = nullptr; flush_buffer_ = nullptr; } void RunFlushThread(); void StopFlushThread(); void Flush(bool force); lsn_t AppendLogRecord(LogRecord *log_record); inline lsn_t GetNextLSN() { return next_lsn_; } inline lsn_t GetPersistentLSN() { return persistent_lsn_; } inline void SetPersistentLSN(lsn_t lsn) { persistent_lsn_ = lsn; } inline char *GetLogBuffer() { return log_buffer_; } // ... } \"]},\"41\":{\"h\":\"恢复\",\"t\":[\"那么 bustub 碰到数据库崩溃、电源断开等情况又该如何恢复呢？bustub 的处理其实是比较粗糙的，定义如下：\",\"class LogRecovery { public: LogRecovery(DiskManager *disk_manager, BufferPoolManager *buffer_pool_manager) : disk_manager_(disk_manager), buffer_pool_manager_(buffer_pool_manager), offset_(0) { log_buffer_ = new char[LOG_BUFFER_SIZE]; } ~LogRecovery() { delete[] log_buffer_; log_buffer_ = nullptr; } void Redo(); void Undo(); bool DeserializeLogRecord(const char *data, LogRecord *log_record); // ... } \",\"bustub 的崩溃恢复必须先 Redo 再 Undo，首先 Redo 会扫描全部的日志文件，并通过 LSN 大小来重做未完成的事务，在重做期间记录正在活跃的事务，然后调用 Undo 来撤销这些操作。\"]},\"42\":{\"h\":\"参考资料\",\"t\":[\"PROJECT #4 - LOGGING & RECOVERY\",\"Database System Concepts 16\",\"Database Recovery\"]},\"43\":{\"h\":\"手动实现GMM算法\"},\"44\":{\"h\":\"手动实现反向传播算法\"},\"45\":{\"h\":\"protobuf应用及反射\",\"t\":[\"Protobuf(pb)是一种常见的数据序列化方式,常常用于进程间序列化信息传递,相对于传统的csv,json等,pb在缩小可读性的基础上,不仅结构体积小,而且解析速度快,其对比如下图所示:\",\"特性\\\\类型\",\"xml\",\"json\",\"protobuf\",\"数据结构支持\",\"简单结构\",\"简单结构\",\"复杂结构\",\"数据保存方式\",\"文本\",\"文本\",\"二进制\",\"数据保存大小\",\"大\",\"大\",\"小\",\"编解码效率\",\"慢\",\"慢\",\"快\",\"语言支持程度\",\"覆盖主流语言\",\"覆盖主流语言\",\"覆盖主流语言\",\"后端常用于微服务信息传递,也广泛用于自动驾驶场景中,用于实现低延时,可靠 的进程间通信结构,因此为了实现通信中间件,需要对protobuf及其反射原理进行调研\",\"Message成员变量类图: 一般使用 PB 反射的步骤如下：\",\"通过Message获取单个字段的FieldDescriptor\",\"通过Message获取其Reflection\",\"通过Reflection来操作FieldDescriptor，从而动态获取或修改单个字段 获取 Descript、Reflection 的函数：\",\"const google::protobuf::Reflection* pReflection = pMessage->GetReflection(); const google::protobuf::Descriptor* pDescriptor = pMessage->GetDescriptor(); \",\"我们要明确为什么pb为什么需要反射,以我所在的自驾行业为例,自驾中需要传递的数据非常多，传感器采集信息包括相机，激光雷达，毫米波雷达，导航信息，gnss等，而planning，感知，预测等又会产生很多message，因此需要定义大量pb结构，如果使用get/set读写这些特征，那每个pb格式都要写一遍实现代码，因此我们需要反射来简化这个流程，pb反射流程如下:\",\"根据messageName获取Descriptor\",\"const google::protobuf::Descriptor* desc = google::protobuf::DescriptorPool::generated_pool()->FindMessageTypeByName(msg_name); \",\"根据descriptor获取Message\",\"google::protobuf::Message* message = google::protobuf::MessageFactory::generated_factory()->GetPrototype(desc)->New(); \",\"获取对应的reflection\",\"const google::protobuf::Reflection* reflection = message->GetReflection(); \",\"获取fileDescription,filed_name就是具体字段名\",\"const google::protobuf::FieldDescriptor* field_descriptor = desc->FindFieldByName(filed_name); google::protobuf::Message* header = reflection->MutableMessage(msg.get(), field_descriptor); \",\"之后就可以操作对应的Message了\",\"我们以一个具体场景为例,那就是实现对pb对象中非空字段的选取，其代码如下:\",\"int PbToMap(const google::protobuf::Message &message, std::map<std::string, std::string> &out) { #define CASE_FIELD_TYPE(cpptype, method, valuetype) \\\\ case google::protobuf::FieldDescriptor::CPPTYPE_##cpptype: { \\\\ valuetype value = reflection->Get##method(message, field); \\\\ std::ostringstream oss; \\\\ oss << value; \\\\ out[field->name()] = oss.str(); \\\\ break; \\\\ } #define CASE_FIELD_TYPE_ENUM() \\\\ case google::protobuf::FieldDescriptor::CPPTYPE_ENUM: { \\\\ int value = reflection->GetEnum(message, field)->number(); \\\\ std::ostringstream oss; \\\\ oss << value; \\\\ out[field->name()] = oss.str(); \\\\ break; \\\\ } #define CASE_FIELD_TYPE_STRING() \\\\ case google::protobuf::FieldDescriptor::CPPTYPE_STRING: { \\\\ std::string value = reflection->GetString(message, field); \\\\ out[field->name()] = value; \\\\ break; \\\\ } const google::protobuf::Descriptor *descriptor = message.GetDescriptor(); const google::protobuf::Reflection *reflection = message.GetReflection(); for (int i = 0; i < descriptor->field_count(); i++) { const google::protobuf::FieldDescriptor *field = descriptor->field(i); bool has_field = reflection->HasField(message, field); if (has_field) { if (field->is_repeated()) { return -1; // 不支持转换repeated字段 } const std::string &field_name = field->name(); switch (field->cpp_type()) { CASE_FIELD_TYPE(INT32, Int32, int); CASE_FIELD_TYPE(UINT32, UInt32, uint32_t); CASE_FIELD_TYPE(FLOAT, Float, float); CASE_FIELD_TYPE(DOUBLE, Double, double); CASE_FIELD_TYPE(BOOL, Bool, bool); CASE_FIELD_TYPE(INT64, Int64, int64_t); CASE_FIELD_TYPE(UINT64, UInt64, uint64_t); CASE_FIELD_TYPE_ENUM(); CASE_FIELD_TYPE_STRING(); default: return -1; // 其他异常类型 } } } return 0; } \"]},\"46\":{\"h\":\"Talk Room\"},\"47\":{\"h\":\"线上聊天室\"},\"48\":{\"h\":\"谈谈用户态 TCP 协议实现\"},\"49\":{\"h\":\"TCP 概述\",\"t\":[\"TCP 协议是目前名气最大、使用最广泛的传输层网络协议。\",\"TCP 是一个可靠的（reliable）、面向连接的（connection-oriented）、基于字节流（byte-stream）、全双工的（full-duplex）协议。\",\"正是因为这些优点，TCP 协议成为了网络协议重点中的重点，是学习、面试、考试上的常客，这也导致了 TCP 的资料很多，但是普遍集中在“形”上面，很多人将三次握手、四次挥手、滑动窗口等知识点背得滚瓜烂熟，但却没有理解 TCP “可靠” 协议的精髓。\",\"因此，本着实践加深理解的初衷，笔者跟随 CS144 这门课，会头到尾实现了一个用户态简易版 TCP 协议。\",\"说明：CS144 最终会实现一个全栈的网络协议栈，包含数据链路层、网络层和传输层，但是本文的重点聚焦在 TCP 协议上，因此对于其它层协议不做详细介绍，感兴趣的可以自行查询。\"]},\"50\":{\"h\":\"TCP 简单介绍\",\"t\":[\"下面我们分别简单介绍一下 TCP 的特点。\"]},\"51\":{\"h\":\"面向连接\",\"t\":[\"面向连接是 TCP 显著特点，在正式数据传输之前 TCP 需要三次握手来协商建立连接，结束传输后又需要四次挥手来结束连接。\",\"以三次握手为例，TCP 需要通过三次握手来确认对端状态，交换起始序号、窗口大小等信息，如下：\",\"三次握手流程如下：\",\"客户端向服务器发送 SYN 包；\",\"服务器收到 SYN 包后，向客户端发送 SYN+ACK 包；\",\"客户端收到 SYN+ACK 包后，回复 ACK 包至客户端。 在三次握手的过程中，重点在于 SYN 和 ACK 包的交互，当然也涉及到初始化序号、窗口大小、状态转换等工作，这些细节后面会在实现中详细介绍。\"]},\"52\":{\"h\":\"可靠性\",\"t\":[\"可靠性是 TCP 最大的功能点(个人观点，欢迎斧正)，TCP 为了保证数据传输的可靠性，做了很多事情，虽然这增加了实现的复杂性，但却是值得的：\",\"校验和，TCP 每个报文都有校验和字段，防止数据丢失或出错；\",\"序列化和确认号，保证每个序号的字节都交付，解决丢失、重复等问题；\",\"超时重传，对于超时未能确认的豹纹，TCP 会重传这些包，确保数据达到对端；\",\"等等 如下：\",\"虽然 TCP 在可靠性上做了很多努力，但仍然不能保证完美的可靠性，只能做到尽最大努力交付。对于可靠性的细节，我们将在后面的实现中详细介绍。\"]},\"53\":{\"h\":\"基于字节流\",\"t\":[\"TCP 数据传输是基于流的，意味着 TCP 传输数据是没有边界的，没有大小限制的，可以传输无限量的字节。\",\"但是 TCP 报文大小是有限制的，这主要取决于滑动窗口大下、路径最大传输单元 MTU 等因素。\",\"TCP 数据写、读、传入都是基于字节流，因此常常会有字节流乱序发生，所以 TCP 需要一个重组器组件专门用于流序号的重组工作，当然这涉及到 TCP 具体实现，我们将实现部分详细介绍。\"]},\"54\":{\"h\":\"全双工\",\"t\":[\"全双工意味着 TCP 协议通信的双方既可以发送数据，又可以接受数据，双方拥有独立的序号、窗口等信息。\",\"简单来说，一个 TCP 连接既可以是 sender 也可以是 receiver，同时连接拥有两个字节流，一个输出流，被 sender 控制，另一个是输入流，由 receiver 管理。关于这二者的细节，我们将在实现部分详细介绍。\"]},\"55\":{\"h\":\"Sponge 协议介绍\"},\"56\":{\"h\":\"Socket API\",\"t\":[\"绝大多数操作系统会在内核中提供 TCP 协议的实现，并对外暴露 socket API，借助 nc 工具，我们可以快速的使用 socket API，并领略它的风采，如下：\",\"$ nc -v -l -p 9090 Ncat: Version 6.40 ( http://nmap.org/ncat ) Ncat: Listening on :::9090 Ncat: Listening on 0.0.0.0:9090 \",\"首先，在一个窗口中通过 -l 参数来监听本地的 9090 端口，然后在另一个窗口中连接该端口：\",\"$ telnet localhost 9090 \",\"回到 nc 端口，会发现多出了如下日志：\",\"Ncat: Connection from 127.0.0.1. Ncat: Connection from 127.0.0.1:37731. \",\"可以看到，通过 nc 和 telnet 这两个工具，我们很轻易的就建立起了 TCP 连接，而这两个工具本身都是在调用 socket API。 TCP 由操作系统实现在了内核态，并提供 socket API，虽然使用方便，但是却屏蔽了大量信息，给错误调试和定位带来了很大困难。\"]},\"57\":{\"h\":\"用户态协议\",\"t\":[\"在用户态上实现协议是一个很有趣且很有挑战的事情，目前最著名的当属 QUIC 协议，QUIC 协议是建立在 UDP 上的一个用户态可靠协议。而 CS144 实现的 TCP 协议，也就是本文后面所实现的 TCP 协议和 QUIC 协议定位非常类似，当然 QUIC 协议在功能特性上完胜，但是这不影响我们以此来学习一个简单可靠的类 TCP 协议。\",\"为了与其它协议进行区分，本文实现的协议我们统称为 Sponge 协议。下面，对 Sponge 协议做一些简单的介绍：\",\"Sponge 协议建立在 UDP 之上(也可以建立在 IP 协议之上，为了避免引入 TUN/TAP 带来复杂，暂时不做延伸)；\",\"Sponge 协议是一种简易版 TCP 协议，和 TCP 协议一样有滑动窗口、重传、校验和等功能，但是一些复杂的特性暂时不支持，如：紧急指针、拥塞控制、Options 中的一些选项均不支持；\",\"Sponge 协议并不特别复杂，在 CS144 的课程带领下，完全可以自主实现，并没有什么高深莫测的技术，每个人都有能力去理解和实现。\"]},\"58\":{\"h\":\"Sponge 协议概览\",\"t\":[\"下面，我们就以先整体后局部的方式来详细介绍 Sponge 协议。Sponge 协议的主体类为 TCPConnection，该类主要维护 TCP 连接、TCP 状态机等信息数据，并将接收到的报文交给 TCPReceiver 处理，从 TCPSender 获取报文并发送。类图如下：\",\"TCPConnection 负责维护连接，报文发送、接收分别由 TCPSender 和 TCPReceiver 来负责；\",\"TCPSender 负责发送报文，接收确认号(ackno)确认报文，记录发送但未确认的报文，对超时未确认的报文进行重发；\",\"TCPReceiver 负责接收报文，对报文数据进行重组(报文可能乱序、损坏等，由 StreamReassembler 负责重组)；\",\"StreamReassembler 负责对报文数据进行重组，每个报文中的每个字节都有唯一的序号，将字节按照序号进行重组得到正确的字节流，并将字节流写入到 ByteStream 中；\",\"ByteStream 是 Sponge 协议中的字节流类，一个 TCPConnection 拥有两个字节流，一个输出流，一个输入流。输出流为 TCPSender 中的 _output 字段，该流负责接收程序写入的数据，并将其包装成报文并发送，输入流为 StreamReassembler 中的 _output 字段，该流由 StreamReassembler 重组报文数据而来，并将流数据交付给应用程序。 Sponge 协议巧妙地将连接分为了 sender 和 receiver 两个部分，并通过重组器、字节流等类将 TCP 连接完美抽象，使代码更易维护和阅读，也使功能迭代和完善更加方便。\",\"Sponge 的数据流图如下所示：\",\"从这个图中可以总结出 Sponge(基于 UDP 而非 IPv4) 数据流过程：\",\"内核态下 UDP 数据包中的 payload 被解析为 TCPSegment(TCP 报文)后，交给用户态下的 TCPConnection，即调用 segment_received 方法；\",\"TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno(确认号)与 window_size(窗口大小)交给 TCPSender，即调用 ack_received 方法；\",\"TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；\",\"TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文(可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno(从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；\",\"UDP 将其打包为数据报，并发送给远端。\"]},\"59\":{\"h\":\"Sponge 协议实现\",\"t\":[\"在粗略介绍 Sponge 协议后，我们一起来看看 Sponge 协议的具体实现逻辑和一些细节。\",\"在介绍 Sponge 协议时，采用的是先整体后局部的方式，而在说明具体实现时，需要先从局部出发，逐渐上升到整体，因此我们会先从 ByteStream 数据流开始，逐步添砖加瓦最后实现一个完成的 TCPConnection。\",\"这里先给出 Sponge 协议代码核心文件：\",\"libsponge/ ├── byte_stream.cc // ByteStream(数据流) 实现文件 ├── byte_stream.hh // ByteStream 头文件 ├── stream_reassembler.cc // StreamReassembler(数据流重组器) 实现文件 ├── stream_reassembler.hh // StreamReassembler 头文件 ├── tcp_connection.cc // TCPConnection(TCP连接) 实现文件 ├── tcp_connection.hh // TCPConnection 头文件 ├── tcp_receiver.cc // TCPReceiver(TCP接收者) 实现文件 ├── tcp_receiver.hh // TCPReceiver 头文件 ├── tcp_sender.cc // TCPSender(TCP发送者) 实现文件 ├── tcp_sender.hh // TCPSender 头文件 ├── wrapping_integers.cc // WrappingIntegers(包装32位seqno、ackno)实现文件 └── wrapping_integers.hh // WrappingIntegers 头文件 \"]},\"60\":{\"h\":\"ByteStream\",\"t\":[\"ByteStream 是一个基于内存、可靠的数据流实现类。Sponge 协议类似于 TCP 协议，也是一个基于字节流的网络协议，数据流是协议最核心的数据载体，在上面也谈到了，一个 TCPConnection 有两个数据流，分别用于数据输入和输出。\",\"ByteStream 是一个可读且可写且有容量限制的数据流。ByteStream 在初始化时，会被设置一个 capacity(容量) 参数，表示该数据流不能存储超过容量的字节数。ByteStream 实现是比较简单的，既可以直接使用 string(字符串)来实现，也可以使用 sponge 项目提供的 BufferList 来实现。\",\"推荐使用 BufferList，内部通过共享指针来实现字符串容器，减少字符串拷贝带来的性能、内存损耗。\",\"这里摘出 ByteStream 中几个重要的实现方法加以说明：\",\"ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {} size_t ByteStream::write(const string &data) { size_t sz = data.size(); // 如果数据超过了窗口大小，那么等于窗口大小 if (sz > _capacity - _buffer_size) { sz = _capacity - _buffer_size; } _stream.append(BufferList(move(string().assign(data.begin(), data.begin() + sz)))); _buffer_size += sz; _bytes_written += sz; return sz; } string ByteStream::peek_output(const size_t len) const { // peek 的长度不能超过 buffer_size const size_t peek_length = len > _buffer_size ? _buffer_size : len; string str = _stream.concatenate(); return string().assign(str.begin(), str.begin() + peek_length); } void ByteStream::pop_output(const size_t len) { // 不能超过 buffer_size size_t pop_length = len > _buffer_size ? _buffer_size : len; _stream.remove_prefix(pop_length); _bytes_read += pop_length; _buffer_size -= pop_length; // 更新 buffer_size } std::string ByteStream::read(const size_t len) { const string result = peek_output(len); pop_output(len); return result; } \",\"这段代码展示了 ByteStream 中最重要的 5 个方法：\",\"ByteStream 构造函数，用于初始化一个字节流；\",\"write 函数，向字节流中写入数据，注意写入数据的大小和当前缓冲区的大小加起来不能超过容量大小，然后将数据加入到 _stream 容器中，并且更新 buffer_size 和 bytes_written；\",\"peek_output 函数，查看字节流的前 len 个字节，peek_out 方法不会消费字节流，只会查看前 len 个字节，并且查询字节数量不能超过当前缓冲区字节的数量；\",\"pop_out 函数，移除字节流中的前 len 个字节，然后更新 bytes_read 和 buffer_size；\",\"read 函数，读取字节流中的前 len 个字节，注意 read 会消费流数据，读取后会移除前 len 个字节。 ByteStream 是 spong 项目中最简单的一部分，但也是最容易忽略的一部分，笔者最开始在实现的时候小觑了这里，以为通过了全部单测就没有问题了，但是在后面的测试中，发现数据有错误，debug 了好久才察觉是 ByteStream 有问题。\"]},\"61\":{\"h\":\"StreamReassembler\",\"t\":[\"一个 TCP 连接只有一个 StreamReassembler，用于 receiver 重组乱序的报文数据。由于 TCP 报文可能存在乱序、重复、缺少等各种各样的问题，receiver 收到的 TCP 报文数据不能直接写入到 ByteStream 中交付给应用程序。\",\"因此为了解决 TCP 报文数据乱序等问题，sponge 将重组这部分工作抽象为数据流重组器。由于网络延迟、丢包等场景，比如：\",\"发送 A、B 包，结果 B 包比 A 包更早到达，因此 B 包到达时，不可直接写入字节流；\",\"发送 A、B 包，接收 A 包丢了，只有 B 包达到，那么 B 包到达后也不可直接写入字节流，必须等待 A 包重发达到后。 为了解决这些问题，我们必须有序的组装 TCP 报文，如下：\",\"class StreamReassembler { private: ByteStream _output; //!< The reassembled in-order byte stream size_t _capacity; //!< The maximum number of bytes size_t _head_index; //!< 当前序号 // 重组节点 struct node { size_t begin = 0; size_t size = 0; std::string data{}; // 重载 < 符号，用于序列重组 bool operator<(const node &a) const { return begin < a.begin; } }; // 节点合并 long merge(node &n1, const node &n2); std::set<node> _set{}; // 数据容器，二叉树 size_t _unassembled_bytes; // 未组装字节个数 } \",\"我们在 StreamReassembler 的定义中添加了 _head_index 和 _set 字段：\",\"_head_index：当前已组装的字节序号，默认为 0，即没有字节被重组；\",\"_set：TCP 报文容器，每个 TCP 报文都被当作一个 node，包含了数据、序号等信息，node 存储在 set 中，set 内部是一个红黑树实现，支持节点有序化。 当一个报文数据被推入到重组器后，重组器判断报文头字节序号与 _head_index 之间的关系，对数据进行裁剪，得到当前数据节点，由于 set 中的 node 是按照 index 有序排列，寻找节点尝试合并数据重复的节点，合并完毕后，判断节点 index 与 _head_index 之间的关系，将 index 刚好等于 _head_index 的节点数据写入字节流中。如下：\",\"void StreamReassembler::push_substring(const string &data, const size_t index, const bool eof) { // 接收到 data 后，将新的连续的字节写入到流中 // 如果超过了 capacity 那么丢弃掉数据 // 如果 eof 为 true，那么接收的为最后一个字符串 size_t sz = data.size(); if (eof) { this->_eof = eof; } // 如果 sz == 0 或者 data 已经被重组了，那么直接返回 if (sz == 0 || sz + index < _head_index) { handle_eof(); return; } node cur; if (index < _head_index) { // 当前 index 小于 _head_index // 那么截取 index 后面有用的部分 size_t offset = _head_index - index; cur.begin = _head_index; cur.size = sz - offset; cur.data = data.substr(offset); } else { // 当 index >= _head_index cur.begin = index; cur.size = sz; cur.data = data; } _unassembled_bytes += cur.size; // 未重组 // 如果节点之间有数据重合，那么依次合并节点 long total = 0; // 向后合并 while (true) { // 找到第一个 >= cur.begin 的节点 auto next = _set.lower_bound(cur); if (next == _set.end()) { break; // 没有找到 } // next 是第一个 >= cur 的节点 // 合并 cur 和 next 到 cur long merged_count = merge(cur, *next); if (merged_count < 0) { break; // 小于 0，证明无法合并，直接 break } total += merged_count; // 合并 next 后然后删除 next，注意所有数据都被合并到了 cur 节点中 _set.erase(next); } // 向前合并 auto next = _set.lower_bound(cur); while (next != _set.begin()) { next--; // 得到前一个节点 long merged_count = merge(cur, *next); if (merged_count < 0) { break; } total += merged_count; _set.erase(next); next = _set.lower_bound(cur); // 找到下一个 } // 向前、向后一起合并了 total _unassembled_bytes -= total; // 插入 cur _set.insert(cur); // 合并完成以后，再来推进 _head_index while (!_set.empty() && _set.begin()->begin == _head_index) { auto begin = _set.begin(); size_t written = _output.write(begin->data); _head_index += written; _unassembled_bytes -= written; _set.erase(begin); // 删除已经合并的头节点 } handle_eof(); } \",\"上面代码已经对节点合并、_head_index 推进给出了详细注释。push_substring 是 StreamReassembler 中最复杂、最重要的函数，它接受三个参数：\",\"data：报文数据(不含 TCP header)；\",\"index：报文数据第一个字节的序号，注意是字节流的序号，根 seqno 有缺别，后面再细说；\",\"eof：是否收到了 fin 包数据，即是否要关闭输入数据流。 由于 set 容器中节点的有序性(node 重载了< 保证了 begin 小的节点在前面)，可通过 lower_bound 函数直接找到第一个大于等于当前节点 begin 的节点，然后尝试去合并二者。\",\"StreamReassembler 另外一个需要注意的点是何时关闭输入流，如下：\",\"void StreamReassembler::handle_eof() { if (_eof && empty()) { // 如果标记了结束，且为空 _output.end_input(); } } \",\"当收到 eof 为 true 时，不能立马关闭 _output，因为 fin 包可能先于其它数据包达到，因此我们必须缓存 eof，等待重组器中数据为空时再关闭输入流。\"]},\"62\":{\"h\":\"TCPReceiver\",\"t\":[\"TCPReceiver 是 TCP 连接的接收方，负责接收报文，并将报文数据(payload)交给 StreamReassembler 重组，得到正确的字节流序列。定义如下：\",\"class TCPReceiver { //! Our data structure for re-assembling bytes. StreamReassembler _reassembler; //! The maximum number of bytes we'll store. size_t _capacity; // 省略一些字段 std::optional<WrappingInt32> _isn{std::nullopt}; // absolute ack number uint64_t _abs_ackno; } \",\"_reassembler：数据流重组器；\",\"_capacity：容量，用于 _reassembler 初始化；\",\"_isn：收到的第一个 seqno；\",\"_abs_ackno：绝对确认序号。 这里需要额外说明一点：关于 WrappingInt32(seqno,ackno) 与 uint64_t(abs_seqno,abs_ackno)。\",\"在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如何随机生成的 isn 十分接近 2^32-1 怎么办？\",\"这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。\",\"另外在 StreamIndex 中的 push_string 函数有一个 index 参数，index 表示字节在数据流中的序号，那么这个序号与绝对 seqo 序号，以及 seqno 有什么联系呢？\",\"假设 isn = 2^32−2 且向数据流中写入 \\\"cat\\\" 三个字节，那么 seqno、abs_seqno、stream_index 之间的对应关系如下表：\",\"element\",\"syn\",\"c\",\"a\",\"t\",\"fin\",\"seqno\",\"2^32−2\",\"2^32−1\",\"0\",\"1\",\"2\",\"absolute_seqno\",\"0\",\"1\",\"2\",\"3\",\"4\",\"stream_index\",\"0\",\"1\",\"2\",\"seqno 溢出后，重新从 0 开始；\",\"absolute_seqno 从 0 开始，并与 seqno 一一对应；\",\"syn 和 fin 均占一个序列；\",\"stream_index 从 0 开始，但是不能包括 syn 与 fin。 实现 TCPReceiver 的核心函数有三个，如下：\",\"void TCPReceiver::segment_received(const TCPSegment &seg) { // Corner Case: // 如果包头部没有 syn，且 receiver 也没有 _syn 过，那么直接返回 // 第一个接收的包一定包含了 syn WrappingInt32 seqno = seg.header().seqno; if (!seg.header().syn && !_syn) { return; } bool first_syn = false; // 第一次收到 syn 包： // 设置 _isn 和 _syn if (seg.header().syn && !_syn) { _isn = std::make_optional(seqno); _syn = true; first_syn = true; } // 收到 fin 包，且本地没有 _fin if (seg.header().fin && !_fin) { _fin = true; } Buffer payload = seg.payload(); // 得到 seqno 对应的 abs_seqno // In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint. // checkpoint 为最后一个重组的字节序号，即 head_index uint64_t abs_seqno = unwrap(seqno, _isn.value(), _reassembler.head_index()); // 如果该 seqno 已经被接收过了，那么本次将忽略 // 如果超过了窗口阈值，那么也无法接收 if (abs_seqno + seg.length_in_sequence_space() <= _abs_ackno || abs_seqno >= _abs_ackno + window_size()) { return; } size_t stream_index = abs_seqno; // stream_index 默认为 abs_seqno string data = payload.copy(); // 如果 syn 也伴随着数据，那么 abs_seqno 应该等于 1 if (_syn && !first_syn && stream_index > 0) { // 如果 syn 那么 -= 1, syn 不算 stream_index -= 1; } // fin 会占有 seqno 序列，但是前提是内部已经关闭，数据流上达到了 fin if (_fin && _reassembler.stream_out().input_ended() && stream_index > 0) { // 如果 fin，那么 -= 1, fin 不算 stream_index -= 1; } // 推入数据 _reassembler.push_substring(data, stream_index, seg.header().fin); // 更新 _abs_ackno // 这个地方的 +1 直接抵消了 syn 包 _abs_ackno = _reassembler.head_index(); if (_syn) { _abs_ackno += 1; } // fin 且数据流关闭，才能确认 fin，这才是 fin 的真正关闭条件 // 即 FIN_RECV = stream_out().input_ended() if (_fin && _reassembler.stream_out().input_ended()) { _abs_ackno += 1; } return; } optional<WrappingInt32> TCPReceiver::ackno() const { // If the ISN hasn’t been set yet, return an empty optional if (!_isn.has_value()) { return std::nullopt; } // 注意：fin 包也占有一个序号 // This is the windows’s left edge: the first byte the receiver is interested in receiving. // _abs_ackno 已经在 segment_received 函数中做好了计算，直接 wrap 即可 return wrap(_abs_ackno, _isn.value()); } size_t TCPReceiver::window_size() const { // the distance between the “first unassembled” index (the index corresponding to the // ackno) and the “first unacceptable” index. // 已经确认的序列-未收到的序列 // 这里的 window_size 应该是 容量 - 已经在 StreamByte 中的字节数 // 即剩下可以接受且重组的字节数才是窗口大小 size_t sz = _capacity - _reassembler.stream_out().buffer_size(); return sz; } \",\"除了 segment_received 复杂一点，ackno 与 window_size 函数都比较简单，细节可以看看注释。这里额外说明一下：\",\"ackno 返回确认序号，注意是 WrappingInt32 类型，ackno 必须得 SYN 后才有，并通过 abs_ackno 与 isn 计算而来。\",\"window_size 返回当前接受者的窗口大小，其实就是字节流还能接收多少字节，用容量减去当前的缓冲区大小即可。 segment_received 是接收者最复杂的函数，需要处理很多边角逻辑，导致代码很多(主要也是因为笔者 C++菜的要死，也懒得重构)，有几个点需要说明一下：\",\"第一个包必须携带 SYN，否则直接拒绝；\",\"收到 FIN 后需要缓存；\",\"得到当前包序号 abs_seqno 后，需要判断是否超过了窗口；\",\"stream_index 与 abs_seqno 之间的关系转化，通过 first_syn 来帮助转换；\",\"_abs_ackno 实际为重组确认的当前序号，即 head_index，但必须包含 SYN 和 FIN。\"]},\"63\":{\"h\":\"TCPSender\",\"t\":[\"TCPSender 负责从输出流中读取数据并打包发送，主要功能点有：\",\"负责接收和缓存 ackno(确认序号)、window_size(窗口大小);\",\"缓存发送但没有被确认的报文，并在超时后重新发送；\",\"从输出流中读取数据并包装为报文，然后发送报文。 TCPSender 类定义如下：\",\"class TCPSender { private: //! our initial sequence number, the number for our SYN. WrappingInt32 _isn; //! outbound queue of segments that the TCPSender wants sent std::queue<TCPSegment> _segments_out{}; //! retransmission timer for the connection unsigned int _initial_retransmission_timeout; //! 当前的重试时间 unsigned int _current_retransmission_timeout; //! outgoing stream of bytes that have not yet been sent ByteStream _stream; //! the (absolute) sequence number for the next byte to be sent uint64_t _next_seqno{0}; //! 发送但未确认的包 std::queue<TCPSegment> _segments_in_flight{}; //! 发送但未确认的字节数 size_t _bytes_in_flight{0}; //! 滑动窗口大小，默认为 nullopt std::optional<uint16_t> _window_size{std::nullopt}; //! 确认序列 uint64_t _abs_ackno{0}; //! 已经重试的次数 unsigned int _consecutive_retransmissions{0}; //! 定时器 bool _timer{false}; //! 计时器 unsigned int _time_tick{0}; } \",\"_isn：初始序号，通过 random 随机生成，并设置到 header 中的 seqno 随报文发送到远端；\",\"_segments_out、_segments_in_flight：报文发送队列和报文已发送未确认队列，sender 只需将发送的报文推入到两个队列中即，其中 _segments_out 队列将会由上层的 TCPConnection 处理，而 _segments_in_flight 中的报文需要通过接受到的 ackno 来实时处理，将其中被确认的报文推出队列；\",\"_initial_retransmission_timeout、_current_retransmission_timeout、_time_tick 等：超时相关字段，对于发送但位确认的报文，一旦超时，sender 将重新发送 _segments_in_flight 中的报文，且重试时间是依次递增(*2)的，一旦将报文推入 _segments_in_flight 那么就开启计时，一旦 _segments_in_flight 为空，即报文均被确认，那么将关闭计时器。 相较于 TCPReceiver，TCPSender 的实现稍微复杂一些，有三个核心函数。\",\"核心函数 fill_window：负责从输出流中读取数据并打包为 TCP 报文，注意报文大小是有限制的，主要根据窗口大小来实时改变，因此一次可能打包多个报文，如下：\",\"void TCPSender::fill_window() { // 根据 window_size 填充数据到包中 // 首先要发送一个 SYN 包 if (!_first_syn) { _first_syn = true; TCPSegment seg; seg.header().syn = true; send_segment(seg); return; // 发送 syn 包后等待 ack 才继续发包 } // Corner Case: // 再没有 syn 的情况下，不填充 if (!_first_syn) { return; // 其它情况下，未 syn 则不进行任何发送操作 } // Corner Case: if (_fin) { return; // 都已经 fin 了，还发个鬼啊 } // _window_size 是 0 的时候，sender 将 _window_size 当作 1 看待 // 为什么需要看做为 1：因为可以同步 ackno 和 window_size size_t win = _window_size.value_or(0) > 0 ? _window_size.value() : 1; size_t remain; // 剩余窗口大小 // 当窗口没有满，且无 fin // _next_seqno - _abs_ackno 是窗口中待确认的字节数量大小 // 因此还可以发送的字节数 = win - (_next_seqno - _abs_ackno) while ((remain = (win - (_next_seqno - _abs_ackno))) > 0 && !_fin) { size_t sz = min(remain, TCPConfig::MAX_PAYLOAD_SIZE); TCPSegment seg; string payload = _stream.read(sz); seg.payload() = Buffer(move(payload)); // 如果包的大小小于窗口大小，且流已经 eof 了，那么作为 fin(最后一个) 包发送 if (seg.length_in_sequence_space() < win && _stream.eof()) { seg.header().fin = true; _fin = true; } // 注意：fin 包可能没有任何数组，但是如果提前判读包的大小，那么 fin 包 // 在被设置 header 之前就被 return 了，当前的 fin 包就丢失了 if (seg.length_in_sequence_space() == 0) { return; // 空包直接返回，注意 } // 每次发送一个包，就会更新 _next_seqno，直到无包可发送 send_segment(seg); } } \",\"具体逻辑参考注释，这里额外说明几点：\",\"如果是第一次填充，那么必须为 SYN 包，并且打包后直接发送；\",\"在没有 SYN 或者已经 FIN 的情况下，直接返回；\",\"窗口大小可能为空，必须在接受对端包的情况下才知道对端的接受窗口大小；\",\"如果输出流已经关闭，且包长度小于窗口大小，那么作为最后一个包发送，设置为 FIN；\",\"如果包长度为 0，那么直接返回，不用发送，空包有另外的处理。 核心函数 ack_received：接受确认序号(ackno)和窗口大小(window_size)，处理_segments_in_flight 中的包，将已经确认的报文推出队列，如下：\",\"void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) { // 得到绝对序号 abs_ackno uint64_t abs_ackno = unwrap(ackno, _isn, _next_seqno); // Corner Case: if (abs_ackno > _next_seqno) { // 太大了，确认不了 return; } // 设置 _window_size _window_size = make_optional(window_size); // Corner Case: if (abs_ackno <= _abs_ackno) { return; // 已经确认过了，不用再确认 } // 设置 _abs_ackno _abs_ackno = abs_ackno; // 根据 ackno 移除掉 _segments_in_flight 中的包 while (!_segments_in_flight.empty()) { TCPSegment front = _segments_in_flight.front(); uint64_t abs_seqno = unwrap(front.header().seqno, _isn, _next_seqno); size_t len = front.length_in_sequence_space(); // 如果包头部序号 + 长度 <= 确认序号 // 那么表示包被确认了 if (abs_seqno + len <= _abs_ackno) { _segments_in_flight.pop(); // 计数 _bytes_in_flight -= len; } else { break; } } // 收到确认包后，必须重置定时器时间和重试次数 _current_retransmission_timeout = _initial_retransmission_timeout; _consecutive_retransmissions = 0; // 如果新的包被确认，且还有包未确认，则重新开始定时 if (!_segments_in_flight.empty()) { _timer = true; _time_tick = 0; } return; } \",\"说明：\",\"_segments_in_flight 中的报文如何被确认？很简单，比较报文中的序号、报文长度与确认序号之间的关系，如果报文头部序号 + 长度 <= 确认序号，那么该报文被确认，并且推出队列；\",\"另外一旦收到 ackno，那么必须重置超时时间为最初超时时间，且重试次数为 0；\",\"所有包确认后，关闭定时器。 核心函数 tick：增加定时器时间，如果发生了超时那么重新发送报文，如下：\",\"void TCPSender::tick(const size_t ms_since_last_tick) { // 重新发送最早的包，注意不是所有过期的包 if (!_timer) { return; } _time_tick += ms_since_last_tick; // 重试一次就 double 重试时间 if (_time_tick >= _current_retransmission_timeout && !_segments_in_flight.empty()) { TCPSegment front = _segments_in_flight.front(); // 重新发送 _segments_out.push(front); // 定时器重置 _time_tick = 0; _timer = true; // 超时次数+1 // 注意：When filling window, treat a '0' window size as equal to '1' but don't back off RTO // 所以如果 window_size == 0，那么不能对超时时间进行翻倍，只能增加重试次数 _consecutive_retransmissions += 1; // 窗口没有设置过 或者 窗口大小不为 0 if (!_window_size.has_value() || (_window_size.has_value() && _window_size.value() != 0)) { _current_retransmission_timeout *= 2; } } // 所有数据都被确认了，关闭定时器 if (_segments_in_flight.empty()) { _timer = false; } } \",\"说明：\",\"如果定时器没有开启，那么直接返回，注意定时器在包进入 _segments_in_flight 后才会开启，在队列清空后停止；\",\"每次超时重发，只会重发队首的报文，不会重发所有报文；\",\"重发后，重试次数 +1，且超时时间 *=2。\"]},\"64\":{\"h\":\"TCPConnection\",\"t\":[\"TCPConnection 负责将 TCPSender 和 TCPReceiver 组合起来，维护 TCP 状态机、收、发包等功能。定义如下：\",\"class TCPConnection { private: TCPConfig _cfg; TCPReceiver _receiver{_cfg.recv_capacity}; TCPSender _sender{_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn}; //! outbound queue of segments that the TCPConnection wants sent std::queue<TCPSegment> _segments_out{}; //! Should the TCPConnection stay active (and keep ACKing) //! for 10 * _cfg.rt_timeout milliseconds after both streams have ended, //! in case the remote TCPConnection doesn't know we've received its whole stream? bool _linger_after_streams_finish{true}; // 上一个包接受距现在时间 size_t _time_since_last_segment_received{0}; //! 是否处于激活状态 bool _active{true}; } \",\"TCPConnection 的字段比较少：\",\"_cfg：TCP 配置，如默认超时时间，最大包长度等；\",\"_receiver：接收者；\",\"_sender：发送者；\",\"_time_since_last_segment_received：最后报文接受到现在时间间隔；\",\"_active：连接是否处于激活状态；\",\"_linger_after_streams_finish：是否在数据流结束后等待(涉及到连接关闭，下面会介绍)。 TCPConnection 主要做如下三件事情：\",\"接收报文，当 TCP 报文达到时，TCPConnection 的 segment_received 方法会被调用，并做如下处理：\",\"如果报文头部含有 RST，将输入、输出流设置为错误状态，并且永久关闭连接；\",\"将报文传递给 receiver，即调用 receiver.segment_received 方法；\",\"如果报文头部中含有 ACK，那么调用 sender.ack_received 方法；\",\"如果收到的报文的长度 > 0(包含数据、SYN、FIN)，那么必须至少回复一个报文，来告诉对端 ackno 和 window_size。\",\"发送报文：\",\"任何时候，sender 将报文推入到其队列后，TCPConnection 负责将队列中的报文拿出来，设置额外的字段，并放入自己的队列，等待被发送；\",\"在推入报文到队列之前，TCPConnection 必须从 receiver 哪里拿到 ack、ackno 和 window_size 并填充到报文中。\",\"计时： _ 每当计时(tick)发生时，TCPConnection 负责将消耗时间告诉 sender； _ 如果报文重试次数超过了 MAX_RETX_ATTEMPTS，那么发送 RST 包，并关闭连接； 核心函数 segment_received 负责接收报文工作：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 接收包 if (!_active) { return; } _time_since_last_segment_received = 0; // 刷新时间 auto header = seg.header(); // Corner Case: // ACKs in LISTEN should be ignored // 如果处于 listen 状态，那么无法接受 ack 包，必须先接受 syn 包 if (header.ack && state() == TCPState::State::LISTEN) { return; } // 如果 header 中有 ack, 那么调用 _sender.ack_received if (header.ack) { _sender.ack_received(header.ackno, header.win); } // _receiver 接收包 _receiver.segment_received(seg); // if the rst (reset) flag is set, sets both the inbound and outbound streams to the error state // and kills the connection permanently. // 无论是客户端还是服务端，收到 rst 包后，都应该准备关闭输入、输出 if (header.rst) { // Corner Case: // all RSTs should be ignored in LISTEN // 如果在 listen 状态，那么所有 RST 都应该忽略 if (state() == TCPState::State::LISTEN) { return; } // 关闭连接 unclean_shutdown(); } // 是否需要发送空包，空包用于 ack bool send_empty = false; // Corner Case: // if the incoming segment occupied any sequence numbers, // the TCPConnection makes sure that at least one segment is sent in reply, // to reflect an update in the ackno and window size. // 任何长度大于 0 的包，都应该 ack 回应 if (seg.length_in_sequence_space() > 0) { send_empty = true; } // Corner Case: // 如果没有 ackno 确认，即 _receiver.segment_received(seg) 失败，则不能发送空包 if (!_receiver.ackno().has_value()) { send_empty = false; } // 尝试去发包回复，注意是尝试，因为如果 _sender 中无数据发送且也无需发送空包 // 那么 send_segment 并不会发包 send_segment(false, false, send_empty); } void TCPConnection::send_segment(bool syn, bool rst, bool send_empty) { // 从 sender 中拿出包，然后再 push_out _sender.fill_window(); // 填充包 // 如果填充后仍然为空，但必须发送一个空包 if (_sender.segments_out().empty() && send_empty) { _sender.send_empty_segment(); } TCPSegment seg; while (!_sender.segments_out().empty()) { // 从 _sender 的队列中拿出 seg = _sender.segments_out().front(); _sender.segments_out().pop(); if (syn) { seg.header().syn = true; } if (rst) { seg.header().rst = true; } // 如果 receiver ack 过，那么填充 win, ack, ackno if (_receiver.ackno().has_value()) { seg.header().ack = true; seg.header().ackno = _receiver.ackno().value(); seg.header().win = _receiver.window_size(); } _segments_out.push(seg); // 当前发送队列 } clean_shutdown(); } \",\"代码上有详细的注释，尤其是一些 Corner Case 需要注意，这里额外说明一下：\",\"必须在有 ack 的情况下，才能调用 _sender.ack_received；\",\"记得调用 _receiver.segment_received；\",\"任何长度大于 0 的包，都应该至少回应一个包，这个包可能为空包，因此需设置 send_empty。 发送空包是 sender 提供的函数，如下：\",\"void TCPSender::send_empty_segment() { // 发送空包 TCPSegment seg; seg.header().seqno = wrap(_next_seqno, _isn); _segments_out.push(seg); } \",\"那么为什么需要发送空包呢？其实很简单，因为对于远端的包，我们需要及时的回复，但是本端可能没有数据回复，也无需确认(无需加入 _segments_in_flight 队列)，因此需要一个空包(无数据)携带 ackno，window_size 等字段到达对端同步信息。 注意，TCPConnection 应在任何时候都调用 send_segment 尝试发送报文，如：\",\"size_t TCPConnection::write(const string &data) { // Write data to the outbound byte stream // 向输出流写数据，即 sender if (data.size() == 0) { return 0; } size_t sz = _sender.stream_in().write(data); send_segment(); return sz; } \",\"应用程序通过 write 函数向输出流写入数据后，也应该调用 send_segment 尝试发送报文。 TCPConnection 另一个重要的工作在于计时：\",\"void TCPConnection::tick(const size_t ms_since_last_tick) { if (!_active) { return; } _time_since_last_segment_received += ms_since_last_tick; // 1. tell the TCPSender about the passage of time. _sender.tick(ms_since_last_tick); // 2. abort the connection, and send a reset segment to the peer (an empty segment with the rst flag set), // if the number of consecutive retransmissions is more than an upper limit TCPConfig::MAX RETX ATTEMPTS. // 如果超过了重试次数，那么准备关闭连接 if (_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS) { // 3. end the connection cleanly if necessary unclean_shutdown(); send_segment(false, true); // 发送 rst 包 } // 4. 重试发送 // 超时，_sender 会发送到队列中 // Corner Case: // 如果处于 listen 状态，那么只应该等待，不应该 send if (state() != TCPState::State::LISTEN) { send_segment(); } } \",\"每当调用 tick 函数时，增加 _time_since_last_segment_received 并且调用 _sender.tick，然后判断重试次数，如果超过了默认重试次数，那么发送 RST 包，并且关闭连接。 在刚才的代码中，unclean_shutdown 和 clean_shutdown 函数多次出现，这两个函数都与连接关闭有直接关系，并且涉及到不同的连接关闭方式。\",\"方式 1：非干净关闭，TCP 连接接收 RST 包，或者被析构、重试次数超过了默认次数，立马关闭输入、输出流，然后设置 active 为 false；\",\"方式 2：干净关闭，没有任何错误产生，双方都全部完成了数据交付和接收，然后设置 active 为 false。\",\"unclean_shutdown(非干净关闭)是比较简单的，在收到 RST 包、析构、重试失败的时机下调用即可：\",\"void TCPConnection::unclean_shutdown() { _receiver.stream_out().set_error(); _sender.stream_in().set_error(); _active = false; } \",\"而 clean_shutdown 是比较麻烦，建立在数据完全交付的情况下，需要满足一下几个条件：\",\"输入流(receiver)已经完全重组且结束；\",\"输出流(sender)已结束，并且已经全部发送到对端；\",\"输出流已经完全被对端确认；\",\"： 1. 数据流结束后不等待，即 _linger_after_streams_finish 为 false； 2. _time_since_last_segment_received 已经超过了 10 倍超时时间。 clean_shutdown 必须同时满足条件 1，3，以及 4 的一个字条件，如下：\",\"void TCPConnection::clean_shutdown() { // The inbound stream has been fully assembled and has ended. if (_receiver.stream_out().input_ended()) { // The outbound stream has been ended by the local application and fully sent (including // the fact that it ended, i.e. a segment with fin ) to the remote peer. if (!_sender.stream_in().eof()) { // If the inbound stream ends before the TCPConnection // has reached EOF on its outbound stream, this variable needs to be set to false. _linger_after_streams_finish = false; } else if (_sender.bytes_in_flight() == 0) { // The outbound stream has been fully acknowledged by the remote peer. if (!_linger_after_streams_finish || _time_since_last_segment_received >= 10 * _cfg.rt_timeout) { _active = false; } } } } \",\"input_ended 表示输入流结束，bytes_in_flight 为 0，表示输出流已经完全被对端接收且确认。 关于 _linger_after_streams_finish 这个变量需要额外说明一下，它表示流结束后是否需要等待，默认为 true，表示需要等待，因为即使流结束了，但是可能对端没有完全确认，因此需要等待，等待时间为 10 * _cfg.rt_timeout，即子条件 b。\",\"那么如何不等待了？当输入流关闭，而输出流没有结束时，这表示远端已经发送了 FIN 包，所以输入流才能关闭，因此这个状态属于被动关闭，所以无需考虑输出流能否全部交付的问题，因此对端已经不再接受包了，所以彼端可以直接设置 active 为 false。\"]},\"65\":{\"h\":\"Sponge 使用\",\"t\":[\"到此一个简易版 TCP——Sponge 协议已经实现完毕了，详细代码见参考资料链接。接下来，我们需要去使用一下该协议，从中来看看三次握手是如何发生的。\",\"首先，通过新建 UDPSocket 监听本地 3000 端口：\",\"int main(/*int argc, char **argv*/) { try { TCPConfig c_fsm{}; FdAdapterConfig c_filt{}; Address addr{\\\"127.0.0.1\\\", 3000}; c_filt.source = addr; UDPSocket udp_sock; udp_sock.bind(c_filt.source); LossyTCPOverUDPSpongeSocket tcp_socket(LossyTCPOverUDPSocketAdapter(TCPOverUDPSocketAdapter(move(udp_sock)))); // 开始监听 tcp_socket.listen_and_accept(c_fsm, c_filt); while (!tcp_socket.eof()) { const string res = tcp_socket.read(); cout << \\\"INFO: received from remote: \\\" << res << \\\" \\\\n\\\"; } tcp_socket.wait_until_closed(); } catch (const exception &e) { cerr << \\\"Exception: \\\" << e.what() << endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } \",\"UDPSocket 为对 socket API UDP 协议的封装，然后通过 LossyTCPOverUDPSocketAdapter 等适配器将其适配适配到 TCPConnection 上，感兴趣的可以查看源码(非常值得一读)。 绑定本地 3000 端口，然后从 socket 中读取数据。\",\"然后新建客户端连接 3000 端口：\",\"int main(/*int argc, char **argv*/) { try { TCPConfig c_fsm{}; FdAdapterConfig c_filt{}; Address addr{\\\"127.0.0.1\\\", 3000}; c_filt.destination = addr; UDPSocket udp_sock; LossyTCPOverUDPSpongeSocket tcp_socket(LossyTCPOverUDPSocketAdapter(TCPOverUDPSocketAdapter(move(udp_sock)))); // 连接 tcp_socket.connect(c_fsm, c_filt); // 发送数据 for (size_t i = 0; i < 10; i++) { cout << \\\"INFO: wite Hello Pedro! to stream \\\\n\\\"; tcp_socket.write(\\\"Hello Pedro!\\\"); // 休眠 1s std::this_thread::sleep_for(std::chrono::milliseconds(1000)); } tcp_socket.wait_until_closed(); } catch (const exception &e) { cerr << \\\"Exception: \\\" << e.what() << endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } \",\"同样的通过 UDPSocket 新建 socket 然后适配到 TCPConnection 中，调用 connect 发起连接，然后向 socket 中定时写入数据。 先运行服务端、再运行客户端。\",\"服务端：\",\"$ ./apps/tcp_udp_server DEBUG: Listening for incoming connection... DEBUG: [三次握手第二步] 服务端发送 SYN + ACK 包 New connection from 127.0.0.1:39239. INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! DEBUG: Inbound stream from 127.0.0.1:39239INFO: received from remote: DEBUG: Waiting for clean shutdown... finished cleanly. DEBUG: Outbound stream to 127.0.0.1:39239 finished (1 byte still in flight). DEBUG: Outbound stream to 127.0.0.1:39239 has been fully acknowledged. DEBUG: TCP connection finished cleanly. done. \",\"客户端：\",\"$ ./apps/tcp_udp_client DEBUG: Connecting to 127.0.0.1:3000... DEBUG: [三次握手第一步] 客户端发送 SYN 包 DEBUG: [三次握手第三步] 客户端发送 ACK 包 Successfully connected to 127.0.0.1:3000. INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream DEBUG: Waiting for clean shutdown... DEBUG: Outbound stream to 127.0.0.1:3000 finished (1 byte still in flight). DEBUG: Outbound stream to 127.0.0.1:3000 has been fully acknowledged. DEBUG: Inbound stream from 127.0.0.1:3000 finished cleanly. DEBUG: Waiting for lingering segments (e.g. retransmissions of FIN) from peer... DEBUG: TCP connection finished cleanly. done. \",\"从终端输出中可以看到，双方三次握手的过程，在代码中是这样发生。 首先，客户端调用 connect 函数发出连接，即 SYN 包，这是三次握手的第一步：\",\"void TCPConnection::connect() { // Initiate a connection by sending a SYN segment // 客户端发起连接，向服务端发送 SYN 包，三次握手第一步 if (_first_syn) { cerr << \\\"DEBUG: [三次握手第一步] 客户端发送 SYN 包 \\\" << endl; _first_syn = false; } send_segment(true, false); } \",\"在 connect 函数且没有发生过 SYN 的情况下，就是三次握手的第一步。 三次握手第二步，由服务器发送 SYN + ACK 包：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 省略代码... if (header.syn && !header.ack && send_empty) { cerr << \\\"DEBUG: [三次握手第二步] 服务端发送 SYN + ACK 包 \\\" << endl; } send_segment(false, false, send_empty); } \",\"服务器收到 SYN 包后，判断头部没有 ACK，且发送空包，则向客户端发送 SYN + ACK 包，即三次握手第二步。 三次握手第三步，客户端收到 SYN + ACK 包，发送 ACK 包：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 省略代码... if (header.ack) { if (_first_ack && state() == TCPState::State::SYN_SENT) { cerr << \\\"DEBUG: [三次握手第三步] 客户端发送 ACK 包 \\\" << endl; _first_ack = false; } _sender.ack_received(header.ackno, header.win); } // 省略代码... } \",\"客户端在收到第一个 ACK 包，且处于 SYN_SENT 状态下，接收 ackno，并向服务器发送 ACK 包。至此，三次握手全部完成，双方进入可靠通信阶段，即终端输出的 10 次 Hello Pedro! 。 当客户端数据全部发送完毕，且被确认，客户端会关闭输出流，然后干净地关闭连接，服务端在收到对端关闭后，进入被动关闭状态，等待超时，然后干净地关闭连接(参考终端输出的 DEBUG 日志)。\",\"那么 Sponge 协议的性能怎么样呢？sponge 项目提供了 benchmark 程序，运行结果如下：\",\"./apps/tcp_benchmark CPU-limited throughput : 2.35 Gbit/s CPU-limited throughput with reordering: 1.58 Gbit/s \"]},\"66\":{\"h\":\"总结\",\"t\":[\"网络协议是一个非常有趣的东西，在互联网普及的今天，基本覆盖了我们生活的方方面面。CS144 是一门好课，将理论知识巧妙和实践结合，在完成 sponge 项目的过程中可以从理论、实践上充分的吸收网络知识，当然 sponge 中还有 IPv4 协议、ARP 协议、路由跳转等多个网络层协议的实现，基本覆盖了网络知识的方方面面，这里就不展开讲了，感兴趣的可以点开参考资料上的连接了解一下。\",\"最后，我们下一个系列再见～\"]},\"67\":{\"h\":\"参考资料\",\"t\":[\"CS 144: Introduction to Computer Networking, Fall 2020\",\"深入理解 TCP 协议：从原理到实战\",\"sponge 项目代码\"]},\"68\":{\"h\":\"Buffer-Sharing\"},\"69\":{\"h\":\"Buffer-Sharing-in-Multi-tenant-Database-Environment\",\"t\":[\"ICPC 2023 Online Spring Challenge powered by Huawei rank 118(regrettably didn't get 800 EUR)\"]},\"70\":{\"h\":\"1.Overview of task demand\",\"t\":[\"The task ask competitors to accomplish the optimal scheduling algorithm to make page-evict smallest,the difficult is when the buffer sharing is full,which user should be chosen and which block shold be removed.For this problem,I accomlish one scheduling algorithm based on shadow price and LRU-hot cold zone.\"]},\"71\":{\"h\":\"2.Solution\"},\"72\":{\"h\":\"2.1 the algorithm to choose user to be dispatch\",\"t\":[\"When the buffer size is full,we should choose one previous block to remove for the new block,firstly we can designate one user to be dispatched.Through analysing the Scoring function, we can find that SLA is the important indicator that measure the user experience.So we can calculate the derivative of the score function,then we can choose the user has the smallest derivative,which is based on shadow price. In practice,we should firstly accomplish the SLAbase algorithm,then we can caluculate the SLA compared with the page-evict of SLAbase algorithm.\"]},\"73\":{\"h\":\"2.2 the algorithm to choose block\",\"t\":[\"After we choose the user to dispatch,we should select which block of the user should be evicted from the buffer.In this step,due to the time limit,I accomplish the LRU base algorithm.For every user's block,we user the LRU to record the block status.When one block should be removed,we can remove one specific block based on LRU theory.As an improvement,I divide the LRU to two zone(cold zone and hot zone),which refer the mySql concept of cold and hot data.When one data is visited more than ome time,it enter the hot zone.When one block should be removed,we firstly select the block from the cold.And the size of cold and hot zone can be pointed in the initialization.\"]},\"74\":{\"h\":\"3.Improvement\",\"t\":[\"In fact,for 2.2,you can accomplish other different algorithm like LFU,MFU,and choose the best algorithm for the given data is to simulate all of them, keep track of their hit rate, and switch to the best performing one.\",\"source code\"]},\"75\":{\"h\":\"基于外点法的分式优化问题\"},\"76\":{\"h\":\"1.问题定义\",\"t\":[\"该问题为带约束的优化问题，约束包括等式约束和不等式约束两部分，本问题难点在于两个，一个是待优化变量维数较高，另一个是初始点难以确定，很难给出有效的初始点\"]},\"77\":{\"h\":\"2.问题分析\",\"t\":[\"因初始点难以选取，因此我们采用外点法进行优化，因为外点法无需从有效的初始点出发进行迭代，因此我们可以从任意点出发进行迭代求解；接着我们将原先的带约束优化问题改为无约束优化问题，将约束条件乘上惩罚系数与原函数相加，将此作为无约束问题进行求解\",\"外点法具体定义和步骤:\"]},\"78\":{\"h\":\"3.实际求解\",\"t\":[\"使用pytorch框架，进行算法实现，因为pytorch实现了自动微分机制，不用我们再手动求导；并且我们可以使用pytorch中自带的优化器，进行优化问题的迭代，在这里我们选择torch.optim.LBFGS作为优化器，该优化器基于牛顿迭代法，相比于SGD可以显著提高收敛速度，并且该问题二阶可导，基本上10几步均可收敛\",\"代码地址\"]},\"79\":{\"h\":\"Database\"},\"80\":{\"h\":\"Posts\"},\"81\":{\"h\":\"Ai\"},\"82\":{\"h\":\"Network\"},\"83\":{\"h\":\"Optimization\"}},\"dirtCount\":0,\"index\":[[\"外点法具体定义和步骤\",{\"1\":{\"77\":1}}],[\"问题分析\",{\"0\":{\"77\":1}}],[\"问题定义\",{\"0\":{\"76\":1}}],[\"zone\",{\"1\":{\"70\":1,\"73\":5}}],[\"zhihu\",{\"1\":{\"37\":1}}],[\"zhuanlan\",{\"1\":{\"37\":1}}],[\"路由跳转等多个网络层协议的实现\",{\"1\":{\"66\":1}}],[\"路径最大传输单元\",{\"1\":{\"53\":1}}],[\"网络协议是一个非常有趣的东西\",{\"1\":{\"66\":1}}],[\"网络层和传输层\",{\"1\":{\"49\":1}}],[\"运行结果如下\",{\"1\":{\"65\":1}}],[\"程序\",{\"1\":{\"65\":1}}],[\"次\",{\"1\":{\"65\":1}}],[\"次数是数据库提升查询效率的主要途径之一\",{\"1\":{\"9\":1}}],[\"至此\",{\"1\":{\"65\":1}}],[\"省略代码\",{\"1\":{\"65\":3}}],[\"省略一些字段\",{\"1\":{\"62\":1}}],[\"服务端在收到对端关闭后\",{\"1\":{\"65\":1}}],[\"服务端发送\",{\"1\":{\"65\":2}}],[\"服务端\",{\"1\":{\"65\":1}}],[\"服务器收到\",{\"1\":{\"51\":1,\"65\":1}}],[\"先运行服务端\",{\"1\":{\"65\":1}}],[\"先移动一条腿\",{\"1\":{\"20\":1}}],[\"休眠\",{\"1\":{\"65\":1}}],[\"绑定本地\",{\"1\":{\"65\":1}}],[\"监听本地\",{\"1\":{\"65\":1}}],[\"详细代码见参考资料链接\",{\"1\":{\"65\":1}}],[\"倍超时时间\",{\"1\":{\"64\":1}}],[\"建立在数据完全交付的情况下\",{\"1\":{\"64\":1}}],[\"析构\",{\"1\":{\"64\":1}}],[\"干净关闭\",{\"1\":{\"64\":1}}],[\"立马关闭输入\",{\"1\":{\"64\":1}}],[\"立即解锁成功\",{\"1\":{\"36\":1}}],[\"非常值得一读\",{\"1\":{\"65\":1}}],[\"非干净关闭\",{\"1\":{\"64\":2}}],[\"非空\",{\"1\":{\"18\":1}}],[\"方式\",{\"1\":{\"64\":2}}],[\"方法会被调用\",{\"1\":{\"64\":1}}],[\"方法会根据事务隔离级别\",{\"1\":{\"35\":1}}],[\"方法不会消费字节流\",{\"1\":{\"60\":1}}],[\"方法尝试得到待发送报文\",{\"1\":{\"58\":1}}],[\"方法时\",{\"1\":{\"35\":1}}],[\"方法接受两个参数\",{\"1\":{\"35\":1}}],[\"方法主要流程如下\",{\"1\":{\"26\":1}}],[\"方法分别用来初始化表元数据\",{\"1\":{\"26\":1}}],[\"方法来获取数据记录的\",{\"1\":{\"26\":1}}],[\"方法来获取所有符合条件的数据记录\",{\"1\":{\"25\":1}}],[\"方法可根据\",{\"1\":{\"25\":1}}],[\"方法\",{\"1\":{\"25\":4,\"26\":1,\"58\":3,\"64\":2}}],[\"方法为例\",{\"1\":{\"11\":1}}],[\"方法删除页\",{\"1\":{\"10\":1}}],[\"方法向\",{\"1\":{\"10\":1}}],[\"增加\",{\"1\":{\"64\":1}}],[\"增加定时器时间\",{\"1\":{\"63\":1}}],[\"尝试发送报文\",{\"1\":{\"64\":2}}],[\"尝试去发包回复\",{\"1\":{\"64\":1}}],[\"携带\",{\"1\":{\"64\":1}}],[\"队列\",{\"1\":{\"64\":1}}],[\"队列将会由上层的\",{\"1\":{\"63\":1}}],[\"记得调用\",{\"1\":{\"64\":1}}],[\"记录发送但未确认的报文\",{\"1\":{\"58\":1}}],[\"记录事务处理期间的操作\",{\"1\":{\"39\":1}}],[\"记录的共享锁\",{\"1\":{\"35\":1}}],[\"记录查询等\",{\"1\":{\"24\":1}}],[\"填充包\",{\"1\":{\"64\":1}}],[\"填充数据到包中\",{\"1\":{\"63\":1}}],[\"失败\",{\"1\":{\"64\":1}}],[\"哪里拿到\",{\"1\":{\"64\":1}}],[\"涉及到连接关闭\",{\"1\":{\"64\":1}}],[\"涉及到好几个类和几千行代码\",{\"1\":{\"16\":1}}],[\"配置\",{\"1\":{\"64\":1}}],[\"收\",{\"1\":{\"64\":1}}],[\"收到确认包后\",{\"1\":{\"63\":1}}],[\"收到\",{\"1\":{\"62\":2,\"64\":1}}],[\"收到的第一个\",{\"1\":{\"62\":1}}],[\"收到的\",{\"1\":{\"61\":1}}],[\"收到报文后\",{\"1\":{\"58\":1}}],[\"维护\",{\"1\":{\"64\":1}}],[\"组合起来\",{\"1\":{\"64\":1}}],[\"比较报文中的序号\",{\"1\":{\"63\":1}}],[\"比如都是共享锁\",{\"1\":{\"35\":1}}],[\"比如\",{\"1\":{\"26\":1,\"34\":1,\"35\":1,\"61\":1}}],[\"比如更新时\",{\"1\":{\"20\":1}}],[\"移除掉\",{\"1\":{\"63\":1}}],[\"移除字节流中的前\",{\"1\":{\"60\":1}}],[\"太大了\",{\"1\":{\"63\":1}}],[\"接着我们将原先的带约束优化问题改为无约束优化问题\",{\"1\":{\"77\":1}}],[\"接下来\",{\"1\":{\"65\":1}}],[\"接受确认序号\",{\"1\":{\"63\":1}}],[\"接收包\",{\"1\":{\"64\":2}}],[\"接收报文\",{\"1\":{\"64\":1}}],[\"接收者\",{\"1\":{\"64\":1}}],[\"接收到\",{\"1\":{\"61\":1}}],[\"接收\",{\"1\":{\"61\":1,\"65\":1}}],[\"接收确认号\",{\"1\":{\"58\":1}}],[\"接收分别由\",{\"1\":{\"58\":1}}],[\"剩余窗口大小\",{\"1\":{\"63\":1}}],[\"看待\",{\"1\":{\"63\":1}}],[\"才继续发包\",{\"1\":{\"63\":1}}],[\"才能调用\",{\"1\":{\"64\":1}}],[\"才能确认\",{\"1\":{\"62\":1}}],[\"才能对\",{\"1\":{\"33\":1}}],[\"才能继续执行\",{\"1\":{\"31\":1}}],[\"才能释放所有持有的锁\",{\"1\":{\"20\":1}}],[\"才能释放祖先节点的锁\",{\"1\":{\"20\":1}}],[\"核心函数\",{\"1\":{\"63\":3,\"64\":1}}],[\"超时\",{\"1\":{\"64\":1}}],[\"超时次数+1\",{\"1\":{\"63\":1}}],[\"超时相关字段\",{\"1\":{\"63\":1}}],[\"超时重传\",{\"1\":{\"52\":1}}],[\"随报文发送到远端\",{\"1\":{\"63\":1}}],[\"随机生成\",{\"1\":{\"63\":1}}],[\"随后尝试发送报文\",{\"1\":{\"58\":1}}],[\"随后根据删除后的节点大小来决定重组\",{\"1\":{\"19\":1}}],[\"初始序号\",{\"1\":{\"63\":1}}],[\"初始化为\",{\"1\":{\"62\":1}}],[\"初始化为随机数\",{\"1\":{\"62\":1}}],[\"初始化\",{\"1\":{\"62\":1}}],[\"初始化新的根节点\",{\"1\":{\"18\":1}}],[\"初始化根节点\",{\"1\":{\"18\":1}}],[\"定时器重置\",{\"1\":{\"63\":1}}],[\"定时器\",{\"1\":{\"63\":1}}],[\"定义\",{\"1\":{\"26\":1}}],[\"定义了\",{\"1\":{\"26\":1}}],[\"定义如下\",{\"1\":{\"10\":1,\"11\":1,\"41\":1,\"62\":1,\"64\":1}}],[\"滑动窗口大小\",{\"1\":{\"63\":1}}],[\"滑动窗口等知识点背得滚瓜烂熟\",{\"1\":{\"49\":1}}],[\"细节可以看看注释\",{\"1\":{\"62\":1}}],[\"复杂一点\",{\"1\":{\"62\":1}}],[\"复杂结构\",{\"1\":{\"45\":1}}],[\"除了\",{\"1\":{\"62\":1}}],[\"除了根\",{\"1\":{\"15\":1}}],[\"yet\",{\"1\":{\"62\":1,\"63\":1}}],[\"your\",{\"1\":{\"62\":1}}],[\"you\",{\"1\":{\"35\":1,\"62\":1,\"74\":1}}],[\"应用程序通过\",{\"1\":{\"64\":1}}],[\"应用程序构建执行计划\",{\"1\":{\"5\":1}}],[\"应在任何时候都调用\",{\"1\":{\"64\":1}}],[\"应该是\",{\"1\":{\"62\":1}}],[\"应该等于\",{\"1\":{\"62\":1}}],[\"均占一个序列\",{\"1\":{\"62\":1}}],[\"溢出后\",{\"1\":{\"62\":1}}],[\"假设\",{\"1\":{\"62\":1}}],[\"怎么办\",{\"1\":{\"62\":1}}],[\"十分接近\",{\"1\":{\"62\":1}}],[\"位\",{\"1\":{\"62\":1}}],[\"位整数\",{\"1\":{\"62\":1}}],[\"位于节点\",{\"1\":{\"19\":1}}],[\"绝对确认序号\",{\"1\":{\"62\":1}}],[\"绝大多数操作系统会在内核中提供\",{\"1\":{\"56\":1}}],[\"证明无法合并\",{\"1\":{\"61\":1}}],[\"证明有人正在使用\",{\"1\":{\"11\":1}}],[\"到此一个简易版\",{\"1\":{\"65\":1}}],[\"到\",{\"1\":{\"61\":1}}],[\"到末尾了\",{\"1\":{\"26\":1,\"36\":1}}],[\"找到下一个\",{\"1\":{\"61\":1}}],[\"找到第一个\",{\"1\":{\"61\":1}}],[\"找到死锁\",{\"1\":{\"34\":1}}],[\"刚好等于\",{\"1\":{\"61\":1}}],[\"刚好处于半满状态\",{\"1\":{\"19\":1}}],[\"序列\",{\"1\":{\"62\":1}}],[\"序列化和确认号\",{\"1\":{\"52\":1}}],[\"序号\",{\"1\":{\"62\":2}}],[\"序号等信息\",{\"1\":{\"61\":1}}],[\"符号\",{\"1\":{\"61\":1}}],[\"结果\",{\"1\":{\"61\":1}}],[\"结束传输后又需要四次挥手来结束连接\",{\"1\":{\"51\":1}}],[\"丢包等场景\",{\"1\":{\"61\":1}}],[\"缺少等各种各样的问题\",{\"1\":{\"61\":1}}],[\"项目代码\",{\"1\":{\"67\":1}}],[\"项目的过程中可以从理论\",{\"1\":{\"66\":1}}],[\"项目提供了\",{\"1\":{\"65\":1}}],[\"项目提供的\",{\"1\":{\"60\":1}}],[\"项目中最简单的一部分\",{\"1\":{\"60\":1}}],[\"容器中节点的有序性\",{\"1\":{\"61\":1}}],[\"容器中\",{\"1\":{\"60\":1}}],[\"容量\",{\"1\":{\"60\":1,\"62\":2}}],[\"函数且没有发生过\",{\"1\":{\"65\":1}}],[\"函数发出连接\",{\"1\":{\"65\":1}}],[\"函数多次出现\",{\"1\":{\"64\":1}}],[\"函数时\",{\"1\":{\"64\":1}}],[\"函数向输出流写入数据后\",{\"1\":{\"64\":1}}],[\"函数都比较简单\",{\"1\":{\"62\":1}}],[\"函数有一个\",{\"1\":{\"62\":1}}],[\"函数直接找到第一个大于等于当前节点\",{\"1\":{\"61\":1}}],[\"函数\",{\"1\":{\"60\":4}}],[\"函数中做好了计算\",{\"1\":{\"62\":1}}],[\"函数中\",{\"1\":{\"36\":1}}],[\"减少字符串拷贝带来的性能\",{\"1\":{\"60\":1}}],[\"减少磁盘访问次数\",{\"1\":{\"9\":1}}],[\"减少磁盘和内存之间的数据\",{\"1\":{\"9\":1}}],[\"推进给出了详细注释\",{\"1\":{\"61\":1}}],[\"推荐使用\",{\"1\":{\"60\":1}}],[\"推入数据\",{\"1\":{\"62\":1}}],[\"推入\",{\"1\":{\"58\":1}}],[\"既可以直接使用\",{\"1\":{\"60\":1}}],[\"逐步添砖加瓦最后实现一个完成的\",{\"1\":{\"59\":1}}],[\"逐渐上升到整体\",{\"1\":{\"59\":1}}],[\"采用的是先整体后局部的方式\",{\"1\":{\"59\":1}}],[\"设置额外的字段\",{\"1\":{\"64\":1}}],[\"设置为\",{\"1\":{\"63\":1}}],[\"设置\",{\"1\":{\"62\":1,\"63\":2}}],[\"设置完毕后包装为\",{\"1\":{\"58\":1}}],[\"设置父节点\",{\"1\":{\"18\":1}}],[\"视具体情况而定\",{\"1\":{\"58\":1}}],[\"交给\",{\"1\":{\"58\":1,\"62\":1}}],[\"交给用户态下的\",{\"1\":{\"58\":1}}],[\"交换起始序号\",{\"1\":{\"51\":1}}],[\"使代码更易维护和阅读\",{\"1\":{\"58\":1}}],[\"使用pytorch框架\",{\"1\":{\"78\":1}}],[\"使用\",{\"0\":{\"65\":1},\"1\":{\"62\":2}}],[\"使用最广泛的传输层网络协议\",{\"1\":{\"49\":1}}],[\"使用锁来保护数据对象\",{\"1\":{\"33\":1}}],[\"字符串\",{\"1\":{\"60\":1}}],[\"字节流等类将\",{\"1\":{\"58\":1}}],[\"字段\",{\"1\":{\"58\":2,\"61\":1}}],[\"字段来维护\",{\"1\":{\"16\":1}}],[\"字段才是真正的物理页数据\",{\"1\":{\"16\":1}}],[\"字段类型\",{\"1\":{\"6\":1}}],[\"输入流\",{\"1\":{\"64\":1}}],[\"输入流为\",{\"1\":{\"58\":1}}],[\"输出\",{\"1\":{\"64\":1}}],[\"输出流已经完全被对端确认\",{\"1\":{\"64\":1}}],[\"输出流\",{\"1\":{\"64\":2}}],[\"输出流设置为错误状态\",{\"1\":{\"64\":1}}],[\"输出流为\",{\"1\":{\"58\":1}}],[\"损坏等\",{\"1\":{\"58\":1}}],[\"确认\",{\"1\":{\"64\":1}}],[\"确认不了\",{\"1\":{\"63\":1}}],[\"确认序列\",{\"1\":{\"63\":1}}],[\"确认序号\",{\"1\":{\"63\":3}}],[\"确认号\",{\"1\":{\"58\":1}}],[\"确认报文\",{\"1\":{\"58\":1}}],[\"确保数据达到对端\",{\"1\":{\"52\":1}}],[\"确保操作的原子性\",{\"1\":{\"39\":1}}],[\"报文达到时\",{\"1\":{\"64\":1}}],[\"报文长度与确认序号之间的关系\",{\"1\":{\"63\":1}}],[\"报文都被当作一个\",{\"1\":{\"61\":1}}],[\"报文容器\",{\"1\":{\"61\":1}}],[\"报文数据第一个字节的序号\",{\"1\":{\"61\":1}}],[\"报文数据\",{\"1\":{\"61\":1}}],[\"报文数据乱序等问题\",{\"1\":{\"61\":1}}],[\"报文数据不能直接写入到\",{\"1\":{\"61\":1}}],[\"报文可能存在乱序\",{\"1\":{\"61\":1}}],[\"报文可能乱序\",{\"1\":{\"58\":1}}],[\"报文\",{\"1\":{\"58\":3,\"61\":1,\"63\":1}}],[\"报文发送队列和报文已发送未确认队列\",{\"1\":{\"63\":1}}],[\"报文发送\",{\"1\":{\"58\":1}}],[\"报文大小是有限制的\",{\"1\":{\"53\":1}}],[\"处理\",{\"1\":{\"58\":2,\"63\":2}}],[\"处理模型\",{\"0\":{\"25\":1},\"1\":{\"25\":1}}],[\"完全可以自主实现\",{\"1\":{\"57\":1}}],[\"拥有两个字节流\",{\"1\":{\"58\":1}}],[\"拥有了\",{\"1\":{\"18\":1}}],[\"拥塞控制\",{\"1\":{\"57\":1}}],[\"紧急指针\",{\"1\":{\"57\":1}}],[\"带来复杂\",{\"1\":{\"57\":1}}],[\"quic\",{\"1\":{\"57\":4}}],[\"queue<tcpsegment>\",{\"1\":{\"63\":2,\"64\":1}}],[\"queue\",{\"1\":{\"35\":9,\"63\":1,\"64\":1}}],[\"query\",{\"1\":{\"27\":3}}],[\"给错误调试和定位带来了很大困难\",{\"1\":{\"56\":1}}],[\"连接接收\",{\"1\":{\"64\":1}}],[\"连接是否处于激活状态\",{\"1\":{\"64\":1}}],[\"连接的接收方\",{\"1\":{\"62\":1}}],[\"连接只有一个\",{\"1\":{\"61\":1}}],[\"连接完美抽象\",{\"1\":{\"58\":1}}],[\"连接\",{\"1\":{\"56\":1,\"58\":1,\"65\":1}}],[\"连接既可以是\",{\"1\":{\"54\":1}}],[\"端口\",{\"1\":{\"56\":2,\"65\":3}}],[\"$\",{\"1\":{\"56\":2,\"65\":2}}],[\"工具\",{\"1\":{\"56\":1}}],[\"借助\",{\"1\":{\"56\":1}}],[\"借给兄弟节点\",{\"1\":{\"19\":1}}],[\"关闭连接\",{\"1\":{\"64\":1}}],[\"关闭定时器\",{\"1\":{\"63\":2}}],[\"关于\",{\"1\":{\"62\":1,\"64\":1}}],[\"关于这二者的细节\",{\"1\":{\"54\":1}}],[\"关系数据库的设计与实现\",{\"1\":{\"3\":1}}],[\"关系数据库\",{\"1\":{\"3\":1}}],[\"管理\",{\"1\":{\"54\":1}}],[\"另一个重要的工作在于计时\",{\"1\":{\"64\":1}}],[\"另一个是初始点难以确定\",{\"1\":{\"76\":1}}],[\"另一个是绝对\",{\"1\":{\"62\":1}}],[\"另一个是输入流\",{\"1\":{\"54\":1}}],[\"另外一旦收到\",{\"1\":{\"63\":1}}],[\"另外一个需要注意的点是何时关闭输入流\",{\"1\":{\"61\":1}}],[\"另外在\",{\"1\":{\"62\":1}}],[\"另外如果\",{\"1\":{\"11\":1}}],[\"控制\",{\"1\":{\"54\":1}}],[\"窗口没有设置过\",{\"1\":{\"63\":1}}],[\"窗口等信息\",{\"1\":{\"54\":1}}],[\"窗口大小不为\",{\"1\":{\"63\":1}}],[\"窗口大小可能为空\",{\"1\":{\"63\":1}}],[\"窗口大小\",{\"1\":{\"51\":1,\"58\":1,\"63\":1}}],[\"窗口大小等信息\",{\"1\":{\"51\":1}}],[\"双方进入可靠通信阶段\",{\"1\":{\"65\":1}}],[\"双方三次握手的过程\",{\"1\":{\"65\":1}}],[\"双方都全部完成了数据交付和接收\",{\"1\":{\"64\":1}}],[\"双方拥有独立的序号\",{\"1\":{\"54\":1}}],[\"双向链表\",{\"1\":{\"10\":1}}],[\"具体逻辑参考注释\",{\"1\":{\"63\":1}}],[\"具体实现\",{\"1\":{\"53\":1}}],[\"具有\",{\"1\":{\"15\":1}}],[\"具有至少\",{\"1\":{\"15\":1}}],[\"传入都是基于字节流\",{\"1\":{\"53\":1}}],[\"传输数据是没有边界的\",{\"1\":{\"53\":1}}],[\"传感器采集信息包括相机\",{\"1\":{\"45\":1}}],[\"意味着\",{\"1\":{\"53\":1}}],[\"防止数据丢失或出错\",{\"1\":{\"52\":1}}],[\"校验和等功能\",{\"1\":{\"57\":1}}],[\"校验和\",{\"1\":{\"52\":1}}],[\"做了很多事情\",{\"1\":{\"52\":1}}],[\"欢迎斧正\",{\"1\":{\"52\":1}}],[\"回应\",{\"1\":{\"64\":1}}],[\"回到\",{\"1\":{\"56\":1}}],[\"回复\",{\"1\":{\"51\":1}}],[\"回滚事务将重新启动或中止\",{\"1\":{\"34\":1}}],[\"回滚事务\",{\"1\":{\"32\":1}}],[\"回滚一个事务\",{\"1\":{\"32\":1}}],[\"回滚\",{\"1\":{\"32\":1}}],[\"客户端会关闭输出流\",{\"1\":{\"65\":1}}],[\"客户端在收到第一个\",{\"1\":{\"65\":1}}],[\"客户端发起连接\",{\"1\":{\"65\":1}}],[\"客户端发送\",{\"1\":{\"65\":4}}],[\"客户端调用\",{\"1\":{\"65\":1}}],[\"客户端\",{\"1\":{\"65\":1}}],[\"客户端收到\",{\"1\":{\"51\":1,\"65\":1}}],[\"客户端向服务器发送\",{\"1\":{\"51\":1}}],[\"三次握手全部完成\",{\"1\":{\"65\":1}}],[\"三次握手第三步\",{\"1\":{\"65\":3}}],[\"三次握手第一步\",{\"1\":{\"65\":3}}],[\"三次握手第二步\",{\"1\":{\"65\":3}}],[\"三次握手流程如下\",{\"1\":{\"51\":1}}],[\"三个字节\",{\"1\":{\"62\":1}}],[\"三种范型参数\",{\"1\":{\"16\":1}}],[\"显著特点\",{\"1\":{\"51\":1}}],[\"显然不是的\",{\"1\":{\"31\":1}}],[\"四次挥手\",{\"1\":{\"49\":1}}],[\"形\",{\"1\":{\"49\":1}}],[\"考试上的常客\",{\"1\":{\"49\":1}}],[\"面向连接是\",{\"1\":{\"51\":1}}],[\"面向连接\",{\"0\":{\"51\":1}}],[\"面向连接的\",{\"1\":{\"49\":1}}],[\"面试\",{\"1\":{\"49\":1}}],[\"基本上10几步均可收敛\",{\"1\":{\"78\":1}}],[\"基本覆盖了网络知识的方方面面\",{\"1\":{\"66\":1}}],[\"基本覆盖了我们生活的方方面面\",{\"1\":{\"66\":1}}],[\"基本情况\",{\"1\":{\"18\":1}}],[\"基于外点法的分式优化问题\",{\"0\":{\"75\":1}}],[\"基于\",{\"1\":{\"58\":1}}],[\"基于字节流\",{\"0\":{\"53\":1},\"1\":{\"49\":1}}],[\"概述\",{\"0\":{\"49\":1}}],[\"线上聊天室\",{\"0\":{\"47\":1}}],[\"之前就被\",{\"1\":{\"63\":1}}],[\"之上\",{\"1\":{\"57\":1}}],[\"之后就可以操作对应的message了\",{\"1\":{\"45\":1}}],[\"之间的对应关系如下表\",{\"1\":{\"62\":1}}],[\"之间的排序\",{\"1\":{\"16\":1}}],[\"之间的关系转化\",{\"1\":{\"62\":1}}],[\"之间的关系\",{\"1\":{\"11\":1,\"61\":2}}],[\"那就是实现对pb对象中非空字段的选取\",{\"1\":{\"45\":1}}],[\"那每个pb格式都要写一遍实现代码\",{\"1\":{\"45\":1}}],[\"那么如何不等待了\",{\"1\":{\"64\":1}}],[\"那么如果是删除则复杂一些\",{\"1\":{\"20\":1}}],[\"那么只应该等待\",{\"1\":{\"64\":1}}],[\"那么只需要共享锁\",{\"1\":{\"20\":1}}],[\"那么准备关闭连接\",{\"1\":{\"64\":1}}],[\"那么为什么需要发送空包呢\",{\"1\":{\"64\":1}}],[\"那么填充\",{\"1\":{\"64\":1}}],[\"那么所有\",{\"1\":{\"64\":1}}],[\"那么无法接受\",{\"1\":{\"64\":1}}],[\"那么发送\",{\"1\":{\"64\":2}}],[\"那么调用\",{\"1\":{\"64\":2}}],[\"那么不能对超时时间进行翻倍\",{\"1\":{\"63\":1}}],[\"那么必须至少回复一个报文\",{\"1\":{\"64\":1}}],[\"那么必须重置超时时间为最初超时时间\",{\"1\":{\"63\":1}}],[\"那么必须为\",{\"1\":{\"63\":1}}],[\"那么表示包被确认了\",{\"1\":{\"63\":1}}],[\"那么作为最后一个包发送\",{\"1\":{\"63\":1}}],[\"那么作为\",{\"1\":{\"63\":1}}],[\"那么就开启计时\",{\"1\":{\"63\":1}}],[\"那么就需要淘汰一部分数据页将其刷到磁盘中\",{\"1\":{\"10\":1}}],[\"那么也无法接收\",{\"1\":{\"62\":1}}],[\"那么也必须对兄弟节点加独占锁\",{\"1\":{\"20\":1}}],[\"那么本次将忽略\",{\"1\":{\"62\":1}}],[\"那么本文可能不适合你\",{\"1\":{\"3\":1}}],[\"那么这个序号与绝对\",{\"1\":{\"62\":1}}],[\"那么这些\",{\"1\":{\"16\":1}}],[\"那么可能会产生一个问题\",{\"1\":{\"62\":1}}],[\"那么依次合并节点\",{\"1\":{\"61\":1}}],[\"那么截取\",{\"1\":{\"61\":1}}],[\"那么接收的为最后一个字符串\",{\"1\":{\"61\":1}}],[\"那么丢弃掉数据\",{\"1\":{\"61\":1}}],[\"那么等于窗口大小\",{\"1\":{\"60\":1}}],[\"那么直接停止等待\",{\"1\":{\"35\":1}}],[\"那么直接返回\",{\"1\":{\"35\":1,\"61\":1,\"62\":1,\"63\":2}}],[\"那么直接\",{\"1\":{\"35\":2}}],[\"那么又该如何保证事务之间不发生数据冲突了\",{\"1\":{\"32\":1}}],[\"那么是不是隔离级别越高越好了\",{\"1\":{\"31\":1}}],[\"那么结束\",{\"1\":{\"26\":1}}],[\"那么继续向下搜索\",{\"1\":{\"20\":1}}],[\"那么节点大小必须\",{\"1\":{\"20\":3}}],[\"那么释放父节点锁\",{\"1\":{\"20\":1}}],[\"那么性能将是十分的低下\",{\"1\":{\"20\":1}}],[\"那么\",{\"1\":{\"19\":1,\"31\":1,\"34\":1,\"41\":1,\"61\":1,\"62\":4,\"63\":1,\"64\":1,\"65\":1}}],[\"那么对父节点仍然递归的执行\",{\"1\":{\"19\":1}}],[\"那么对于这样的节点\",{\"1\":{\"19\":1}}],[\"那么重新申请一个页作为新的根节点\",{\"1\":{\"18\":1}}],[\"那么将关闭计时器\",{\"1\":{\"63\":1}}],[\"那么将一直持有整条路线上的锁\",{\"1\":{\"20\":1}}],[\"那么将\",{\"1\":{\"18\":1}}],[\"那么将新建一棵\",{\"1\":{\"18\":1}}],[\"那么新建\",{\"1\":{\"18\":1}}],[\"那么向父节点中加入指向\",{\"1\":{\"18\":1}}],[\"那么一定要\",{\"1\":{\"17\":1}}],[\"那么最后必然会搜索到叶子结点上\",{\"1\":{\"15\":1}}],[\"那么该报文被确认\",{\"1\":{\"63\":1}}],[\"那么该锁可以被其它事务获取\",{\"1\":{\"32\":1}}],[\"那么该查询计划又是如何被执行器执行的呢\",{\"1\":{\"26\":1}}],[\"那么该子节点成为新的根节点\",{\"1\":{\"19\":1}}],[\"那么该内部节点只有\",{\"1\":{\"15\":1}}],[\"那么该页就应该被加入到\",{\"1\":{\"11\":1}}],[\"那么证明有人正在使用该页\",{\"1\":{\"11\":1}}],[\"那么则需要淘汰一个页\",{\"1\":{\"11\":1}}],[\"那么链表尾部自然就成为了最近最少使用的页\",{\"1\":{\"10\":1}}],[\"那么希望你能耐心阅读完本文\",{\"1\":{\"3\":1}}],[\"感知\",{\"1\":{\"45\":1}}],[\"感兴趣的可以查看源码\",{\"1\":{\"65\":1}}],[\"感兴趣的可以自行查询\",{\"1\":{\"49\":1}}],[\"感兴趣的可以自行查阅资料\",{\"1\":{\"20\":1}}],[\"感兴趣的可以点开参考资料上的连接了解一下\",{\"1\":{\"66\":1}}],[\"感兴趣的可以点开参考资料查阅\",{\"1\":{\"26\":1}}],[\"感兴趣的可以点击\",{\"1\":{\"11\":1}}],[\"导致代码很多\",{\"1\":{\"62\":1}}],[\"导致大部分技术债实际上是架构和设计阶段的债务\",{\"1\":{\"0\":1}}],[\"导航信息\",{\"1\":{\"45\":1}}],[\"毫米波雷达\",{\"1\":{\"45\":1}}],[\"激光雷达\",{\"1\":{\"45\":1}}],[\"自驾中需要传递的数据非常多\",{\"1\":{\"45\":1}}],[\"反射的步骤如下\",{\"1\":{\"45\":1}}],[\"覆盖主流语言\",{\"1\":{\"45\":3}}],[\"快\",{\"1\":{\"45\":1}}],[\"快照实现\",{\"1\":{\"6\":1}}],[\"快照管理器\",{\"1\":{\"5\":1}}],[\"慢\",{\"1\":{\"45\":2}}],[\"编解码效率\",{\"1\":{\"45\":1}}],[\"文本\",{\"1\":{\"45\":2}}],[\"文档数据库\",{\"1\":{\"3\":1}}],[\"简单来说\",{\"1\":{\"54\":1}}],[\"简单结构\",{\"1\":{\"45\":2}}],[\"简单介绍\",{\"0\":{\"50\":1},\"1\":{\"16\":1}}],[\"特性\",{\"1\":{\"45\":1}}],[\"json\",{\"1\":{\"45\":1}}],[\"json等\",{\"1\":{\"45\":1}}],[\"join\",{\"1\":{\"24\":1,\"26\":2}}],[\"常常用于进程间序列化信息传递\",{\"1\":{\"45\":1}}],[\"常见的处理模型有\",{\"1\":{\"25\":1}}],[\"常见的淘汰算法有\",{\"1\":{\"10\":1}}],[\"手动实现反向传播算法\",{\"0\":{\"44\":1}}],[\"手动实现gmm算法\",{\"0\":{\"43\":1}}],[\"再运行客户端\",{\"1\":{\"65\":1}}],[\"再没有\",{\"1\":{\"63\":1}}],[\"再来推进\",{\"1\":{\"61\":1}}],[\"再\",{\"1\":{\"41\":1}}],[\"再从磁盘读取新的页\",{\"1\":{\"10\":1}}],[\"电源断开等情况又该如何恢复呢\",{\"1\":{\"41\":1}}],[\"碰到数据库崩溃\",{\"1\":{\"41\":1}}],[\"~logrecovery\",{\"1\":{\"41\":1}}],[\"~logmanager\",{\"1\":{\"40\":1}}],[\"~abstractexecutor\",{\"1\":{\"26\":1}}],[\"~abstractplannode\",{\"1\":{\"26\":1}}],[\"撤消期间记录更改\",{\"1\":{\"39\":1}}],[\"预测等又会产生很多message\",{\"1\":{\"45\":1}}],[\"预写日志\",{\"1\":{\"39\":1}}],[\"预防\",{\"1\":{\"32\":1}}],[\"恢复\",{\"0\":{\"41\":1}}],[\"恢复算法主要思路\",{\"1\":{\"39\":1}}],[\"恢复算法主要工作包括如下两部分\",{\"1\":{\"39\":1}}],[\"恢复算法是确保数据库一致性\",{\"1\":{\"39\":1}}],[\"恢复机制是数据库必不可少的一部分\",{\"1\":{\"39\":1}}],[\"软件错误等\",{\"1\":{\"39\":1}}],[\"宕机\",{\"1\":{\"39\":1}}],[\"计时\",{\"1\":{\"64\":1}}],[\"计时器\",{\"1\":{\"63\":1}}],[\"计数\",{\"1\":{\"63\":1}}],[\"计算而来\",{\"1\":{\"62\":1}}],[\"计算机容易发生各种故障\",{\"1\":{\"39\":1}}],[\"计划都有一个对应的查询计划类\",{\"1\":{\"26\":1}}],[\"切无法加读锁\",{\"1\":{\"36\":1}}],[\"写锁\",{\"1\":{\"36\":2}}],[\"写到\",{\"1\":{\"11\":1}}],[\"没有任何错误产生\",{\"1\":{\"64\":1}}],[\"没有找到\",{\"1\":{\"61\":1}}],[\"没有大小限制的\",{\"1\":{\"53\":1}}],[\"没有加读\",{\"1\":{\"36\":2}}],[\"没有加读锁\",{\"1\":{\"36\":2}}],[\"没有加写锁\",{\"1\":{\"36\":1}}],[\"没有则直接返回\",{\"1\":{\"10\":1}}],[\"未\",{\"1\":{\"63\":1}}],[\"未收到的序列\",{\"1\":{\"62\":1}}],[\"未重组\",{\"1\":{\"61\":1}}],[\"未组装字节个数\",{\"1\":{\"61\":1}}],[\"未加任何锁\",{\"1\":{\"36\":2}}],[\"未找到\",{\"1\":{\"11\":2}}],[\"通知\",{\"1\":{\"35\":1}}],[\"通过新建\",{\"1\":{\"65\":1}}],[\"通过reflection来操作fielddescriptor\",{\"1\":{\"45\":1}}],[\"通过message获取其reflection\",{\"1\":{\"45\":1}}],[\"通过message获取单个字段的fielddescriptor\",{\"1\":{\"45\":1}}],[\"通过调用\",{\"1\":{\"25\":1}}],[\"通过搜索\",{\"1\":{\"18\":1}}],[\"通过\",{\"1\":{\"11\":1,\"16\":1,\"17\":1,\"25\":1,\"26\":1,\"56\":1,\"62\":1,\"63\":1}}],[\"上\",{\"1\":{\"65\":1}}],[\"上一个包接受距现在时间\",{\"1\":{\"64\":1}}],[\"上面代码已经对节点合并\",{\"1\":{\"61\":1}}],[\"上面\",{\"1\":{\"49\":1}}],[\"上所有的边\",{\"1\":{\"35\":1}}],[\"上的一个用户态可靠协议\",{\"1\":{\"57\":1}}],[\"上的锁\",{\"1\":{\"20\":1,\"35\":1}}],[\"上的操作也需要保证并发安全\",{\"1\":{\"11\":1}}],[\"清除\",{\"1\":{\"35\":1}}],[\"检查是否存在死锁\",{\"1\":{\"35\":1}}],[\"同样的通过\",{\"1\":{\"65\":1}}],[\"同样地\",{\"1\":{\"18\":1}}],[\"同时连接拥有两个字节流\",{\"1\":{\"54\":1}}],[\"同理锁管理器还提供了\",{\"1\":{\"35\":1}}],[\"授予锁\",{\"1\":{\"35\":1}}],[\"继续执行\",{\"1\":{\"35\":1}}],[\"状态机\",{\"1\":{\"64\":1}}],[\"状态机等信息数据\",{\"1\":{\"58\":1}}],[\"状态转换等工作\",{\"1\":{\"51\":1}}],[\"状态下\",{\"1\":{\"35\":1,\"65\":1}}],[\"状态\",{\"1\":{\"35\":1,\"64\":3}}],[\"长度\",{\"1\":{\"63\":2}}],[\"长度为\",{\"1\":{\"16\":1}}],[\"长事务先淘汰\",{\"1\":{\"34\":1}}],[\"正是因为这些优点\",{\"1\":{\"49\":1}}],[\"正是这样的一个协议\",{\"1\":{\"20\":1}}],[\"正是这样一本书\",{\"1\":{\"3\":1}}],[\"正在等待\",{\"1\":{\"34\":1}}],[\"死锁预防\",{\"1\":{\"34\":1}}],[\"死锁检测\",{\"1\":{\"34\":1}}],[\"死锁\",{\"0\":{\"34\":1}}],[\"死锁问题\",{\"1\":{\"32\":1}}],[\"跟踪哪些事务持有哪些锁以及哪些事务正在等待获取其它锁\",{\"1\":{\"33\":1}}],[\"独占锁\",{\"1\":{\"33\":1}}],[\"xml\",{\"1\":{\"45\":1}}],[\"x\",{\"1\":{\"33\":1}}],[\"共享锁\",{\"1\":{\"33\":1}}],[\"强二阶段锁规定\",{\"1\":{\"32\":1}}],[\"强二阶段锁定协议示意图如下\",{\"1\":{\"32\":1}}],[\"因初始点难以选取\",{\"1\":{\"77\":1}}],[\"因为pytorch实现了自动微分机制\",{\"1\":{\"78\":1}}],[\"因为外点法无需从有效的初始点出发进行迭代\",{\"1\":{\"77\":1}}],[\"因为即使流结束了\",{\"1\":{\"64\":1}}],[\"因为对于远端的包\",{\"1\":{\"64\":1}}],[\"因为如果\",{\"1\":{\"64\":1}}],[\"因为可以同步\",{\"1\":{\"63\":1}}],[\"因为\",{\"1\":{\"35\":1,\"61\":1}}],[\"因为再\",{\"1\":{\"32\":1}}],[\"因此对端已经不再接受包了\",{\"1\":{\"64\":1}}],[\"因此对于其它层协议不做详细介绍\",{\"1\":{\"49\":1}}],[\"因此对于并发连接的数据访问控制\",{\"1\":{\"32\":1}}],[\"因此这个状态属于被动关闭\",{\"1\":{\"64\":1}}],[\"因此还可以发送的字节数\",{\"1\":{\"63\":1}}],[\"因此一次可能打包多个报文\",{\"1\":{\"63\":1}}],[\"因此一旦缓存池满了\",{\"1\":{\"10\":1}}],[\"因此为了解决\",{\"1\":{\"61\":1}}],[\"因此为了实现通信中间件\",{\"1\":{\"45\":1}}],[\"因此我们可以从任意点出发进行迭代求解\",{\"1\":{\"77\":1}}],[\"因此我们采用外点法进行优化\",{\"1\":{\"77\":1}}],[\"因此我们必须缓存\",{\"1\":{\"61\":1}}],[\"因此我们会先从\",{\"1\":{\"59\":1}}],[\"因此我们需要反射来简化这个流程\",{\"1\":{\"45\":1}}],[\"因此我们需要通过锁管理器来完善执行器的事务支持\",{\"1\":{\"36\":1}}],[\"因此我们需要一种算法\",{\"1\":{\"20\":1}}],[\"因此常常会有字节流乱序发生\",{\"1\":{\"53\":1}}],[\"因此数据库必须预先采取措施以保证即使发生故障\",{\"1\":{\"39\":1}}],[\"因此会出现环形等待\",{\"1\":{\"34\":1}}],[\"因此其它事务可能读到脏数据\",{\"1\":{\"32\":1}}],[\"因此任何一个执行器\",{\"1\":{\"26\":1}}],[\"因此也需要对\",{\"1\":{\"20\":1}}],[\"因此也被称为\",{\"1\":{\"20\":1}}],[\"因此无法释放\",{\"1\":{\"20\":1}}],[\"因此每得到一个锁\",{\"1\":{\"20\":1}}],[\"因此不回分裂\",{\"1\":{\"20\":1}}],[\"因此合并完毕\",{\"1\":{\"19\":1}}],[\"因此节点\",{\"1\":{\"19\":1}}],[\"因此递归情况需分裂到不可分裂为止\",{\"1\":{\"18\":1}}],[\"因此父节点也需要继续分裂\",{\"1\":{\"18\":1}}],[\"因此需设置\",{\"1\":{\"64\":1}}],[\"因此需要等待\",{\"1\":{\"64\":1}}],[\"因此需要一个空包\",{\"1\":{\"64\":1}}],[\"因此需要定义大量pb结构\",{\"1\":{\"45\":1}}],[\"因此需要重组而不是合并\",{\"1\":{\"19\":1}}],[\"因此需要重组或合并\",{\"1\":{\"19\":1}}],[\"因此需先调用\",{\"1\":{\"17\":1}}],[\"因此需直接写代码构建执行计划来执行\",{\"1\":{\"5\":1}}],[\"因此可将该字段通过\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"15\":1,\"19\":1,\"20\":1,\"33\":1,\"49\":1,\"61\":1}}],[\"因此根节点也是叶子结点\",{\"1\":{\"15\":1}}],[\"因此后面还是会统一称作页\",{\"1\":{\"11\":1}}],[\"因此锁\",{\"1\":{\"11\":1}}],[\"因此开源的只有一部分\",{\"1\":{\"3\":1}}],[\"解锁\",{\"1\":{\"35\":1}}],[\"解决丢失\",{\"1\":{\"52\":1}}],[\"解决死锁的方法有两种\",{\"1\":{\"34\":1}}],[\"解决办法\",{\"1\":{\"33\":1}}],[\"解决方案是检测\",{\"1\":{\"32\":1}}],[\"解决方案是\",{\"1\":{\"32\":1}}],[\"解析器\",{\"1\":{\"5\":2,\"24\":1}}],[\"两个部分\",{\"1\":{\"58\":1}}],[\"两个阶段\",{\"1\":{\"32\":1}}],[\"两阶段锁定协议\",{\"1\":{\"32\":1}}],[\"决定事务是否可以动态地访问数据库中的对象\",{\"1\":{\"32\":1}}],[\"此后该连接对数据的访问都会以此事务作为基本单位\",{\"1\":{\"32\":1}}],[\"此时如果\",{\"1\":{\"31\":1}}],[\"此时节点\",{\"1\":{\"18\":2}}],[\"此时\",{\"1\":{\"18\":1,\"20\":2}}],[\"此时根节点是内部节点\",{\"1\":{\"15\":1}}],[\"此时根节点在树的底部\",{\"1\":{\"15\":1}}],[\"唯一标识\",{\"1\":{\"32\":1,\"35\":1}}],[\"任何长度大于\",{\"1\":{\"64\":2}}],[\"任何时候\",{\"1\":{\"64\":1}}],[\"任何数据更改在应用到数据库之前\",{\"1\":{\"39\":1}}],[\"任何事务在访问数据记录之前\",{\"1\":{\"35\":1}}],[\"任何一个连接建立后\",{\"1\":{\"32\":1}}],[\"任何内存与磁盘之间的交互都需要通过它来进行\",{\"1\":{\"11\":1}}],[\"终止阶段\",{\"1\":{\"32\":1}}],[\"启动一个事务\",{\"1\":{\"32\":1}}],[\"又可以接受数据\",{\"1\":{\"54\":1}}],[\"又在等待\",{\"1\":{\"34\":1}}],[\"又该如何实现事务了\",{\"1\":{\"32\":1}}],[\"又给它取了一个新名字\",{\"1\":{\"11\":1}}],[\"介绍事务基本概念后\",{\"1\":{\"32\":1}}],[\"很难给出有效的初始点\",{\"1\":{\"76\":1}}],[\"很多人将三次握手\",{\"1\":{\"49\":1}}],[\"很少有人在一个事务过程中\",{\"1\":{\"31\":1}}],[\"很简单\",{\"1\":{\"16\":1,\"63\":1}}],[\"性能是数据库一个重要的考量指标\",{\"1\":{\"31\":1}}],[\"默认为\",{\"1\":{\"61\":1,\"62\":1,\"63\":1,\"64\":1}}],[\"默认隔离级别是\",{\"1\":{\"31\":1}}],[\"默认的隔离级别是\",{\"1\":{\"31\":1}}],[\"☑️\",{\"1\":{\"31\":6}}],[\"✖️\",{\"1\":{\"31\":6}}],[\"效率也就越低\",{\"1\":{\"31\":1}}],[\"串行化\",{\"1\":{\"31\":2}}],[\"总结\",{\"0\":{\"66\":1}}],[\"总是跟这个事务在启动时看到的数据是一致的\",{\"1\":{\"31\":1}}],[\"总览\",{\"0\":{\"2\":1,\"4\":1}}],[\"级别越高\",{\"1\":{\"31\":1}}],[\"彼此的隔离状态\",{\"1\":{\"31\":1}}],[\"隔离级别越高\",{\"1\":{\"31\":1}}],[\"隔离级别用于控制多个事务并发访问时\",{\"1\":{\"31\":1}}],[\"隔离度也越好\",{\"1\":{\"31\":1}}],[\"隔离性\",{\"1\":{\"30\":1}}],[\"条\",{\"1\":{\"31\":2}}],[\"幻读中的任何一个\",{\"1\":{\"31\":1}}],[\"幻读发生在其他事务\",{\"1\":{\"31\":1}}],[\"幻读\",{\"1\":{\"31\":2}}],[\"幻灯片页\",{\"0\":{\"1\":1}}],[\"脏读问题\",{\"1\":{\"32\":1}}],[\"脏读\",{\"1\":{\"31\":2}}],[\"脏页记得写回磁盘\",{\"1\":{\"11\":1}}],[\"脏页\",{\"1\":{\"9\":1}}],[\"多次读取同一条记录\",{\"1\":{\"31\":1}}],[\"多事务并发执行的情况下\",{\"1\":{\"31\":1}}],[\"多个事务并发执行时\",{\"1\":{\"30\":1}}],[\"持久性\",{\"1\":{\"30\":1}}],[\"要么都不执行\",{\"1\":{\"30\":1}}],[\"要么全部失败\",{\"1\":{\"30\":1}}],[\"要么全部成功\",{\"1\":{\"30\":1}}],[\"包就丢失了\",{\"1\":{\"63\":1}}],[\"包可能没有任何数组\",{\"1\":{\"63\":1}}],[\"包可能先于其它数据包达到\",{\"1\":{\"61\":1}}],[\"包发送\",{\"1\":{\"63\":1}}],[\"包也占有一个序号\",{\"1\":{\"62\":1}}],[\"包数据\",{\"1\":{\"61\":1}}],[\"包重发达到后\",{\"1\":{\"61\":1}}],[\"包到达后也不可直接写入字节流\",{\"1\":{\"61\":1}}],[\"包到达时\",{\"1\":{\"61\":1}}],[\"包达到\",{\"1\":{\"61\":1}}],[\"包丢了\",{\"1\":{\"61\":1}}],[\"包更早到达\",{\"1\":{\"61\":1}}],[\"包比\",{\"1\":{\"61\":1}}],[\"包装32位seqno\",{\"1\":{\"59\":1}}],[\"包装为表记录\",{\"1\":{\"26\":1}}],[\"包的交互\",{\"1\":{\"51\":1}}],[\"包至客户端\",{\"1\":{\"51\":1}}],[\"包后等待\",{\"1\":{\"63\":1}}],[\"包后\",{\"1\":{\"51\":2,\"64\":1,\"65\":1}}],[\"包\",{\"1\":{\"51\":2,\"61\":2,\"62\":3,\"63\":3,\"64\":8,\"65\":14}}],[\"包含数据\",{\"1\":{\"64\":1}}],[\"包含数据链路层\",{\"1\":{\"49\":1}}],[\"包含了数据\",{\"1\":{\"61\":1}}],[\"包含在其中的对数据库的操作要么全部被执行\",{\"1\":{\"30\":1}}],[\"原因在于其它事务插入了数据\",{\"1\":{\"31\":1}}],[\"原子性和持久性的关键技术\",{\"1\":{\"39\":1}}],[\"原子性\",{\"1\":{\"30\":1}}],[\"原理也很简单\",{\"1\":{\"10\":1}}],[\"原理和实现的\",{\"1\":{\"3\":1}}],[\"习惯上被称之为\",{\"1\":{\"30\":1}}],[\"摘自维基百科\",{\"1\":{\"30\":1}}],[\"事务共享锁加入\",{\"1\":{\"35\":1}}],[\"事务获取某条记录的共享锁\",{\"1\":{\"35\":1}}],[\"事务淘汰策略有多种\",{\"1\":{\"34\":1}}],[\"事务释放锁\",{\"1\":{\"33\":1}}],[\"事务请求\",{\"1\":{\"33\":1}}],[\"事务不能再加锁\",{\"1\":{\"35\":1}}],[\"事务不能再获取锁\",{\"1\":{\"32\":1}}],[\"事务不用关系其它事务之间的数据依赖\",{\"1\":{\"33\":1}}],[\"事务无法再获取新的锁\",{\"1\":{\"32\":1}}],[\"事务是数据访问的基本单位\",{\"1\":{\"32\":1}}],[\"事务是数据库访问\",{\"1\":{\"30\":1}}],[\"事务已终止\",{\"1\":{\"32\":1}}],[\"事务已提交\",{\"1\":{\"32\":1}}],[\"事务向锁管理器请求锁\",{\"1\":{\"32\":1}}],[\"事务一般有三个操作\",{\"1\":{\"32\":1}}],[\"事务第一次查询有\",{\"1\":{\"31\":1}}],[\"事务第一次读取数据\",{\"1\":{\"31\":1}}],[\"事务再次读取\",{\"1\":{\"31\":1}}],[\"事务更改了数据\",{\"1\":{\"31\":1}}],[\"事务发生错误并执行回滚操作\",{\"1\":{\"31\":1}}],[\"事务尚未提交的数据\",{\"1\":{\"31\":1}}],[\"事务读取到的数据就是脏数据\",{\"1\":{\"31\":1}}],[\"事务读取\",{\"1\":{\"31\":1}}],[\"事务隔离级别\",{\"0\":{\"31\":1},\"1\":{\"31\":1}}],[\"事务应确保数据库的状态从一个一致状态转变为另一个一致状态\",{\"1\":{\"30\":1}}],[\"事务作为一个整体被执行\",{\"1\":{\"30\":1}}],[\"事务具有如下四个特性\",{\"1\":{\"30\":1}}],[\"事务\",{\"0\":{\"30\":1},\"1\":{\"33\":2,\"35\":1}}],[\"事务管理器\",{\"1\":{\"5\":1,\"6\":1,\"29\":1}}],[\"谈谈用户态\",{\"0\":{\"48\":1}}],[\"谈谈关系数据库的设计与实现\",{\"0\":{\"2\":1,\"8\":1,\"13\":1,\"23\":1,\"38\":1}}],[\"谈关系数据库的设计与实现\",{\"0\":{\"28\":1}}],[\"篇幅有限\",{\"1\":{\"26\":1}}],[\"精妙的抽象\",{\"1\":{\"26\":1}}],[\"得益于\",{\"1\":{\"26\":1}}],[\"得到绝对序号\",{\"1\":{\"63\":1}}],[\"得到正确的字节流序列\",{\"1\":{\"62\":1}}],[\"得到前一个节点\",{\"1\":{\"61\":1}}],[\"得到事务上的所有\",{\"1\":{\"35\":1}}],[\"得到死锁的\",{\"1\":{\"35\":1}}],[\"得到当前包序号\",{\"1\":{\"62\":1}}],[\"得到当前数据节点\",{\"1\":{\"61\":1}}],[\"得到当前\",{\"1\":{\"26\":1,\"36\":1}}],[\"得到父节点\",{\"1\":{\"19\":1}}],[\"得到\",{\"1\":{\"18\":1,\"35\":1,\"62\":1}}],[\"得到叶子结点\",{\"1\":{\"18\":1}}],[\"得到空闲页\",{\"1\":{\"11\":1}}],[\"巧妙将其解耦\",{\"1\":{\"26\":1}}],[\"循环\",{\"1\":{\"26\":1}}],[\"满足查询条件\",{\"1\":{\"26\":1}}],[\"迭代器++\",{\"1\":{\"26\":1}}],[\"迭代器模型\",{\"1\":{\"25\":1}}],[\"赋值\",{\"1\":{\"26\":1,\"36\":1}}],[\"调用\",{\"1\":{\"26\":1,\"36\":1,\"58\":1,\"65\":1}}],[\"下一个\",{\"1\":{\"26\":1,\"36\":1}}],[\"下面会介绍\",{\"1\":{\"64\":1}}],[\"下面我们分别简单介绍一下\",{\"1\":{\"50\":1}}],[\"下面\",{\"1\":{\"5\":1,\"6\":1,\"57\":1,\"58\":1}}],[\"仍以全表扫描为例\",{\"1\":{\"26\":1}}],[\"仍然恢复到发生前的状态\",{\"1\":{\"39\":1}}],[\"仍然以全表扫描为例\",{\"1\":{\"36\":1}}],[\"仍然会存在\",{\"1\":{\"32\":1}}],[\"仍然满足半满性质\",{\"1\":{\"20\":1}}],[\"仍然是内部节点\",{\"1\":{\"19\":1}}],[\"用容量减去当前的缓冲区大小即可\",{\"1\":{\"62\":1}}],[\"用绝对序号来表示数据流上字节的数量\",{\"1\":{\"62\":1}}],[\"用户态协议\",{\"0\":{\"57\":1}}],[\"用来保护\",{\"1\":{\"35\":1}}],[\"用来记录事务正在等待获取的锁\",{\"1\":{\"34\":1}}],[\"用来唯一标识一张表\",{\"1\":{\"26\":1}}],[\"用于序列重组\",{\"1\":{\"61\":1}}],[\"用于初始化一个字节流\",{\"1\":{\"60\":1}}],[\"用于实现低延时\",{\"1\":{\"45\":1}}],[\"用于故障后数据恢复\",{\"1\":{\"5\":1}}],[\"用于\",{\"1\":{\"3\":1,\"16\":1,\"61\":1,\"62\":1}}],[\"断言\",{\"1\":{\"26\":1}}],[\"谓词不为空\",{\"1\":{\"36\":1}}],[\"谓词\",{\"1\":{\"26\":1}}],[\"子查询计划列表\",{\"1\":{\"26\":1}}],[\"子查询计划\",{\"1\":{\"26\":1}}],[\"子节点枷锁\",{\"1\":{\"20\":1}}],[\"子节点加锁\",{\"1\":{\"20\":1}}],[\"子节点个数\",{\"1\":{\"18\":1}}],[\"子节点\",{\"1\":{\"15\":1}}],[\"作为所有查询计划的父类\",{\"1\":{\"26\":1}}],[\"作为主类\",{\"1\":{\"16\":1}}],[\"父执行器在\",{\"1\":{\"25\":1}}],[\"父节点解锁\",{\"1\":{\"20\":1}}],[\"父节点无需分裂\",{\"1\":{\"18\":1}}],[\"父节点一定是内部节点\",{\"1\":{\"18\":1}}],[\"父节点的子节点个数+1\",{\"1\":{\"18\":1}}],[\"父节点\",{\"1\":{\"16\":1,\"18\":1}}],[\"批处理模型\",{\"1\":{\"25\":1}}],[\"规定了执行器如何去执行查询计划\",{\"1\":{\"25\":1}}],[\"聚合函数\",{\"1\":{\"24\":1}}],[\"访问\",{\"1\":{\"24\":1}}],[\"优化器\",{\"1\":{\"24\":1}}],[\"优化器等\",{\"1\":{\"5\":1}}],[\"优化并得到该语句的\",{\"1\":{\"24\":1}}],[\"本问题难点在于两个\",{\"1\":{\"76\":1}}],[\"本着实践加深理解的初衷\",{\"1\":{\"49\":1}}],[\"本节的主角是执行器\",{\"1\":{\"24\":1}}],[\"本文实现的协议我们统称为\",{\"1\":{\"57\":1}}],[\"本文只会贴出部分实现代码进行剖析\",{\"1\":{\"3\":1}}],[\"本文不会去介绍如何写\",{\"1\":{\"3\":1}}],[\"往往花了好久才能定位问题\",{\"1\":{\"21\":1}}],[\"往往十分诡异\",{\"1\":{\"21\":1}}],[\"肉眼很难捕捉\",{\"1\":{\"21\":1}}],[\"尤其是一些\",{\"1\":{\"64\":1}}],[\"尤其是加上\",{\"1\":{\"21\":1}}],[\"尤其是支持并发的\",{\"1\":{\"21\":1}}],[\"笔者最开始在实现的时候小觑了这里\",{\"1\":{\"60\":1}}],[\"笔者跟随\",{\"1\":{\"49\":1}}],[\"笔者在实现的过程中\",{\"1\":{\"21\":1}}],[\"笔者选择了最常见的双向链表+哈希表法\",{\"1\":{\"10\":1}}],[\"小的节点在前面\",{\"1\":{\"61\":1}}],[\"小\",{\"1\":{\"45\":1}}],[\"小结\",{\"0\":{\"21\":1}}],[\"小于\",{\"1\":{\"18\":1,\"19\":1,\"61\":2}}],[\"搜索\",{\"1\":{\"20\":1}}],[\"搜索是\",{\"1\":{\"17\":1}}],[\"全双工意味着\",{\"1\":{\"54\":1}}],[\"全双工\",{\"0\":{\"54\":1}}],[\"全双工的\",{\"1\":{\"49\":1}}],[\"全表扫描仅仅只是其中最简单的一种\",{\"1\":{\"26\":1}}],[\"全表扫描查询计划保存了当前查询的表\",{\"1\":{\"26\":1}}],[\"全被锁住了\",{\"1\":{\"20\":1}}],[\"全部加锁\",{\"1\":{\"20\":1}}],[\"全称最近最少使用算法\",{\"1\":{\"10\":1}}],[\"读已提交\",{\"1\":{\"36\":2}}],[\"读提交\",{\"1\":{\"31\":3}}],[\"读未提交无法解决脏读\",{\"1\":{\"31\":1}}],[\"读未提交\",{\"1\":{\"31\":2,\"36\":2}}],[\"读\",{\"1\":{\"20\":1,\"53\":1}}],[\"读取后会移除前\",{\"1\":{\"60\":1}}],[\"读取字节流中的前\",{\"1\":{\"60\":1}}],[\"读取\",{\"1\":{\"16\":1}}],[\"号元素\",{\"1\":{\"20\":1}}],[\"查看字节流的前\",{\"1\":{\"60\":1}}],[\"查看其说明\",{\"1\":{\"11\":1}}],[\"查询条件等\",{\"1\":{\"26\":1}}],[\"查询数据组织方式\",{\"1\":{\"26\":1}}],[\"查询\",{\"1\":{\"24\":1}}],[\"查询计划\",{\"1\":{\"24\":1,\"25\":1,\"26\":1,\"36\":1}}],[\"查询过程中\",{\"1\":{\"20\":1}}],[\"开始监听\",{\"1\":{\"65\":1}}],[\"开始一个事务\",{\"1\":{\"32\":1}}],[\"开始\",{\"1\":{\"20\":1,\"32\":1,\"62\":3}}],[\"开始加共享锁\",{\"1\":{\"20\":1}}],[\"开源于\",{\"1\":{\"3\":1}}],[\"待操作完毕后\",{\"1\":{\"20\":1}}],[\"待页慢需要淘汰时\",{\"1\":{\"10\":1}}],[\"别人也可以同时访问\",{\"1\":{\"20\":1}}],[\"粒度\",{\"1\":{\"20\":1}}],[\"蟹行协议\",{\"1\":{\"20\":1}}],[\"发起连接\",{\"1\":{\"65\":1}}],[\"发生时\",{\"1\":{\"64\":1}}],[\"发生重组\",{\"1\":{\"20\":1}}],[\"发包等功能\",{\"1\":{\"64\":1}}],[\"发送数据\",{\"1\":{\"65\":1}}],[\"发送空包\",{\"1\":{\"64\":1}}],[\"发送空包是\",{\"1\":{\"64\":1}}],[\"发送报文\",{\"1\":{\"64\":1}}],[\"发送者\",{\"1\":{\"64\":1}}],[\"发送但未确认的字节数\",{\"1\":{\"63\":1}}],[\"发送但未确认的包\",{\"1\":{\"63\":1}}],[\"发送\",{\"1\":{\"61\":2,\"63\":1,\"64\":1,\"65\":1}}],[\"发现数据有错误\",{\"1\":{\"60\":1}}],[\"发现数据变成了\",{\"1\":{\"31\":1}}],[\"发现父节点未满足半满的性质\",{\"1\":{\"19\":1}}],[\"发现节点\",{\"1\":{\"18\":1,\"20\":1}}],[\"发现\",{\"1\":{\"18\":1}}],[\"安全\",{\"1\":{\"20\":2}}],[\"释放锁\",{\"1\":{\"34\":4}}],[\"释放锁后\",{\"1\":{\"33\":1}}],[\"释放锁阶段\",{\"1\":{\"32\":1}}],[\"释放\",{\"1\":{\"20\":3}}],[\"释放所有节点上的锁\",{\"1\":{\"20\":1}}],[\"释放父节点上的锁\",{\"1\":{\"20\":1}}],[\"释放该页\",{\"1\":{\"11\":1}}],[\"沿着树向下遍历\",{\"1\":{\"20\":1}}],[\"该优化器基于牛顿迭代法\",{\"1\":{\"78\":1}}],[\"该问题为带约束的优化问题\",{\"1\":{\"76\":1}}],[\"该流由\",{\"1\":{\"58\":1}}],[\"该流负责接收程序写入的数据\",{\"1\":{\"58\":1}}],[\"该类主要维护\",{\"1\":{\"58\":1}}],[\"该方法接收四个参数\",{\"1\":{\"25\":1}}],[\"该锁确实可以保证树在多线程是数据安全的\",{\"1\":{\"20\":1}}],[\"该页可能会被替换\",{\"1\":{\"11\":1}}],[\"该页\",{\"1\":{\"11\":1}}],[\"该页不再受\",{\"1\":{\"10\":1}}],[\"思考一下\",{\"1\":{\"20\":1}}],[\"协议已经实现完毕了\",{\"1\":{\"65\":1}}],[\"协议类似于\",{\"1\":{\"60\":1}}],[\"协议代码核心文件\",{\"1\":{\"59\":1}}],[\"协议时\",{\"1\":{\"59\":1}}],[\"协议巧妙地将连接分为了\",{\"1\":{\"58\":1}}],[\"协议中的字节流类\",{\"1\":{\"58\":1}}],[\"协议概览\",{\"0\":{\"58\":1}}],[\"协议并不特别复杂\",{\"1\":{\"57\":1}}],[\"协议一样有滑动窗口\",{\"1\":{\"57\":1}}],[\"协议之上\",{\"1\":{\"57\":1}}],[\"协议建立在\",{\"1\":{\"57\":1}}],[\"协议做一些简单的介绍\",{\"1\":{\"57\":1}}],[\"协议在功能特性上完胜\",{\"1\":{\"57\":1}}],[\"协议定位非常类似\",{\"1\":{\"57\":1}}],[\"协议和\",{\"1\":{\"57\":1}}],[\"协议是一种简易版\",{\"1\":{\"57\":1}}],[\"协议是建立在\",{\"1\":{\"57\":1}}],[\"协议是目前名气最大\",{\"1\":{\"49\":1}}],[\"协议介绍\",{\"0\":{\"55\":1}}],[\"协议通信的双方既可以发送数据\",{\"1\":{\"54\":1}}],[\"协议上\",{\"1\":{\"49\":1}}],[\"协议成为了网络协议重点中的重点\",{\"1\":{\"49\":1}}],[\"协议实现\",{\"0\":{\"48\":1,\"59\":1}}],[\"协议后\",{\"1\":{\"21\":1,\"59\":1}}],[\"协议也有很多优化点\",{\"1\":{\"20\":1}}],[\"协议也十分好理解\",{\"1\":{\"20\":1}}],[\"协议则复杂一些\",{\"1\":{\"20\":1}}],[\"协议的性能怎么样呢\",{\"1\":{\"65\":1}}],[\"协议的封装\",{\"1\":{\"65\":1}}],[\"协议的具体实现逻辑和一些细节\",{\"1\":{\"59\":1}}],[\"协议的主体类为\",{\"1\":{\"58\":1}}],[\"协议的精髓\",{\"1\":{\"49\":1}}],[\"协议的实现\",{\"1\":{\"20\":1,\"56\":1}}],[\"协议的核心点在于\",{\"1\":{\"20\":1}}],[\"协议的向下查找方式像极了螃蟹走路\",{\"1\":{\"20\":1}}],[\"协议\",{\"0\":{\"20\":1},\"1\":{\"49\":2,\"57\":5,\"58\":1,\"60\":1,\"66\":2,\"67\":1}}],[\"提供的函数\",{\"1\":{\"64\":1}}],[\"提交阶段\",{\"1\":{\"32\":1}}],[\"提交一个事务\",{\"1\":{\"32\":2}}],[\"提交\",{\"1\":{\"32\":1}}],[\"提示\",{\"1\":{\"19\":1}}],[\"提高访问性能\",{\"1\":{\"11\":1}}],[\"孩子节点成为新的根节点\",{\"1\":{\"19\":1}}],[\"末尾\",{\"1\":{\"19\":1}}],[\"\\b末尾移到\",{\"1\":{\"19\":1}}],[\"hit\",{\"1\":{\"74\":1}}],[\"hot\",{\"1\":{\"70\":1,\"73\":4}}],[\"huawei\",{\"1\":{\"69\":1}}],[\"hello\",{\"1\":{\"65\":23}}],[\"head\",{\"1\":{\"61\":16,\"62\":4}}],[\"header\",{\"1\":{\"16\":2,\"45\":1,\"61\":1,\"62\":7,\"63\":5,\"64\":14,\"65\":5}}],[\"hh\",{\"1\":{\"59\":6}}],[\"http\",{\"1\":{\"56\":1}}],[\"https\",{\"1\":{\"37\":2}}],[\"have\",{\"1\":{\"63\":1,\"64\":1}}],[\"handle\",{\"1\":{\"61\":3}}],[\"hasn\",{\"1\":{\"62\":1}}],[\"has\",{\"1\":{\"45\":2,\"62\":1,\"63\":2,\"64\":7,\"65\":2,\"72\":1}}],[\"hascycle\",{\"1\":{\"35\":1}}],[\"happens\",{\"1\":{\"19\":1}}],[\"兄弟节点\",{\"1\":{\"19\":1}}],[\"判断头部没有\",{\"1\":{\"65\":1}}],[\"判断节点\",{\"1\":{\"61\":1}}],[\"判断节点大小是否小于叶子节点最大个数\",{\"1\":{\"18\":1}}],[\"判断事务隔离级别\",{\"1\":{\"36\":1}}],[\"判断迭代器是否结束\",{\"1\":{\"26\":1}}],[\"判断是否需要删除根节点\",{\"1\":{\"19\":1}}],[\"判断\",{\"1\":{\"19\":1}}],[\"判断一下\",{\"1\":{\"19\":1}}],[\"否则直接拒绝\",{\"1\":{\"62\":1}}],[\"否则返回失败\",{\"1\":{\"35\":1}}],[\"否则迭代器继续\",{\"1\":{\"26\":1}}],[\"否则一直持有\",{\"1\":{\"20\":1}}],[\"否则找到含\",{\"1\":{\"19\":1}}],[\"否则页永远不能删除\",{\"1\":{\"11\":1}}],[\"虽然使用方便\",{\"1\":{\"56\":1}}],[\"虽然\",{\"1\":{\"52\":1}}],[\"虽然这增加了实现的复杂性\",{\"1\":{\"52\":1}}],[\"虽然节点\",{\"1\":{\"19\":1}}],[\"虽然是物理页数据\",{\"1\":{\"16\":1}}],[\"现在再从树中删除\",{\"1\":{\"19\":1}}],[\"现在从树中删除\",{\"1\":{\"19\":1}}],[\"重发后\",{\"1\":{\"63\":1}}],[\"重试失败的时机下调用即可\",{\"1\":{\"64\":1}}],[\"重试发送\",{\"1\":{\"64\":1}}],[\"重试次数超过了默认次数\",{\"1\":{\"64\":1}}],[\"重试次数\",{\"1\":{\"63\":1}}],[\"重试时间\",{\"1\":{\"63\":1}}],[\"重试一次就\",{\"1\":{\"63\":1}}],[\"重新发送\",{\"1\":{\"63\":1}}],[\"重新发送最早的包\",{\"1\":{\"63\":1}}],[\"重新从\",{\"1\":{\"62\":1}}],[\"重新建立图\",{\"1\":{\"35\":1}}],[\"重载了<\",{\"1\":{\"61\":1}}],[\"重载\",{\"1\":{\"61\":1}}],[\"重传\",{\"1\":{\"57\":1}}],[\"重复\",{\"1\":{\"61\":1}}],[\"重复等问题\",{\"1\":{\"52\":1}}],[\"重复这个过程\",{\"1\":{\"20\":2}}],[\"重点在于\",{\"1\":{\"51\":1}}],[\"重点在于搜索时根据操作类型来选择锁的方式\",{\"1\":{\"20\":1}}],[\"重做操作并将数据库恢复到崩溃前的状态\",{\"1\":{\"39\":1}}],[\"重组器判断报文头字节序号与\",{\"1\":{\"61\":1}}],[\"重组节点\",{\"1\":{\"61\":1}}],[\"重组乱序的报文数据\",{\"1\":{\"61\":1}}],[\"重组报文数据而来\",{\"1\":{\"58\":1}}],[\"重组\",{\"1\":{\"19\":3,\"62\":1}}],[\"重组后为\",{\"1\":{\"19\":1}}],[\"重组过程比较简单\",{\"1\":{\"19\":1}}],[\"重置\",{\"1\":{\"11\":1}}],[\"合并完成以后\",{\"1\":{\"61\":1}}],[\"合并完毕后\",{\"1\":{\"61\":1}}],[\"合并时\",{\"1\":{\"20\":1}}],[\"合并都是可以递归向上执行的\",{\"1\":{\"19\":1}}],[\"合并以后可能还需要合并或者重组\",{\"1\":{\"19\":1}}],[\"合并\",{\"1\":{\"19\":3,\"20\":3,\"61\":2}}],[\"合并成为节点\",{\"1\":{\"19\":1}}],[\"合并后大小仍然大于\",{\"1\":{\"19\":1}}],[\"合理利用好二分查找就足够了\",{\"1\":{\"17\":1}}],[\"大\",{\"1\":{\"45\":2}}],[\"大于\",{\"1\":{\"19\":1}}],[\"大小来重做未完成的事务\",{\"1\":{\"41\":1}}],[\"大小只有\",{\"1\":{\"19\":2}}],[\"大小为\",{\"1\":{\"19\":3,\"20\":1}}],[\"大小计算而来的\",{\"1\":{\"16\":1}}],[\"且被确认\",{\"1\":{\"65\":1}}],[\"且处于\",{\"1\":{\"65\":1}}],[\"且发送空包\",{\"1\":{\"65\":1}}],[\"且超时时间\",{\"1\":{\"63\":1}}],[\"且重试次数为\",{\"1\":{\"63\":1}}],[\"且重试时间是依次递增\",{\"1\":{\"63\":1}}],[\"且还有包未确认\",{\"1\":{\"63\":1}}],[\"且包长度小于窗口大小\",{\"1\":{\"63\":1}}],[\"且流已经\",{\"1\":{\"63\":1}}],[\"且数据流关闭\",{\"1\":{\"62\":1}}],[\"且数据基本单位是页\",{\"1\":{\"11\":1}}],[\"且本地没有\",{\"1\":{\"62\":1}}],[\"且\",{\"1\":{\"62\":1}}],[\"且向数据流中写入\",{\"1\":{\"62\":1}}],[\"且为空\",{\"1\":{\"61\":1}}],[\"且为根节点\",{\"1\":{\"20\":1}}],[\"且无\",{\"1\":{\"63\":1}}],[\"且无法加读锁\",{\"1\":{\"36\":1}}],[\"且无任何子节点\",{\"1\":{\"19\":1}}],[\"且不能加读锁\",{\"1\":{\"36\":1}}],[\"且事务处于\",{\"1\":{\"35\":1}}],[\"且多个操作不可分割\",{\"1\":{\"30\":1}}],[\"且共享锁是共享的\",{\"1\":{\"20\":1}}],[\"且所有节点无需变更\",{\"1\":{\"20\":1}}],[\"且已经没有子节点了\",{\"1\":{\"19\":1}}],[\"且有一个孩子节点\",{\"1\":{\"19\":1}}],[\"且其兄弟节点\",{\"1\":{\"19\":1}}],[\"且也处于半满状态\",{\"1\":{\"19\":1}}],[\"且只有一个子节点\",{\"1\":{\"19\":1}}],[\"操作成功后\",{\"1\":{\"20\":1}}],[\"操作\",{\"1\":{\"19\":1,\"35\":1}}],[\"操作完成后\",{\"1\":{\"11\":1}}],[\"值\",{\"1\":{\"19\":2}}],[\"值则是插入到\",{\"1\":{\"15\":1}}],[\"二叉树\",{\"1\":{\"61\":1}}],[\"二进制\",{\"1\":{\"45\":1}}],[\"二阶段事务沿用了这三个操作\",{\"1\":{\"32\":1}}],[\"二阶段事务\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"二者大小加起来也只有\",{\"1\":{\"19\":1}}],[\"二者的子节点\",{\"1\":{\"19\":2}}],[\"二分查找主要运用在如下两点\",{\"1\":{\"17\":1}}],[\"二分查找\",{\"1\":{\"17\":1}}],[\"半满\",{\"1\":{\"19\":1}}],[\"插图流程图如图\",{\"1\":{\"18\":1}}],[\"插入操作\",{\"1\":{\"20\":1}}],[\"插入后不会超过\",{\"1\":{\"20\":1}}],[\"插入后判断是否需要分裂\",{\"1\":{\"18\":1}}],[\"插入一个\",{\"1\":{\"20\":1}}],[\"插入父节点\",{\"1\":{\"18\":1}}],[\"插入失败\",{\"1\":{\"18\":1}}],[\"插入到叶子节点中\",{\"1\":{\"18\":1}}],[\"插入至叶子节点\",{\"1\":{\"18\":1}}],[\"插入执行器等\",{\"1\":{\"6\":1}}],[\"插入\",{\"1\":{\"5\":1,\"16\":1,\"18\":1,\"24\":1,\"61\":1}}],[\"插入等计划\",{\"1\":{\"5\":1}}],[\"直到无包可发送\",{\"1\":{\"63\":1}}],[\"直到满足半满为止\",{\"1\":{\"19\":1}}],[\"直至寻找到包含\",{\"1\":{\"20\":1}}],[\"直至无需分裂后返回\",{\"1\":{\"18\":1}}],[\"直接抵消了\",{\"1\":{\"62\":1}}],[\"直接\",{\"1\":{\"36\":2,\"61\":1,\"62\":1}}],[\"直接返回\",{\"1\":{\"11\":2,\"17\":1,\"18\":2,\"19\":1,\"26\":1,\"35\":1,\"36\":1,\"63\":1}}],[\"直接将链表尾部页淘汰即可\",{\"1\":{\"10\":1}}],[\"依次向上递归\",{\"1\":{\"18\":1}}],[\"需记得对兄弟节点加独占锁\",{\"1\":{\"20\":1}}],[\"需先找到该叶子结点\",{\"1\":{\"18\":1}}],[\"需要满足一下几个条件\",{\"1\":{\"64\":1}}],[\"需要判断是否超过了窗口\",{\"1\":{\"62\":1}}],[\"需要处理很多边角逻辑\",{\"1\":{\"62\":1}}],[\"需要先从局部出发\",{\"1\":{\"59\":1}}],[\"需要一个重组器组件专门用于流序号的重组工作\",{\"1\":{\"53\":1}}],[\"需要通过三次握手来确认对端状态\",{\"1\":{\"51\":1}}],[\"需要三次握手来协商建立连接\",{\"1\":{\"51\":1}}],[\"需要对protobuf及其反射原理进行调研\",{\"1\":{\"45\":1}}],[\"需要对节点\",{\"1\":{\"18\":1}}],[\"需要合并\",{\"1\":{\"19\":1,\"20\":1}}],[\"需要注意脏页\",{\"1\":{\"11\":1}}],[\"需要注意\",{\"1\":{\"11\":1,\"64\":1}}],[\"需要保证并发安全\",{\"1\":{\"10\":1}}],[\"递归\",{\"1\":{\"18\":1}}],[\"递归情况\",{\"1\":{\"18\":1}}],[\"拿到父节点\",{\"1\":{\"18\":1}}],[\"other\",{\"1\":{\"74\":1}}],[\"ome\",{\"1\":{\"73\":1}}],[\"overview\",{\"0\":{\"70\":1}}],[\"override\",{\"1\":{\"10\":4,\"26\":1}}],[\"occupied\",{\"1\":{\"64\":1}}],[\"our\",{\"1\":{\"62\":1,\"63\":2}}],[\"outgoing\",{\"1\":{\"63\":1}}],[\"outbound\",{\"1\":{\"63\":1,\"64\":6,\"65\":4}}],[\"out\",{\"1\":{\"45\":4,\"60\":2,\"62\":4,\"63\":4,\"64\":10}}],[\"output\",{\"1\":{\"26\":8,\"58\":2,\"60\":5,\"61\":4}}],[\"oss\",{\"1\":{\"45\":6}}],[\"ostringstream\",{\"1\":{\"45\":2}}],[\"order\",{\"1\":{\"61\":1}}],[\"org\",{\"1\":{\"56\":1}}],[\"oriented\",{\"1\":{\"49\":1}}],[\"or\",{\"1\":{\"36\":1,\"63\":1}}],[\"online\",{\"1\":{\"69\":1}}],[\"one\",{\"1\":{\"64\":1,\"70\":1,\"72\":2,\"73\":4,\"74\":1}}],[\"on\",{\"1\":{\"35\":11,\"56\":2,\"64\":1,\"70\":1,\"72\":1,\"73\":1}}],[\"off\",{\"1\":{\"63\":1}}],[\"offset\",{\"1\":{\"24\":1,\"41\":1,\"61\":3}}],[\"of\",{\"0\":{\"70\":1},\"1\":{\"34\":1,\"61\":1,\"62\":2,\"63\":2,\"64\":3,\"65\":1,\"72\":2,\"73\":3,\"74\":2}}],[\"oid\",{\"1\":{\"26\":9}}],[\"optimization\",{\"0\":{\"83\":1}}],[\"optim\",{\"1\":{\"78\":1}}],[\"optimal\",{\"1\":{\"70\":1}}],[\"optional<uint16\",{\"1\":{\"63\":1}}],[\"optional<wrappingint32>\",{\"1\":{\"62\":2}}],[\"optional\",{\"1\":{\"62\":2,\"63\":1}}],[\"options\",{\"1\":{\"57\":1}}],[\"operator<\",{\"1\":{\"61\":1}}],[\"operationtype\",{\"1\":{\"20\":2}}],[\"op\",{\"1\":{\"20\":4}}],[\"old\",{\"1\":{\"18\":7,\"19\":5}}],[\"ok\",{\"1\":{\"18\":2,\"19\":2,\"36\":1}}],[\"根据\",{\"1\":{\"63\":2}}],[\"根据descriptor获取message\",{\"1\":{\"45\":1}}],[\"根据messagename获取descriptor\",{\"1\":{\"45\":1}}],[\"根\",{\"1\":{\"18\":1,\"61\":1}}],[\"根节点页\",{\"1\":{\"20\":1}}],[\"根节点不用更新\",{\"1\":{\"20\":1}}],[\"根节点还不是最后一个节点\",{\"1\":{\"19\":1}}],[\"根节点除外\",{\"1\":{\"18\":1}}],[\"根节点\",{\"1\":{\"15\":1,\"18\":1,\"19\":1}}],[\"根节点既可以是内部节点\",{\"1\":{\"15\":1}}],[\"空包用于\",{\"1\":{\"64\":1}}],[\"空包有另外的处理\",{\"1\":{\"63\":1}}],[\"空包直接返回\",{\"1\":{\"63\":1}}],[\"空树\",{\"1\":{\"18\":1}}],[\"空闲页列表\",{\"1\":{\"11\":1}}],[\"第一个包必须携带\",{\"1\":{\"62\":1}}],[\"第一个接收的包一定包含了\",{\"1\":{\"62\":1}}],[\"第一次收到\",{\"1\":{\"62\":1}}],[\"第一次是叶子节点\",{\"1\":{\"18\":1}}],[\"第二次查询却发现有\",{\"1\":{\"31\":1}}],[\"第二次是内部节点\",{\"1\":{\"18\":1}}],[\"引起了两次节点分裂\",{\"1\":{\"18\":1}}],[\"9090\",{\"1\":{\"56\":5}}],[\"9\",{\"1\":{\"18\":2,\"19\":3}}],[\"进一步处理返回\",{\"1\":{\"25\":1}}],[\"进行优化问题的迭代\",{\"1\":{\"78\":1}}],[\"进行算法实现\",{\"1\":{\"78\":1}}],[\"进行重组\",{\"1\":{\"19\":1}}],[\"进行分裂\",{\"1\":{\"18\":1}}],[\"进入被动关闭状态\",{\"1\":{\"65\":1}}],[\"进入\",{\"1\":{\"17\":1}}],[\"按照执行计划上的表范式\",{\"1\":{\"26\":1}}],[\"按照分裂情况\",{\"1\":{\"18\":2}}],[\"按照排序来\",{\"1\":{\"18\":1}}],[\"已结束\",{\"1\":{\"64\":1}}],[\"已经超过了\",{\"1\":{\"64\":1}}],[\"已经完全重组且结束\",{\"1\":{\"64\":1}}],[\"已经确认过了\",{\"1\":{\"63\":1}}],[\"已经确认的序列\",{\"1\":{\"62\":1}}],[\"已经重试的次数\",{\"1\":{\"63\":1}}],[\"已经在\",{\"1\":{\"62\":2}}],[\"已经被接收过了\",{\"1\":{\"62\":1}}],[\"已经被重组了\",{\"1\":{\"61\":1}}],[\"已经被锁了\",{\"1\":{\"35\":1}}],[\"已经拥有\",{\"1\":{\"18\":1}}],[\"已被提交的事务对数据库的修改应该永久保存在数据库中\",{\"1\":{\"30\":1}}],[\"已有\",{\"1\":{\"18\":1}}],[\"向服务端发送\",{\"1\":{\"65\":1}}],[\"向输出流写数据\",{\"1\":{\"64\":1}}],[\"向后一起合并了\",{\"1\":{\"61\":1}}],[\"向后合并\",{\"1\":{\"61\":1}}],[\"向前\",{\"1\":{\"61\":1}}],[\"向前合并\",{\"1\":{\"61\":1}}],[\"向字节流中写入数据\",{\"1\":{\"60\":1}}],[\"向客户端发送\",{\"1\":{\"51\":1}}],[\"向锁管理器请求\",{\"1\":{\"35\":1}}],[\"向下遍历\",{\"1\":{\"20\":1}}],[\"向叶子节点中插入\",{\"1\":{\"18\":1}}],[\"向根节点中插入数据\",{\"1\":{\"18\":1}}],[\"向\",{\"1\":{\"18\":1}}],[\"向树中插入一个新数据\",{\"1\":{\"18\":1}}],[\"向外提供\",{\"1\":{\"16\":1}}],[\"己有\",{\"1\":{\"18\":1}}],[\"7\",{\"1\":{\"18\":2,\"19\":1}}],[\"祖先节点可能仍需分离\",{\"1\":{\"18\":1}}],[\"平分为两个节点\",{\"1\":{\"18\":1}}],[\"势必会导致节点的子节点个数超过\",{\"1\":{\"18\":1}}],[\"难点在于节点分裂\",{\"1\":{\"18\":1}}],[\"右孩子节点大于等于当前\",{\"1\":{\"17\":1}}],[\"右边\",{\"1\":{\"15\":1}}],[\"左孩子节点小于当前\",{\"1\":{\"17\":1}}],[\"左边\",{\"1\":{\"15\":1}}],[\"wite\",{\"1\":{\"65\":11}}],[\"with\",{\"1\":{\"64\":2,\"65\":1,\"72\":1}}],[\"win\",{\"1\":{\"63\":4,\"64\":3,\"65\":1}}],[\"windows\",{\"1\":{\"62\":1}}],[\"window\",{\"1\":{\"58\":3,\"62\":5,\"63\":21,\"64\":6}}],[\"we\",{\"1\":{\"62\":1,\"64\":1,\"72\":7,\"73\":5}}],[\"wrap\",{\"1\":{\"62\":2,\"64\":1}}],[\"wrappingint32\",{\"1\":{\"62\":4,\"63\":2}}],[\"wrappingintegers\",{\"1\":{\"59\":2}}],[\"wrapping\",{\"1\":{\"59\":2}}],[\"written\",{\"1\":{\"60\":2,\"61\":3}}],[\"write\",{\"1\":{\"60\":2,\"61\":1,\"64\":4,\"65\":1}}],[\"writepage\",{\"1\":{\"11\":4}}],[\"www\",{\"1\":{\"37\":1}}],[\"wants\",{\"1\":{\"63\":1,\"64\":1}}],[\"wal\",{\"1\":{\"39\":1}}],[\"wakes\",{\"1\":{\"35\":1}}],[\"waits\",{\"1\":{\"35\":4}}],[\"waiting\",{\"1\":{\"35\":1,\"65\":3}}],[\"wait\",{\"1\":{\"34\":2,\"35\":8,\"65\":2}}],[\"which\",{\"1\":{\"70\":2,\"72\":1,\"73\":2}}],[\"while\",{\"1\":{\"17\":2,\"20\":1,\"25\":1,\"26\":2,\"35\":2,\"36\":1,\"61\":3,\"63\":2,\"64\":1,\"65\":1}}],[\"what\",{\"1\":{\"65\":2}}],[\"whole\",{\"1\":{\"64\":1}}],[\"when\",{\"1\":{\"35\":1,\"63\":1,\"70\":1,\"72\":1,\"73\":3}}],[\"where\",{\"1\":{\"26\":1}}],[\"wlatch\",{\"1\":{\"20\":1}}],[\"获得\",{\"1\":{\"17\":1}}],[\"获取报文并发送\",{\"1\":{\"58\":1}}],[\"获取filedescription\",{\"1\":{\"45\":1}}],[\"获取对应的reflection\",{\"1\":{\"45\":1}}],[\"获取对应页\",{\"1\":{\"11\":1}}],[\"获取\",{\"1\":{\"45\":1,\"58\":1}}],[\"获取锁阶段\",{\"1\":{\"32\":1}}],[\"获取列数据\",{\"1\":{\"26\":1,\"36\":1}}],[\"获取子执行器数据记录后\",{\"1\":{\"25\":1}}],[\"获取子节点\",{\"1\":{\"20\":2}}],[\"获取了数据页\",{\"1\":{\"11\":1}}],[\"获取数据页\",{\"1\":{\"11\":1}}],[\"获取所有数据页\",{\"1\":{\"11\":1}}],[\"只会重发队首的报文\",{\"1\":{\"63\":1}}],[\"只会查看前\",{\"1\":{\"60\":1}}],[\"只需将发送的报文推入到两个队列中即\",{\"1\":{\"63\":1}}],[\"只能增加重试次数\",{\"1\":{\"63\":1}}],[\"只能做到尽最大努力交付\",{\"1\":{\"52\":1}}],[\"只能在结束时释放所有的锁\",{\"1\":{\"32\":1}}],[\"只能释放原来获取的锁\",{\"1\":{\"32\":1}}],[\"只能释放锁\",{\"1\":{\"32\":1}}],[\"只能尽可能的将热点数据存储在缓冲池中\",{\"1\":{\"10\":1}}],[\"只剩下根节点了\",{\"1\":{\"19\":1}}],[\"只有\",{\"1\":{\"18\":1,\"61\":1}}],[\"只要一个页使用完毕后\",{\"1\":{\"17\":1}}],[\"伪代码只为说明过程和原理\",{\"1\":{\"19\":1}}],[\"伪代码如下\",{\"1\":{\"17\":1}}],[\"伪代码实现如下\",{\"1\":{\"11\":1}}],[\"语言支持程度\",{\"1\":{\"45\":1}}],[\"语言特性\",{\"1\":{\"16\":1}}],[\"语句\",{\"1\":{\"26\":1}}],[\"语句后\",{\"1\":{\"24\":1}}],[\"语句转化为执行计划\",{\"1\":{\"5\":1}}],[\"被解析为\",{\"1\":{\"58\":1}}],[\"被\",{\"1\":{\"54\":1}}],[\"被调用时可以调用子执行器的\",{\"1\":{\"25\":1}}],[\"被虐的死去活来\",{\"1\":{\"21\":1}}],[\"被删除后\",{\"1\":{\"19\":1}}],[\"被分裂为\",{\"1\":{\"18\":1}}],[\"被分裂成\",{\"1\":{\"18\":1}}],[\"被读取转换后才能知道其\",{\"1\":{\"16\":1}}],[\"被称为\",{\"1\":{\"16\":1}}],[\"节点也需要合并\",{\"1\":{\"19\":1}}],[\"节点指向兄弟节点的指针\",{\"1\":{\"19\":1}}],[\"节点的键\",{\"1\":{\"19\":1}}],[\"节点的指针\",{\"1\":{\"18\":1}}],[\"节点中\",{\"1\":{\"61\":1}}],[\"节点中指向\",{\"1\":{\"19\":1}}],[\"节点中的键值对也是有序的\",{\"1\":{\"17\":1}}],[\"节点将自己的末尾项\",{\"1\":{\"19\":1}}],[\"节点加起来的大小为\",{\"1\":{\"19\":1}}],[\"节点是\",{\"1\":{\"19\":1}}],[\"节点大小为\",{\"1\":{\"19\":1}}],[\"节点大小会变小\",{\"1\":{\"19\":1}}],[\"节点合并后成为节点\",{\"1\":{\"19\":1}}],[\"节点合并\",{\"1\":{\"19\":1,\"61\":1}}],[\"节点分裂后会使父节点的孩子节点个数增加\",{\"1\":{\"18\":1}}],[\"节点分裂可分为如下两种情况\",{\"1\":{\"18\":1}}],[\"节点上的第一个键上移到节点\",{\"1\":{\"18\":1}}],[\"节点需要分裂\",{\"1\":{\"18\":1}}],[\"节点之间是有序的\",{\"1\":{\"17\":1}}],[\"节点类型\",{\"1\":{\"16\":1}}],[\"节点\",{\"1\":{\"16\":1,\"18\":12,\"19\":6,\"20\":1}}],[\"还发个鬼啊\",{\"1\":{\"63\":1}}],[\"还未完全理清楚\",{\"1\":{\"36\":1}}],[\"还定义了执行器的基本方法\",{\"1\":{\"26\":1}}],[\"还是解锁都十分简单\",{\"1\":{\"20\":1}}],[\"还是叶子节点\",{\"1\":{\"16\":1}}],[\"还必须得兄弟节点加独占锁\",{\"1\":{\"20\":1}}],[\"还需要判断父节点是否需要分裂\",{\"1\":{\"18\":1}}],[\"还会保存页的元数据\",{\"1\":{\"16\":1}}],[\"还有目前使用最广泛\",{\"1\":{\"3\":1}}],[\"转化为叶子结点\",{\"1\":{\"17\":1}}],[\"转化为\",{\"1\":{\"16\":1}}],[\"叶子\",{\"1\":{\"18\":1}}],[\"叶子结点\",{\"1\":{\"16\":1}}],[\"叶子节点是值的个数\",{\"1\":{\"18\":1}}],[\"叶子节点能容纳的\",{\"1\":{\"16\":1}}],[\"叶子节点两种\",{\"1\":{\"16\":1}}],[\"叶子节点\",{\"1\":{\"16\":1}}],[\"叶子节点没有子节点\",{\"1\":{\"15\":1}}],[\"叶子节点三种节点\",{\"1\":{\"15\":1}}],[\"了好久才察觉是\",{\"1\":{\"60\":1}}],[\"了\",{\"1\":{\"16\":1,\"63\":3}}],[\"了解了\",{\"1\":{\"6\":1}}],[\"说明\",{\"1\":{\"16\":1,\"49\":1,\"63\":2}}],[\"恰好能获取一个节点的数据\",{\"1\":{\"16\":1}}],[\"参考终端输出的\",{\"1\":{\"65\":1}}],[\"参考资料\",{\"0\":{\"7\":1,\"12\":1,\"22\":1,\"27\":1,\"37\":1,\"42\":1,\"67\":1}}],[\"参数来监听本地的\",{\"1\":{\"56\":1}}],[\"参数\",{\"1\":{\"16\":1,\"60\":1,\"62\":1}}],[\"参数用于指定树名称\",{\"1\":{\"16\":1}}],[\"构造函数\",{\"1\":{\"26\":1,\"60\":1}}],[\"构造\",{\"1\":{\"16\":1}}],[\"rate\",{\"1\":{\"74\":1}}],[\"rank\",{\"1\":{\"69\":1}}],[\"random\",{\"1\":{\"63\":1}}],[\"rsts\",{\"1\":{\"64\":1}}],[\"rst\",{\"1\":{\"64\":14}}],[\"rt\",{\"1\":{\"64\":4}}],[\"rto\",{\"1\":{\"63\":1}}],[\"runflushthread\",{\"1\":{\"40\":1}}],[\"runcycledetection\",{\"1\":{\"35\":1}}],[\"room\",{\"0\":{\"46\":1}}],[\"root\",{\"1\":{\"17\":1,\"18\":8,\"19\":8}}],[\"rolled\",{\"1\":{\"35\":1}}],[\"rollback\",{\"1\":{\"32\":2}}],[\"rc\",{\"1\":{\"31\":1}}],[\"rr\",{\"1\":{\"31\":1}}],[\"rlatch\",{\"1\":{\"20\":2}}],[\"rid\",{\"1\":{\"16\":3,\"25\":3,\"26\":5,\"35\":17,\"36\":3}}],[\"refer\",{\"1\":{\"73\":1}}],[\"reflect\",{\"1\":{\"64\":1}}],[\"reflection\",{\"1\":{\"45\":11}}],[\"regrettably\",{\"1\":{\"69\":1}}],[\"reordering\",{\"1\":{\"65\":1}}],[\"remote\",{\"1\":{\"64\":3,\"65\":12}}],[\"removed\",{\"1\":{\"70\":1,\"73\":2}}],[\"remove\",{\"1\":{\"19\":2,\"60\":1,\"72\":1,\"73\":1}}],[\"remain\",{\"1\":{\"63\":3}}],[\"retx\",{\"1\":{\"64\":3}}],[\"retransmissions\",{\"1\":{\"63\":3,\"64\":2,\"65\":1}}],[\"retransmission\",{\"1\":{\"63\":9}}],[\"returned\",{\"1\":{\"36\":1}}],[\"return\",{\"1\":{\"10\":4,\"11\":13,\"17\":5,\"18\":7,\"19\":7,\"20\":1,\"25\":1,\"26\":7,\"35\":7,\"36\":5,\"40\":3,\"45\":3,\"60\":3,\"61\":2,\"62\":7,\"63\":9,\"64\":6,\"65\":4}}],[\"re\",{\"1\":{\"62\":1}}],[\"reached\",{\"1\":{\"64\":1}}],[\"reassembled\",{\"1\":{\"61\":1,\"62\":1}}],[\"reassembler\",{\"1\":{\"59\":2,\"62\":9}}],[\"read\",{\"1\":{\"31\":3,\"35\":3,\"36\":3,\"60\":5,\"63\":1,\"65\":1}}],[\"readpage\",{\"1\":{\"11\":1}}],[\"reliable\",{\"1\":{\"49\":1}}],[\"releaseallancestorlocks\",{\"1\":{\"20\":1}}],[\"redo\",{\"1\":{\"41\":3}}],[\"redistribute\",{\"1\":{\"19\":4}}],[\"redis\",{\"1\":{\"3\":1}}],[\"request\",{\"1\":{\"35\":11}}],[\"reply\",{\"1\":{\"64\":1}}],[\"replacer\",{\"1\":{\"10\":1,\"11\":8}}],[\"repeated\",{\"1\":{\"45\":1}}],[\"repeatable\",{\"1\":{\"31\":1,\"35\":1,\"36\":1}}],[\"res\",{\"1\":{\"65\":2}}],[\"result\",{\"1\":{\"25\":4,\"60\":2}}],[\"reset\",{\"1\":{\"11\":2,\"64\":2}}],[\"reinterpret\",{\"1\":{\"16\":4,\"17\":1,\"18\":4,\"19\":1}}],[\"recv\",{\"1\":{\"62\":1,\"64\":1}}],[\"receiving\",{\"1\":{\"62\":1}}],[\"received\",{\"1\":{\"58\":3,\"62\":4,\"63\":2,\"64\":19,\"65\":15}}],[\"receiver\",{\"1\":{\"54\":2,\"58\":2,\"59\":2,\"61\":2,\"62\":2,\"64\":17}}],[\"recently\",{\"1\":{\"10\":1}}],[\"record\",{\"1\":{\"35\":1,\"40\":1,\"41\":1,\"73\":1}}],[\"recovery\",{\"1\":{\"6\":2,\"42\":2}}],[\"例子可以为\",{\"1\":{\"16\":1}}],[\"分裂\",{\"1\":{\"18\":4}}],[\"分裂完毕\",{\"1\":{\"18\":1}}],[\"分裂过程与基本情况一致\",{\"1\":{\"18\":1}}],[\"分别用于数据输入和输出\",{\"1\":{\"60\":1}}],[\"分别介绍了缓存池组件以及支持存储引擎的\",{\"1\":{\"24\":1}}],[\"分别表示叶子节点和内部节点能够拥有的最大子节点个数\",{\"1\":{\"16\":1}}],[\"分别是\",{\"1\":{\"16\":1}}],[\"分配新的\",{\"1\":{\"11\":1}}],[\"键比较器类型\",{\"1\":{\"16\":1}}],[\"键即是图中的数字\",{\"1\":{\"15\":1}}],[\"支持节点有序化\",{\"1\":{\"61\":1}}],[\"支持\",{\"1\":{\"16\":1}}],[\"支持数据库事务\",{\"1\":{\"5\":1}}],[\"领略大师风采\",{\"1\":{\"16\":1}}],[\"有三个核心函数\",{\"1\":{\"63\":1}}],[\"有几个点需要说明一下\",{\"1\":{\"62\":1}}],[\"有什么联系呢\",{\"1\":{\"62\":1}}],[\"有缺别\",{\"1\":{\"61\":1}}],[\"有序排列\",{\"1\":{\"61\":1}}],[\"有问题\",{\"1\":{\"60\":1}}],[\"有两个数据流\",{\"1\":{\"60\":1}}],[\"有一条边指向\",{\"1\":{\"34\":1}}],[\"有多种查询计划\",{\"1\":{\"26\":1}}],[\"有且只有一个核心字段\",{\"1\":{\"26\":1}}],[\"有很多小细节都需要考虑和完善\",{\"1\":{\"21\":1}}],[\"有如下的处理方式\",{\"1\":{\"19\":1}}],[\"有如下几个核心方法\",{\"1\":{\"11\":1}}],[\"有父节点\",{\"1\":{\"18\":1}}],[\"有了这些元数据\",{\"1\":{\"16\":1}}],[\"有\",{\"1\":{\"15\":1}}],[\"情况就不一样了\",{\"1\":{\"15\":1}}],[\"指向孩子节点的指针则是值\",{\"1\":{\"15\":1}}],[\"取整\",{\"1\":{\"15\":1}}],[\"六阶\",{\"1\":{\"15\":1}}],[\"6\",{\"0\":{\"38\":1},\"1\":{\"15\":5,\"16\":2,\"18\":3,\"19\":4,\"56\":1}}],[\"6th\",{\"1\":{\"7\":1}}],[\"58\",{\"1\":{\"65\":1}}],[\"5\",{\"0\":{\"28\":1},\"1\":{\"15\":2,\"18\":2,\"19\":3,\"60\":1}}],[\"前面的执行器是无法支持事务隔离的\",{\"1\":{\"36\":1}}],[\"前面的两个小节中\",{\"1\":{\"24\":1}}],[\"前面实现的\",{\"1\":{\"20\":1}}],[\"前面\",{\"1\":{\"18\":1}}],[\"前面谈到\",{\"1\":{\"15\":1}}],[\"前言\",{\"0\":{\"3\":1}}],[\"首先要发送一个\",{\"1\":{\"63\":1}}],[\"首先\",{\"1\":{\"15\":1,\"16\":1,\"41\":1,\"56\":1,\"65\":2}}],[\"度一致\",{\"1\":{\"15\":1}}],[\"深入理解\",{\"1\":{\"67\":1}}],[\"深\",{\"1\":{\"15\":1}}],[\"个字节\",{\"1\":{\"60\":5}}],[\"个方法\",{\"1\":{\"60\":1}}],[\"个人观点\",{\"1\":{\"52\":1}}],[\"个状态\",{\"1\":{\"32\":1}}],[\"个数加起来\",{\"1\":{\"19\":2}}],[\"个数也\",{\"1\":{\"18\":1}}],[\"个值了\",{\"1\":{\"18\":1}}],[\"个值\",{\"1\":{\"15\":1,\"18\":1}}],[\"个孩子节点\",{\"1\":{\"15\":1}}],[\"个键\",{\"1\":{\"15\":3}}],[\"个子节点的内部叶节点包含\",{\"1\":{\"15\":1}}],[\"个子节点\",{\"1\":{\"15\":4,\"18\":5}}],[\"kills\",{\"1\":{\"64\":1}}],[\"know\",{\"1\":{\"64\":1}}],[\"keep\",{\"1\":{\"64\":1,\"74\":1}}],[\"keytype\",{\"1\":{\"16\":3}}],[\"key\",{\"1\":{\"16\":3,\"17\":14,\"18\":10,\"19\":5,\"20\":4}}],[\"keycomparator\",{\"1\":{\"16\":4}}],[\"keycomparator>\",{\"1\":{\"16\":3}}],[\"kv\",{\"1\":{\"16\":1,\"18\":3,\"20\":1}}],[\"k\",{\"1\":{\"15\":6,\"16\":7}}],[\"必须同时满足条件\",{\"1\":{\"64\":1}}],[\"必须在有\",{\"1\":{\"64\":1}}],[\"必须在接受对端包的情况下才知道对端的接受窗口大小\",{\"1\":{\"63\":1}}],[\"必须从\",{\"1\":{\"64\":1}}],[\"必须重置定时器时间和重试次数\",{\"1\":{\"63\":1}}],[\"必须得\",{\"1\":{\"62\":1}}],[\"必须使用\",{\"1\":{\"39\":1}}],[\"必须先接受\",{\"1\":{\"64\":1}}],[\"必须先由日志写入磁盘\",{\"1\":{\"39\":1}}],[\"必须先尝试获取该记录的锁\",{\"1\":{\"35\":1}}],[\"必须等待\",{\"1\":{\"33\":1,\"61\":1}}],[\"必须对\",{\"1\":{\"33\":1}}],[\"必须满足如下几个条件\",{\"1\":{\"15\":1}}],[\"必不可少的架构和设计功夫\",{\"1\":{\"0\":1}}],[\"阶段不能释放某一个锁\",{\"1\":{\"32\":1}}],[\"阶段\",{\"1\":{\"32\":1}}],[\"阶\",{\"1\":{\"15\":3,\"18\":1,\"19\":1}}],[\"树为空\",{\"1\":{\"17\":1}}],[\"树就可以用于存储\",{\"1\":{\"16\":1}}],[\"树中值的类型\",{\"1\":{\"16\":1}}],[\"树中键的类型\",{\"1\":{\"16\":1}}],[\"树中的数据\",{\"1\":{\"15\":1}}],[\"树可以拥有多个子节点\",{\"1\":{\"15\":1}}],[\"树的内部是内部节点\",{\"1\":{\"15\":1}}],[\"树的底部是叶子结点\",{\"1\":{\"15\":1}}],[\"树有三个节点\",{\"1\":{\"15\":1}}],[\"树有且只有一个节点\",{\"1\":{\"15\":1}}],[\"40\",{\"1\":{\"56\":1}}],[\"46\",{\"1\":{\"20\":2}}],[\"4\",{\"0\":{\"23\":1},\"1\":{\"15\":5,\"22\":1,\"32\":1,\"37\":1,\"42\":1,\"62\":1,\"64\":2}}],[\"内存损耗\",{\"1\":{\"60\":1}}],[\"内存是非常有限的\",{\"1\":{\"10\":1}}],[\"内部是一个红黑树实现\",{\"1\":{\"61\":1}}],[\"内部通过共享指针来实现字符串容器\",{\"1\":{\"60\":1}}],[\"内部节点只会存储键和子节点指针\",{\"1\":{\"15\":1}}],[\"内部节点的第一个键可以理解为是空的\",{\"1\":{\"15\":1}}],[\"内部节点\",{\"1\":{\"15\":1,\"16\":3}}],[\"内核态下\",{\"1\":{\"58\":1}}],[\"主要做如下三件事情\",{\"1\":{\"64\":1}}],[\"主要根据窗口大小来实时改变\",{\"1\":{\"63\":1}}],[\"主要功能点有\",{\"1\":{\"63\":1}}],[\"主要也是因为笔者\",{\"1\":{\"62\":1}}],[\"主流关系数据库\",{\"1\":{\"14\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"800\",{\"1\":{\"69\":1}}],[\"8\",{\"1\":{\"12\":1,\"18\":2}}],[\"所能解决的问题就越多\",{\"1\":{\"31\":1}}],[\"所有数据都被确认了\",{\"1\":{\"63\":1}}],[\"所有包确认后\",{\"1\":{\"63\":1}}],[\"所有执行器也有一个公共父类\",{\"1\":{\"26\":1}}],[\"所有项移动到\",{\"1\":{\"19\":1}}],[\"所有叶子节点高\",{\"1\":{\"15\":1}}],[\"所在的叶子节点页\",{\"1\":{\"18\":1}}],[\"所在的叶子结点\",{\"1\":{\"17\":1}}],[\"所以彼端可以直接设置\",{\"1\":{\"64\":1}}],[\"所以无需考虑输出流能否全部交付的问题\",{\"1\":{\"64\":1}}],[\"所以无法释放\",{\"1\":{\"20\":1}}],[\"所以输入流才能关闭\",{\"1\":{\"64\":1}}],[\"所以如果\",{\"1\":{\"63\":1}}],[\"所以\",{\"1\":{\"53\":1}}],[\"所以是安全的\",{\"1\":{\"20\":3}}],[\"所以每次\",{\"1\":{\"16\":1}}],[\"所以请切记\",{\"1\":{\"11\":1}}],[\"所示是一棵\",{\"1\":{\"15\":1}}],[\"所示\",{\"1\":{\"11\":1,\"15\":1,\"16\":1,\"18\":3,\"19\":6,\"20\":3,\"26\":1,\"31\":1}}],[\"会发送到队列中\",{\"1\":{\"64\":1}}],[\"会发现多出了如下日志\",{\"1\":{\"56\":1}}],[\"会占有\",{\"1\":{\"62\":1}}],[\"会消费流数据\",{\"1\":{\"60\":1}}],[\"会被设置一个\",{\"1\":{\"60\":1}}],[\"会重传这些包\",{\"1\":{\"52\":1}}],[\"会头到尾实现了一个用户态简易版\",{\"1\":{\"49\":1}}],[\"会扫描全部的日志文件\",{\"1\":{\"41\":1}}],[\"会读到脏数据\",{\"1\":{\"33\":1}}],[\"会从缓冲池中获取一个新页作为根节点页\",{\"1\":{\"18\":1}}],[\"会不断的扩容节点\",{\"1\":{\"18\":1}}],[\"会尝试从树中搜索\",{\"1\":{\"17\":1}}],[\"会减少\",{\"1\":{\"11\":1}}],[\"会增加页的\",{\"1\":{\"11\":1}}],[\"实践上充分的吸收网络知识\",{\"1\":{\"66\":1}}],[\"实际求解\",{\"0\":{\"78\":1}}],[\"实际为重组确认的当前序号\",{\"1\":{\"62\":1}}],[\"实际的代码实现其实比较复杂\",{\"1\":{\"19\":1}}],[\"实则就是对事务的控制\",{\"1\":{\"32\":1}}],[\"实则为一对反操作\",{\"1\":{\"11\":1}}],[\"实现是比较简单的\",{\"1\":{\"60\":1}}],[\"实现文件\",{\"1\":{\"59\":6}}],[\"实现的\",{\"1\":{\"57\":1}}],[\"实现\",{\"0\":{\"35\":1},\"1\":{\"62\":1}}],[\"实现了两个序号\",{\"1\":{\"62\":1}}],[\"实现了迭代器模型\",{\"1\":{\"25\":1}}],[\"实现了日志记录功能\",{\"1\":{\"5\":1}}],[\"实现过如此复杂的数据结构后\",{\"1\":{\"21\":1}}],[\"实现起来有难度\",{\"1\":{\"20\":1}}],[\"实现并不困难\",{\"1\":{\"10\":1}}],[\"实现数据库数据快照功能\",{\"1\":{\"5\":1}}],[\"时\",{\"1\":{\"16\":1,\"20\":2,\"33\":1,\"61\":1}}],[\"时也需要注意脏页\",{\"1\":{\"11\":1}}],[\"时序数据库\",{\"1\":{\"3\":1}}],[\"若有报文\",{\"1\":{\"58\":1}}],[\"若事务释放了一个数据的锁\",{\"1\":{\"32\":1}}],[\"若符合则取出值\",{\"1\":{\"26\":1}}],[\"若查询谓词为空\",{\"1\":{\"26\":1}}],[\"若结束\",{\"1\":{\"26\":1}}],[\"若需要\",{\"1\":{\"18\":1}}],[\"若节点\",{\"1\":{\"18\":1}}],[\"若是脏页\",{\"1\":{\"11\":1}}],[\"若无则淘汰一个页并且拿到该页\",{\"1\":{\"11\":1}}],[\"就有了\",{\"1\":{\"31\":1}}],[\"就很难再对数据结构产生畏惧\",{\"1\":{\"21\":1}}],[\"就可以释放上一个锁\",{\"1\":{\"20\":1}}],[\"就能快速锁定是左边节点还是右边节点\",{\"1\":{\"17\":1}}],[\"就是三次握手的第一步\",{\"1\":{\"65\":1}}],[\"就是通过\",{\"1\":{\"26\":1}}],[\"就是\",{\"1\":{\"15\":1}}],[\"就证明无人使用该页\",{\"1\":{\"11\":1}}],[\"就会更新\",{\"1\":{\"63\":1}}],[\"就会产生死锁\",{\"1\":{\"34\":1}}],[\"就会\",{\"1\":{\"11\":1}}],[\"就会有新页来继续使用这个\",{\"1\":{\"11\":1}}],[\"额外说明\",{\"1\":{\"11\":1}}],[\"刷新时间\",{\"1\":{\"64\":1}}],[\"刷每一页\",{\"1\":{\"11\":1}}],[\"刷数据页\",{\"1\":{\"11\":1}}],[\"即终端输出的\",{\"1\":{\"65\":1}}],[\"即三次握手第二步\",{\"1\":{\"65\":1}}],[\"即子条件\",{\"1\":{\"64\":1}}],[\"即报文均被确认\",{\"1\":{\"63\":1}}],[\"即剩下可以接受且重组的字节数才是窗口大小\",{\"1\":{\"62\":1}}],[\"即可\",{\"1\":{\"62\":1}}],[\"即是否要关闭输入数据流\",{\"1\":{\"61\":1}}],[\"即是否更改了该页数据\",{\"1\":{\"11\":1}}],[\"即没有字节被重组\",{\"1\":{\"61\":1}}],[\"即调用\",{\"1\":{\"58\":3,\"64\":1}}],[\"即当前请求共享锁的事务实例\",{\"1\":{\"35\":1}}],[\"即死锁\",{\"1\":{\"34\":1}}],[\"即事务本身觉得是序列化执行的\",{\"1\":{\"33\":1}}],[\"即字段的定义\",{\"1\":{\"26\":1,\"36\":1}}],[\"即执行器上下文\",{\"1\":{\"26\":1}}],[\"即对哪张表进行全表扫描\",{\"1\":{\"26\":1}}],[\"即\",{\"1\":{\"26\":1,\"62\":3,\"64\":3,\"65\":1}}],[\"即根节点\",{\"1\":{\"15\":1}}],[\"即上图\",{\"1\":{\"5\":1}}],[\">data\",{\"1\":{\"61\":1}}],[\">deallocatepage\",{\"1\":{\"11\":1}}],[\">cpp\",{\"1\":{\"45\":1}}],[\">hasfield\",{\"1\":{\"45\":1}}],[\">field\",{\"1\":{\"45\":2}}],[\">findfieldbyname\",{\"1\":{\"45\":1}}],[\">findmessagetypebyname\",{\"1\":{\"45\":1}}],[\">number\",{\"1\":{\"45\":1}}],[\">name\",{\"1\":{\"45\":4}}],[\">new\",{\"1\":{\"45\":1}}],[\">next\",{\"1\":{\"25\":1}}],[\">mutablemessage\",{\"1\":{\"45\":1}}],[\">unlock\",{\"1\":{\"36\":1}}],[\">lockshared\",{\"1\":{\"36\":2}}],[\">setstate\",{\"1\":{\"35\":1}}],[\">schema\",{\"1\":{\"26\":2,\"36\":2}}],[\">outputschema\",{\"1\":{\"26\":3,\"36\":3}}],[\">emplace\",{\"1\":{\"35\":1}}],[\">evaluate\",{\"1\":{\"26\":2,\"36\":2}}],[\">end\",{\"1\":{\"26\":1,\"35\":2,\"36\":1}}],[\">begin\",{\"1\":{\"26\":1,\"35\":2,\"61\":1}}],[\">table\",{\"1\":{\"26\":2,\"36\":1}}],[\">push\",{\"1\":{\"25\":1}}],[\">pin\",{\"1\":{\"11\":1}}],[\">is\",{\"1\":{\"45\":1}}],[\">isexclusivelocked\",{\"1\":{\"35\":1,\"36\":2}}],[\">issharedlocked\",{\"1\":{\"35\":1,\"36\":2}}],[\">isleafpage\",{\"1\":{\"19\":1}}],[\">init\",{\"1\":{\"25\":1}}],[\">wlatch\",{\"1\":{\"20\":1}}],[\">runlatch\",{\"1\":{\"20\":1}}],[\">removeanddeleterecord\",{\"1\":{\"19\":1}}],[\">reset\",{\"1\":{\"11\":1}}],[\">getenum\",{\"1\":{\"45\":1}}],[\">getexclusivelockset\",{\"1\":{\"35\":2}}],[\">get\",{\"1\":{\"45\":1}}],[\">getdescriptor\",{\"1\":{\"45\":1}}],[\">getdata\",{\"1\":{\"16\":2,\"17\":1}}],[\">getreflection\",{\"1\":{\"45\":2}}],[\">getlockmanager\",{\"1\":{\"36\":3}}],[\">getstring\",{\"1\":{\"45\":1}}],[\">getstate\",{\"1\":{\"35\":3}}],[\">getsharedlockset\",{\"1\":{\"35\":3}}],[\">getsize\",{\"1\":{\"19\":1}}],[\">getisolationlevel\",{\"1\":{\"35\":2,\"36\":1}}],[\">getcolumns\",{\"1\":{\"26\":2,\"36\":2}}],[\">getcatalog\",{\"1\":{\"26\":1}}],[\">getprototype\",{\"1\":{\"45\":1}}],[\">getpredicate\",{\"1\":{\"26\":2,\"36\":2}}],[\">getparentpage\",{\"1\":{\"18\":1}}],[\">gettransactionid\",{\"1\":{\"35\":1}}],[\">gettransaction\",{\"1\":{\"26\":1,\"36\":8}}],[\">gettableoid\",{\"1\":{\"26\":1}}],[\">gettable\",{\"1\":{\"26\":1}}],[\">\",{\"1\":{\"11\":5,\"16\":2,\"19\":2,\"20\":2,\"26\":3,\"60\":3,\"61\":1,\"62\":2,\"63\":3,\"64\":3}}],[\">=\",{\"1\":{\"10\":1,\"18\":3,\"19\":1,\"61\":3,\"62\":1,\"63\":1,\"64\":1}}],[\"0\",{\"1\":{\"11\":11,\"16\":2,\"19\":1,\"26\":3,\"40\":1,\"41\":1,\"45\":2,\"56\":8,\"61\":9,\"62\":9,\"63\":19,\"64\":10,\"65\":23}}],[\"<<\",{\"1\":{\"45\":2,\"65\":16}}],[\"<=\",{\"1\":{\"17\":2,\"19\":1,\"62\":1,\"63\":4}}],[\"<typename\",{\"1\":{\"16\":1}}],[\"<\",{\"1\":{\"11\":2,\"18\":2,\"19\":1,\"20\":1,\"45\":1,\"61\":9,\"63\":1,\"65\":1}}],[\"寻找节点尝试合并数据重复的节点\",{\"1\":{\"61\":1}}],[\"寻找包含\",{\"1\":{\"17\":1}}],[\"寻找新的\",{\"1\":{\"11\":1}}],[\"寻找数据页\",{\"1\":{\"11\":1}}],[\"寻找\",{\"1\":{\"11\":1,\"18\":1}}],[\"更改\",{\"1\":{\"24\":1}}],[\"更改都读写磁盘\",{\"1\":{\"5\":1}}],[\"更新了\",{\"1\":{\"33\":1}}],[\"更新数据的一个基本执行单元\",{\"1\":{\"30\":1}}],[\"更新父节点指针\",{\"1\":{\"19\":1}}],[\"更新\",{\"1\":{\"11\":3,\"18\":1,\"20\":1,\"60\":1,\"62\":1}}],[\"+1\",{\"1\":{\"18\":1,\"62\":1,\"63\":1}}],[\"+\",{\"1\":{\"17\":2,\"19\":1,\"36\":28,\"39\":1,\"60\":2,\"61\":1,\"62\":2,\"63\":3,\"65\":5}}],[\"+=\",{\"1\":{\"11\":2,\"60\":3,\"61\":4,\"62\":2,\"63\":2,\"64\":1}}],[\"++\",{\"1\":{\"11\":1,\"26\":2,\"36\":1}}],[\"保证了\",{\"1\":{\"61\":1}}],[\"保证每个序号的字节都交付\",{\"1\":{\"52\":1}}],[\"保证数据库的高可用性\",{\"1\":{\"39\":1}}],[\"保证数据操作的原子性\",{\"1\":{\"5\":1}}],[\"保证前后数据的一致性\",{\"1\":{\"39\":1}}],[\"保证线程安全\",{\"1\":{\"11\":1}}],[\"流程图\",{\"1\":{\"11\":1}}],[\"流程图如下图\",{\"1\":{\"11\":1}}],[\"35\",{\"1\":{\"65\":1}}],[\"39239info\",{\"1\":{\"65\":1}}],[\"39239\",{\"1\":{\"65\":3}}],[\"3000\",{\"1\":{\"65\":10}}],[\"32\",{\"1\":{\"62\":2}}],[\"37731\",{\"1\":{\"56\":1}}],[\"362061406\",{\"1\":{\"37\":1}}],[\"3~11\",{\"1\":{\"22\":1}}],[\"3\",{\"0\":{\"13\":1,\"74\":1,\"78\":1},\"1\":{\"11\":2,\"15\":1,\"18\":1,\"19\":3,\"20\":1,\"27\":1,\"36\":2,\"62\":1,\"64\":2}}],[\"则向客户端发送\",{\"1\":{\"65\":1}}],[\"则不能发送空包\",{\"1\":{\"64\":1}}],[\"则不进行任何发送操作\",{\"1\":{\"63\":1}}],[\"则重新开始定时\",{\"1\":{\"63\":1}}],[\"则重组否则合并\",{\"1\":{\"19\":1}}],[\"则设置报文\",{\"1\":{\"58\":1}}],[\"则释放祖先节点的锁\",{\"1\":{\"20\":1}}],[\"则进入\",{\"1\":{\"19\":1}}],[\"则将\",{\"1\":{\"19\":2}}],[\"则根至少有两个子节点\",{\"1\":{\"15\":1}}],[\"则必须刷回磁盘\",{\"1\":{\"11\":1}}],[\"则证明无人使用该页\",{\"1\":{\"11\":1}}],[\"则刷至磁盘\",{\"1\":{\"11\":3}}],[\"则判断空闲列表是否有空闲页\",{\"1\":{\"11\":1}}],[\"则\",{\"1\":{\"11\":2}}],[\"则直接返回\",{\"1\":{\"10\":1}}],[\"则直接返回页数据\",{\"1\":{\"5\":1}}],[\"以为通过了全部单测就没有问题了\",{\"1\":{\"60\":1}}],[\"以及\",{\"1\":{\"62\":1,\"64\":1}}],[\"以及其它字段\",{\"1\":{\"58\":1}}],[\"以及事务阶段来判断是否授予锁\",{\"1\":{\"35\":1}}],[\"以三次握手为例\",{\"1\":{\"51\":1}}],[\"以我所在的自驾行业为例\",{\"1\":{\"45\":1}}],[\"以确保\",{\"1\":{\"39\":1}}],[\"以全表扫描的\",{\"1\":{\"26\":1}}],[\"以独占锁锁住根节点\",{\"1\":{\"20\":1}}],[\"以共享锁锁住根节点\",{\"1\":{\"20\":1}}],[\"以前为\",{\"1\":{\"19\":1}}],[\"以\",{\"1\":{\"11\":2}}],[\"都应该至少回应一个包\",{\"1\":{\"64\":1}}],[\"都应该\",{\"1\":{\"64\":1}}],[\"都应该忽略\",{\"1\":{\"64\":1}}],[\"都应该准备关闭输入\",{\"1\":{\"64\":1}}],[\"都已经\",{\"1\":{\"63\":1}}],[\"都是\",{\"1\":{\"62\":1}}],[\"都是安全的\",{\"1\":{\"20\":1}}],[\"都需要检查空闲列表\",{\"1\":{\"11\":1}}],[\"都被它垄断\",{\"1\":{\"11\":1}}],[\"都会将页保存在链表头部\",{\"1\":{\"10\":1}}],[\"无数据\",{\"1\":{\"64\":1}}],[\"无需加入\",{\"1\":{\"64\":1}}],[\"无需再次分裂\",{\"1\":{\"18\":1}}],[\"无独有偶\",{\"1\":{\"26\":1}}],[\"无论是客户端还是服务端\",{\"1\":{\"64\":1}}],[\"无论是加锁\",{\"1\":{\"20\":1}}],[\"无论是获取数据页\",{\"1\":{\"11\":1}}],[\"无法将\",{\"1\":{\"5\":1}}],[\"来告诉对端\",{\"1\":{\"64\":1}}],[\"来实时处理\",{\"1\":{\"63\":1}}],[\"来实现wal日志记录\",{\"1\":{\"40\":1}}],[\"来实现\",{\"1\":{\"29\":1,\"60\":2}}],[\"来帮助转换\",{\"1\":{\"62\":1}}],[\"来负责\",{\"1\":{\"58\":1}}],[\"来撤销这些操作\",{\"1\":{\"41\":1}}],[\"来访问\",{\"1\":{\"33\":1}}],[\"来解决这两个问题的\",{\"1\":{\"32\":1}}],[\"来让\",{\"1\":{\"20\":1}}],[\"来获取对应的数据页\",{\"1\":{\"11\":1}}],[\"来表示\",{\"1\":{\"11\":2}}],[\"来教我们如何去弄懂数据库原理\",{\"1\":{\"3\":1}}],[\"叫做帧\",{\"1\":{\"11\":1}}],[\"后才会开启\",{\"1\":{\"63\":1}}],[\"后才有\",{\"1\":{\"62\":1}}],[\"后需要缓存\",{\"1\":{\"62\":1}}],[\"后面再细说\",{\"1\":{\"61\":1}}],[\"后面有用的部分\",{\"1\":{\"61\":1}}],[\"后然后删除\",{\"1\":{\"61\":1}}],[\"后端常用于微服务信息传递\",{\"1\":{\"45\":1}}],[\"后台线程每隔一段时间就会构建出事务之间的依赖图\",{\"1\":{\"35\":1}}],[\"后访问的事务必须等前一个事务执行完成\",{\"1\":{\"31\":1}}],[\"后\",{\"1\":{\"11\":2,\"18\":4,\"19\":1,\"20\":1,\"58\":1,\"61\":1,\"62\":1}}],[\"可通过\",{\"1\":{\"61\":1}}],[\"可能得不到\",{\"1\":{\"58\":1}}],[\"可能会对多个数据页加锁并读取数据\",{\"1\":{\"32\":1}}],[\"可能会出现如下几个问题\",{\"1\":{\"31\":1}}],[\"可能会出现\",{\"1\":{\"19\":1}}],[\"可靠的数据流实现类\",{\"1\":{\"60\":1}}],[\"可靠性是\",{\"1\":{\"52\":1}}],[\"可靠性\",{\"0\":{\"52\":1}}],[\"可靠\",{\"1\":{\"45\":1,\"49\":1}}],[\"可重读读\",{\"1\":{\"36\":1}}],[\"可重复读\",{\"1\":{\"31\":3,\"36\":1}}],[\"可用来表示所有类型的执行计划\",{\"1\":{\"25\":1}}],[\"可直接通过二分查找找到对应的值\",{\"1\":{\"17\":1}}],[\"可以看到\",{\"1\":{\"56\":1}}],[\"可以看到删除操作加锁比查询加锁要复杂的多\",{\"1\":{\"20\":1}}],[\"可以传输无限量的字节\",{\"1\":{\"53\":1}}],[\"可以从故障中恢复\",{\"1\":{\"39\":1}}],[\"可以先加共享锁\",{\"1\":{\"20\":1}}],[\"可以得出\",{\"1\":{\"15\":1}}],[\"可以被淘汰\",{\"1\":{\"11\":1}}],[\"可以用于缓存页数据\",{\"1\":{\"11\":1}}],[\"可是如果你还有疑惑\",{\"1\":{\"3\":1}}],[\"与查询计划一样\",{\"1\":{\"26\":1}}],[\"与其兄弟节点\",{\"1\":{\"19\":2}}],[\"与\",{\"1\":{\"11\":2,\"19\":1,\"58\":1,\"61\":1,\"62\":6}}],[\"与它有关的论文\",{\"1\":{\"3\":1}}],[\"数量\",{\"1\":{\"16\":1}}],[\"数组字段\",{\"1\":{\"16\":1}}],[\"数组是有限的\",{\"1\":{\"11\":1}}],[\"数组中的每一项被称为帧\",{\"1\":{\"11\":1}}],[\"数组\",{\"1\":{\"11\":1}}],[\"数据容器\",{\"1\":{\"61\":1}}],[\"数据流结束后不等待\",{\"1\":{\"64\":1}}],[\"数据流上达到了\",{\"1\":{\"62\":1}}],[\"数据流很快就会溢出\",{\"1\":{\"62\":1}}],[\"数据流是协议最核心的数据载体\",{\"1\":{\"60\":1}}],[\"数据流重组器\",{\"1\":{\"59\":1,\"62\":1}}],[\"数据流\",{\"1\":{\"59\":1}}],[\"数据流开始\",{\"1\":{\"59\":1}}],[\"数据流过程\",{\"1\":{\"58\":1}}],[\"数据包中的\",{\"1\":{\"58\":1}}],[\"数据写\",{\"1\":{\"53\":1}}],[\"数据传输是基于流的\",{\"1\":{\"53\":1}}],[\"数据保存大小\",{\"1\":{\"45\":1}}],[\"数据保存方式\",{\"1\":{\"45\":1}}],[\"数据结构支持\",{\"1\":{\"45\":1}}],[\"数据仍然找回\",{\"1\":{\"39\":1}}],[\"数据等信息\",{\"1\":{\"26\":2}}],[\"数据若要插入到叶子节点\",{\"1\":{\"18\":1}}],[\"数据数组\",{\"1\":{\"16\":1}}],[\"数据是如何转化为叶子结点\",{\"1\":{\"16\":1}}],[\"数据\",{\"1\":{\"16\":1,\"31\":1}}],[\"数据存储在磁盘上被称为页\",{\"1\":{\"11\":1}}],[\"数据记录容器\",{\"1\":{\"25\":1}}],[\"数据记录\",{\"1\":{\"6\":1}}],[\"数据表记录\",{\"1\":{\"29\":1}}],[\"数据表范式\",{\"1\":{\"26\":2}}],[\"数据表迭代器\",{\"1\":{\"6\":1}}],[\"数据表\",{\"1\":{\"6\":1,\"26\":2}}],[\"数据表页\",{\"1\":{\"6\":1}}],[\"数据表定义\",{\"1\":{\"6\":1}}],[\"数据页\",{\"1\":{\"6\":1}}],[\"数据库可以实现多种淘汰算法\",{\"1\":{\"10\":1}}],[\"数据库不可能将所有数据页装在内存中\",{\"1\":{\"10\":1}}],[\"数据库需要在内存中保留尽可能多的数据页\",{\"1\":{\"9\":1}}],[\"数据库目录\",{\"1\":{\"6\":1}}],[\"数据库组开源的一款关系数据库\",{\"1\":{\"3\":1}}],[\"数据库事务隔离级别有哪几个\",{\"1\":{\"3\":1}}],[\"数据库是如何处理并发访问控制的\",{\"1\":{\"3\":1}}],[\"数据库是如何执行\",{\"1\":{\"3\":1}}],[\"数据库是一个老生常谈的话题\",{\"1\":{\"3\":1}}],[\"数据库会预读数据到缓冲池中\",{\"1\":{\"3\":1}}],[\"数据库系统会周期性地检查\",{\"1\":{\"34\":1}}],[\"数据库系统都会为其分配一个事务\",{\"1\":{\"32\":1}}],[\"数据库系统从客户端接收到\",{\"1\":{\"24\":1}}],[\"数据库系统架构是什么样的\",{\"1\":{\"3\":1}}],[\"数据库系统概念\",{\"1\":{\"3\":1}}],[\"置换器\",{\"1\":{\"11\":1}}],[\"页中\",{\"1\":{\"16\":1}}],[\"页类型\",{\"1\":{\"16\":1}}],[\"页表\",{\"1\":{\"11\":1}}],[\"页将其保存在链表头部\",{\"1\":{\"10\":1}}],[\"暂不关注\",{\"1\":{\"11\":1}}],[\"暂时不做延伸\",{\"1\":{\"57\":1}}],[\"暂时并未实现\",{\"1\":{\"5\":1}}],[\"暂时没有\",{\"1\":{\"5\":1}}],[\"ai\",{\"0\":{\"81\":1}}],[\"algorithm\",{\"0\":{\"72\":1,\"73\":1},\"1\":{\"70\":2,\"72\":2,\"73\":1,\"74\":2}}],[\"all\",{\"1\":{\"35\":1,\"64\":1,\"74\":1}}],[\"allocatepage\",{\"1\":{\"11\":1}}],[\"addr\",{\"1\":{\"65\":4}}],[\"address\",{\"1\":{\"65\":2}}],[\"adjustroot\",{\"1\":{\"19\":3}}],[\"after\",{\"1\":{\"64\":7,\"73\":1}}],[\"analysing\",{\"1\":{\"72\":1}}],[\"any\",{\"1\":{\"64\":1}}],[\"an\",{\"1\":{\"62\":1,\"64\":3,\"73\":1}}],[\"and\",{\"1\":{\"16\":1,\"35\":2,\"62\":1,\"64\":7,\"65\":1,\"70\":2,\"73\":4,\"74\":2}}],[\"ask\",{\"1\":{\"70\":1}}],[\"as\",{\"1\":{\"62\":1,\"63\":1,\"73\":1}}],[\"assembled\",{\"1\":{\"64\":1}}],[\"assembling\",{\"1\":{\"62\":1}}],[\"assign\",{\"1\":{\"60\":2}}],[\"accomlish\",{\"1\":{\"70\":1}}],[\"accomplish\",{\"1\":{\"70\":1,\"72\":1,\"73\":1,\"74\":1}}],[\"accept\",{\"1\":{\"65\":1}}],[\"active\",{\"1\":{\"64\":10}}],[\"acks\",{\"1\":{\"64\":1}}],[\"acking\",{\"1\":{\"64\":1}}],[\"acknowledged\",{\"1\":{\"64\":1,\"65\":2}}],[\"ackno\",{\"1\":{\"58\":3,\"59\":1,\"62\":20,\"63\":21,\"64\":11,\"65\":2}}],[\"ack\",{\"1\":{\"51\":2,\"58\":1,\"62\":1,\"63\":3,\"64\":16,\"65\":16}}],[\"acid特性\",{\"1\":{\"30\":1}}],[\"apps\",{\"1\":{\"65\":3}}],[\"application\",{\"1\":{\"64\":1}}],[\"append\",{\"1\":{\"60\":1}}],[\"appendlogrecord\",{\"1\":{\"40\":1}}],[\"api\",{\"0\":{\"56\":1},\"1\":{\"16\":1,\"18\":1,\"19\":1,\"56\":4,\"65\":1}}],[\"about\",{\"1\":{\"64\":1}}],[\"abortreason\",{\"1\":{\"35\":3}}],[\"abortimplicitly\",{\"1\":{\"35\":3}}],[\"abort\",{\"1\":{\"35\":6,\"64\":1}}],[\"aborts\",{\"1\":{\"35\":1}}],[\"aborted\",{\"1\":{\"32\":1,\"35\":3}}],[\"abs\",{\"1\":{\"62\":24,\"63\":15}}],[\"absolute\",{\"1\":{\"62\":3,\"63\":1}}],[\"abstractexecutor\",{\"1\":{\"26\":7}}],[\"abstractexpression\",{\"1\":{\"26\":3}}],[\"abstractplannode\",{\"1\":{\"25\":2,\"26\":9}}],[\"at\",{\"1\":{\"64\":1}}],[\"attempts\",{\"1\":{\"64\":3}}],[\"attributes\",{\"1\":{\"16\":1}}],[\"attribute\",{\"1\":{\"11\":2,\"16\":6}}],[\"atomicity\",{\"1\":{\"30\":1}}],[\"age\",{\"1\":{\"34\":1}}],[\"aggregation\",{\"1\":{\"26\":1}}],[\"agile\",{\"1\":{\"0\":1}}],[\"auto\",{\"1\":{\"25\":1,\"35\":6,\"61\":3,\"64\":1}}],[\"a1\",{\"1\":{\"18\":4}}],[\"a\",{\"1\":{\"18\":13,\"19\":22,\"20\":7,\"26\":1,\"31\":5,\"33\":6,\"35\":2,\"61\":7,\"62\":1,\"63\":1,\"64\":2,\"65\":2}}],[\"arp\",{\"1\":{\"66\":1}}],[\"argv\",{\"1\":{\"65\":2}}],[\"argc\",{\"1\":{\"65\":2}}],[\"arguments\",{\"1\":{\"16\":2}}],[\"are\",{\"1\":{\"36\":1}}],[\"array\",{\"1\":{\"16\":3,\"17\":2}}],[\"表\",{\"1\":{\"31\":1}}],[\"表迭代器\",{\"1\":{\"26\":1}}],[\"表示需要等待\",{\"1\":{\"64\":1}}],[\"表示输出流已经完全被对端接收且确认\",{\"1\":{\"64\":1}}],[\"表示输入流结束\",{\"1\":{\"64\":1}}],[\"表示字节在数据流中的序号\",{\"1\":{\"62\":1}}],[\"表示\",{\"1\":{\"62\":2}}],[\"表示该数据流不能存储超过容量的字节数\",{\"1\":{\"60\":1}}],[\"表示全表扫描查询计划\",{\"1\":{\"26\":1}}],[\"表示内部节点中值上存储页\",{\"1\":{\"16\":1}}],[\"表示树中的每个节点最多只能有\",{\"1\":{\"15\":1}}],[\"表示当前缓存池还有多少帧是空闲的\",{\"1\":{\"11\":1}}],[\"表示是否脏页\",{\"1\":{\"11\":1}}],[\"表数据\",{\"1\":{\"11\":1}}],[\"given\",{\"1\":{\"74\":1}}],[\"github\",{\"1\":{\"3\":1}}],[\"gbit\",{\"1\":{\"65\":2}}],[\"g\",{\"1\":{\"65\":1}}],[\"gnss等\",{\"1\":{\"45\":1}}],[\"google\",{\"1\":{\"45\":16}}],[\"graph\",{\"1\":{\"35\":1}}],[\"granted\",{\"1\":{\"35\":2}}],[\"growing\",{\"1\":{\"32\":2}}],[\"generated\",{\"1\":{\"45\":2}}],[\"genericcomparator<8>\",{\"1\":{\"16\":1}}],[\"genericcomparator<8>>\",{\"1\":{\"16\":1}}],[\"generickey<8>\",{\"1\":{\"16\":1}}],[\"getdescriptor\",{\"1\":{\"45\":1}}],[\"getdata\",{\"1\":{\"18\":4,\"19\":1}}],[\"get\",{\"1\":{\"45\":1,\"69\":1}}],[\"getlogbuffer\",{\"1\":{\"40\":1}}],[\"getnextlsn\",{\"1\":{\"40\":1}}],[\"getreflection\",{\"1\":{\"45\":1}}],[\"getrid\",{\"1\":{\"26\":1,\"36\":8}}],[\"getrootpage\",{\"1\":{\"20\":1}}],[\"getexpr\",{\"1\":{\"26\":1,\"36\":1}}],[\"getexecutorcontext\",{\"1\":{\"26\":1}}],[\"getas<bool>\",{\"1\":{\"26\":1,\"36\":1}}],[\"getoutputschema\",{\"1\":{\"26\":1}}],[\"gettransaction\",{\"1\":{\"35\":2}}],[\"gettableoid\",{\"1\":{\"26\":1}}],[\"gettype\",{\"1\":{\"26\":1}}],[\"getmaxsize\",{\"1\":{\"19\":1}}],[\"getminsize\",{\"1\":{\"19\":1}}],[\"getsize\",{\"1\":{\"17\":1,\"19\":4}}],[\"getvalue\",{\"1\":{\"17\":3}}],[\"getpersistentlsn\",{\"1\":{\"40\":1}}],[\"getpredicate\",{\"1\":{\"26\":1}}],[\"getpageid\",{\"1\":{\"18\":2}}],[\"getpages\",{\"1\":{\"11\":1}}],[\"getpoolsize\",{\"1\":{\"11\":1}}],[\"类图如下\",{\"1\":{\"58\":1}}],[\"类定义如下\",{\"1\":{\"40\":1,\"63\":1}}],[\"类有两个重要字段\",{\"1\":{\"26\":1}}],[\"类实例来执行查询计划\",{\"1\":{\"25\":1}}],[\"类中定义一把锁\",{\"1\":{\"20\":1}}],[\"类是对数据页的代码抽象\",{\"1\":{\"16\":1}}],[\"类的值类型为\",{\"1\":{\"16\":1}}],[\"类型来生成对应的执行器\",{\"1\":{\"25\":1}}],[\"类型\",{\"1\":{\"16\":2,\"45\":1,\"62\":1}}],[\"类似\",{\"1\":{\"11\":1}}],[\"类\",{\"1\":{\"11\":1,\"16\":1}}],[\"类别众多\",{\"1\":{\"3\":1}}],[\"元数据重置\",{\"1\":{\"11\":1}}],[\"元数据\",{\"1\":{\"11\":1}}],[\"元数据页\",{\"1\":{\"6\":1}}],[\"删除已经合并的头节点\",{\"1\":{\"61\":1}}],[\"删除等\",{\"1\":{\"24\":1}}],[\"删除流程图如图\",{\"1\":{\"19\":1}}],[\"删除根节点\",{\"1\":{\"19\":1}}],[\"删除时\",{\"1\":{\"19\":1}}],[\"删除失败\",{\"1\":{\"19\":1}}],[\"删除对应的\",{\"1\":{\"19\":1}}],[\"删除的复杂性大大高于插入\",{\"1\":{\"19\":1}}],[\"删除引发了两次节点合并\",{\"1\":{\"19\":1}}],[\"删除引发了节点重组\",{\"1\":{\"19\":1}}],[\"删除指向\",{\"1\":{\"19\":1}}],[\"删除一个子节点后\",{\"1\":{\"19\":1}}],[\"删除节点\",{\"1\":{\"19\":1}}],[\"删除后\",{\"1\":{\"19\":4,\"20\":2}}],[\"删除\",{\"1\":{\"11\":1,\"16\":1,\"19\":1,\"20\":2}}],[\"删除数据页\",{\"1\":{\"11\":2}}],[\"删除尾部\",{\"1\":{\"10\":1}}],[\"删除这个节点\",{\"1\":{\"10\":1}}],[\"=2\",{\"1\":{\"63\":1}}],[\"==\",{\"1\":{\"11\":2,\"19\":2,\"20\":2,\"26\":1,\"35\":5,\"36\":1,\"61\":4,\"63\":2,\"64\":4,\"65\":1}}],[\"=>\",{\"1\":{\"11\":1}}],[\"=\",{\"1\":{\"10\":4,\"11\":16,\"16\":7,\"17\":11,\"18\":12,\"19\":7,\"20\":4,\"25\":2,\"26\":12,\"35\":5,\"36\":7,\"40\":5,\"41\":2,\"45\":19,\"60\":7,\"61\":22,\"62\":18,\"63\":27,\"64\":17,\"65\":6}}],[\"加上事务隔离级别的判断\",{\"1\":{\"36\":1}}],[\"加入后等待\",{\"1\":{\"35\":1}}],[\"加入到节点头部\",{\"1\":{\"19\":1}}],[\"加入到空闲列表\",{\"1\":{\"11\":1}}],[\"加入到\",{\"1\":{\"10\":1,\"11\":1}}],[\"加读锁\",{\"1\":{\"20\":1}}],[\"加独占锁\",{\"1\":{\"20\":5}}],[\"加共享锁\",{\"1\":{\"20\":1}}],[\"加锁后\",{\"1\":{\"33\":1}}],[\"加锁\",{\"1\":{\"10\":3,\"11\":3,\"20\":1,\"33\":2}}],[\"将此作为无约束问题进行求解\",{\"1\":{\"77\":1}}],[\"将约束条件乘上惩罚系数与原函数相加\",{\"1\":{\"77\":1}}],[\"将理论知识巧妙和实践结合\",{\"1\":{\"66\":1}}],[\"将报文推入到其队列后\",{\"1\":{\"64\":1}}],[\"将报文传递给\",{\"1\":{\"64\":1}}],[\"将报文交给\",{\"1\":{\"58\":2}}],[\"将输入\",{\"1\":{\"64\":1}}],[\"将已经确认的报文推出队列\",{\"1\":{\"63\":1}}],[\"将重新发送\",{\"1\":{\"63\":1}}],[\"将重组这部分工作抽象为数据流重组器\",{\"1\":{\"61\":1}}],[\"将其中被确认的报文推出队列\",{\"1\":{\"63\":1}}],[\"将其打包为数据报\",{\"1\":{\"58\":1}}],[\"将新的连续的字节写入到流中\",{\"1\":{\"61\":1}}],[\"将字节按照序号进行重组得到正确的字节流\",{\"1\":{\"58\":1}}],[\"将撤消操作记录到日志中以确保操作不会在重复失败的情况下重复执行\",{\"1\":{\"39\":1}}],[\"将数据库恢复到某个失败后的状态\",{\"1\":{\"39\":1}}],[\"将数据页刷至磁盘\",{\"1\":{\"11\":1}}],[\"将事务\",{\"1\":{\"35\":1}}],[\"将表字段数据\",{\"1\":{\"26\":1}}],[\"将根节点数据视为叶子节点\",{\"1\":{\"18\":1}}],[\"将缓存中所有页到刷到磁盘\",{\"1\":{\"11\":1}}],[\"将页刷到磁盘\",{\"1\":{\"11\":1}}],[\"将\",{\"1\":{\"10\":1,\"17\":1,\"18\":1,\"19\":2,\"61\":1,\"63\":1}}],[\"将一个页加入\",{\"1\":{\"10\":1}}],[\"||\",{\"1\":{\"10\":1,\"35\":2,\"61\":1,\"62\":1,\"63\":1,\"64\":1}}],[\"约束包括等式约束和不等式约束两部分\",{\"1\":{\"76\":1}}],[\"约束\",{\"1\":{\"10\":1}}],[\"故不能合并\",{\"1\":{\"19\":1}}],[\"故每个函数操作都需加锁\",{\"1\":{\"10\":1}}],[\"故障恢复\",{\"1\":{\"6\":1}}],[\"故障恢复模块\",{\"1\":{\"6\":1}}],[\"也应该调用\",{\"1\":{\"64\":1}}],[\"也无需确认\",{\"1\":{\"64\":1}}],[\"也无法满足半满性质\",{\"1\":{\"19\":1}}],[\"也懒得重构\",{\"1\":{\"62\":1}}],[\"也伴随着数据\",{\"1\":{\"62\":1}}],[\"也没有\",{\"1\":{\"62\":1}}],[\"也没有加写锁\",{\"1\":{\"36\":1}}],[\"也使功能迭代和完善更加方便\",{\"1\":{\"58\":1}}],[\"也就是本文后面所实现的\",{\"1\":{\"57\":1}}],[\"也广泛用于自动驾驶场景中\",{\"1\":{\"45\":1}}],[\"也可理解为查询条件\",{\"1\":{\"26\":1}}],[\"也可以使用\",{\"1\":{\"60\":1}}],[\"也可以建立在\",{\"1\":{\"57\":1}}],[\"也可以是\",{\"1\":{\"54\":1}}],[\"也可以通过\",{\"1\":{\"32\":1}}],[\"也可以看作索引的名称\",{\"1\":{\"16\":1}}],[\"也可以作为叶子节点\",{\"1\":{\"15\":1}}],[\"也不能升级\",{\"1\":{\"32\":1}}],[\"也不安全\",{\"1\":{\"20\":1}}],[\"也不满足半满的性质\",{\"1\":{\"19\":1}}],[\"也不复杂\",{\"1\":{\"10\":1}}],[\"也作为\",{\"1\":{\"18\":1}}],[\"也必须分裂\",{\"1\":{\"18\":1}}],[\"也谈到了\",{\"1\":{\"18\":1}}],[\"也有\",{\"1\":{\"15\":1}}],[\"也是一个基于字节流的网络协议\",{\"1\":{\"60\":1}}],[\"也是必须的\",{\"1\":{\"11\":1}}],[\"也是数据设计的主要目标\",{\"1\":{\"9\":1}}],[\"也会从磁盘中读取数据页到内存\",{\"1\":{\"11\":1}}],[\"也会调用\",{\"1\":{\"10\":1}}],[\"哈希表\",{\"1\":{\"10\":1}}],[\"n\",{\"1\":{\"65\":2}}],[\"n2\",{\"1\":{\"61\":1}}],[\"n1\",{\"1\":{\"61\":1}}],[\"nmap\",{\"1\":{\"56\":1}}],[\"ncat\",{\"1\":{\"56\":6}}],[\"nc\",{\"1\":{\"56\":4}}],[\"nullopt\",{\"1\":{\"62\":2,\"63\":2}}],[\"nullptr\",{\"1\":{\"25\":1,\"26\":1,\"36\":2,\"40\":2,\"41\":1}}],[\"null\",{\"1\":{\"17\":2}}],[\"numbers\",{\"1\":{\"64\":1}}],[\"number\",{\"1\":{\"16\":1,\"34\":1,\"61\":1,\"62\":2,\"63\":3,\"64\":1}}],[\"num\",{\"1\":{\"10\":2}}],[\"non\",{\"1\":{\"31\":1}}],[\"no\",{\"1\":{\"19\":1,\"39\":1}}],[\"node\",{\"1\":{\"16\":2,\"17\":2,\"18\":33,\"19\":42,\"20\":4,\"61\":9}}],[\"notify\",{\"1\":{\"35\":1}}],[\"not\",{\"1\":{\"11\":3,\"17\":1,\"35\":1,\"63\":1}}],[\"name就是具体字段名\",{\"1\":{\"45\":1}}],[\"name\",{\"1\":{\"16\":2,\"45\":3}}],[\"network\",{\"0\":{\"82\":1}}],[\"networking\",{\"1\":{\"67\":1}}],[\"needs\",{\"1\":{\"64\":1}}],[\"necessary\",{\"1\":{\"64\":1}}],[\"nested\",{\"1\":{\"26\":2}}],[\"next\",{\"1\":{\"25\":5,\"26\":6,\"36\":2,\"40\":2,\"61\":14,\"63\":9,\"64\":1}}],[\"neighbor\",{\"1\":{\"19\":8}}],[\"newrootnode\",{\"1\":{\"19\":1}}],[\"new\",{\"1\":{\"18\":18,\"19\":2,\"40\":2,\"41\":1,\"65\":1,\"72\":1}}],[\"newpage\",{\"1\":{\"11\":3,\"18\":2}}],[\"newpageimpl\",{\"1\":{\"11\":2}}],[\"neo4j\",{\"1\":{\"3\":1}}],[\"udpsocket\",{\"1\":{\"65\":5}}],[\"udp\",{\"1\":{\"57\":2,\"58\":4,\"65\":8}}],[\"uint16\",{\"1\":{\"63\":1}}],[\"uint64\",{\"1\":{\"45\":3,\"62\":4,\"63\":4}}],[\"uint32\",{\"1\":{\"45\":3}}],[\"upper\",{\"1\":{\"64\":1}}],[\"up\",{\"1\":{\"35\":1}}],[\"update\",{\"1\":{\"26\":1,\"64\":1}}],[\"updaterootpageid\",{\"1\":{\"19\":1}}],[\"user\",{\"0\":{\"72\":1},\"1\":{\"70\":1,\"72\":3,\"73\":4}}],[\"use\",{\"1\":{\"62\":1}}],[\"used\",{\"1\":{\"10\":1}}],[\"using\",{\"1\":{\"16\":2}}],[\"until\",{\"1\":{\"65\":2}}],[\"unclean\",{\"1\":{\"64\":5}}],[\"uncommitted\",{\"1\":{\"35\":2,\"36\":1}}],[\"unsigned\",{\"1\":{\"63\":4}}],[\"unacceptable\",{\"1\":{\"62\":1}}],[\"unassembled\",{\"1\":{\"61\":4,\"62\":1}}],[\"unwrap\",{\"1\":{\"62\":1,\"63\":2}}],[\"undo\",{\"1\":{\"41\":3}}],[\"unlock\",{\"1\":{\"35\":2}}],[\"unique\",{\"1\":{\"35\":3}}],[\"unique<tableiterator>\",{\"1\":{\"26\":1}}],[\"unused\",{\"1\":{\"11\":2,\"16\":6}}],[\"unordered\",{\"1\":{\"10\":1,\"11\":1,\"35\":1}}],[\"unpinpage\",{\"1\":{\"11\":4,\"17\":1}}],[\"unpinpageimpl\",{\"1\":{\"11\":2}}],[\"unpin\",{\"1\":{\"10\":3,\"11\":3,\"17\":1}}],[\"ve\",{\"1\":{\"64\":1}}],[\"version\",{\"1\":{\"56\":1}}],[\"vector<value>\",{\"1\":{\"26\":1,\"36\":1}}],[\"vector<const\",{\"1\":{\"26\":2}}],[\"vector<tuple>\",{\"1\":{\"25\":1}}],[\"vectorized\",{\"1\":{\"25\":1}}],[\"val\",{\"1\":{\"17\":2}}],[\"values\",{\"1\":{\"26\":4,\"36\":4}}],[\"value\",{\"1\":{\"16\":2,\"17\":2,\"18\":7,\"26\":1,\"45\":6,\"62\":3,\"63\":5,\"64\":3}}],[\"valuetype>\",{\"1\":{\"16\":1}}],[\"valuetype\",{\"1\":{\"16\":5,\"17\":1,\"45\":2}}],[\"variable\",{\"1\":{\"16\":1,\"64\":1}}],[\"v\",{\"1\":{\"16\":5,\"56\":1}}],[\"void\",{\"1\":{\"10\":4,\"11\":2,\"18\":2,\"19\":5,\"26\":2,\"35\":1,\"40\":4,\"41\":2,\"60\":1,\"61\":2,\"62\":1,\"63\":3,\"64\":6,\"65\":3}}],[\"visited\",{\"1\":{\"73\":1}}],[\"virtual\",{\"1\":{\"26\":5}}],[\"victim\",{\"1\":{\"10\":2,\"11\":2}}],[\"viable\",{\"1\":{\"0\":1}}],[\"返回当前接受者的窗口大小\",{\"1\":{\"62\":1}}],[\"返回确认序号\",{\"1\":{\"62\":1}}],[\"返回\",{\"1\":{\"10\":1,\"11\":3,\"26\":2}}],[\"当客户端数据全部发送完毕\",{\"1\":{\"65\":1}}],[\"当输入流关闭\",{\"1\":{\"64\":1}}],[\"当窗口没有满\",{\"1\":{\"63\":1}}],[\"当作\",{\"1\":{\"63\":1}}],[\"当收到\",{\"1\":{\"61\":1}}],[\"当\",{\"1\":{\"61\":1,\"64\":1}}],[\"当一个报文数据被推入到重组器后\",{\"1\":{\"61\":1}}],[\"当调用\",{\"1\":{\"35\":1}}],[\"当系统检测到死锁时\",{\"1\":{\"34\":1}}],[\"当事务之间存在数据依赖\",{\"1\":{\"34\":1}}],[\"当所以合并操作完成后\",{\"1\":{\"20\":1}}],[\"当更新\",{\"1\":{\"20\":1}}],[\"当寻找一个\",{\"1\":{\"20\":1}}],[\"当有人拿到数据页\",{\"1\":{\"11\":1}}],[\"当页被淘汰\",{\"1\":{\"11\":1}}],[\"当然这涉及到\",{\"1\":{\"53\":1}}],[\"当然这个过程中还伴随着索引\",{\"1\":{\"5\":1}}],[\"当然也涉及到初始化序号\",{\"1\":{\"51\":1}}],[\"当然也有例外\",{\"1\":{\"15\":1}}],[\"当然\",{\"1\":{\"26\":1,\"57\":1,\"66\":1}}],[\"当然其数据本身还是由\",{\"1\":{\"11\":1}}],[\"当前发送队列\",{\"1\":{\"64\":1}}],[\"当前的\",{\"1\":{\"63\":1}}],[\"当前的重试时间\",{\"1\":{\"63\":1}}],[\"当前已组装的字节序号\",{\"1\":{\"61\":1}}],[\"当前序号\",{\"1\":{\"61\":1}}],[\"当前查询事务\",{\"1\":{\"25\":1}}],[\"当前\",{\"1\":{\"10\":1,\"61\":1}}],[\"当缓存池满了需要淘汰时\",{\"1\":{\"10\":1}}],[\"由服务器发送\",{\"1\":{\"65\":1}}],[\"由操作系统实现在了内核态\",{\"1\":{\"56\":1}}],[\"由事务\",{\"1\":{\"32\":1}}],[\"由于网络延迟\",{\"1\":{\"61\":1}}],[\"由于\",{\"1\":{\"17\":1,\"61\":3}}],[\"由于操作系统\",{\"1\":{\"16\":1}}],[\"由于每次访问或者新增页时\",{\"1\":{\"10\":1}}],[\"由\",{\"1\":{\"11\":1,\"54\":1,\"58\":1}}],[\"由磁盘管理器和宿主机操作系统共同完成\",{\"1\":{\"5\":1}}],[\"从原理到实战\",{\"1\":{\"67\":1}}],[\"从终端输出中可以看到\",{\"1\":{\"65\":1}}],[\"从中来看看三次握手是如何发生的\",{\"1\":{\"65\":1}}],[\"从输出流中读取数据并包装为报文\",{\"1\":{\"63\":1}}],[\"从这个图中可以总结出\",{\"1\":{\"58\":1}}],[\"从而动态获取或修改单个字段\",{\"1\":{\"45\":1}}],[\"从而可能引发父节点再次分裂\",{\"1\":{\"18\":1}}],[\"从根节点\",{\"1\":{\"20\":2}}],[\"从树级别下降到了页级别\",{\"1\":{\"20\":1}}],[\"从叶子结点上寻找值\",{\"1\":{\"17\":1}}],[\"从伪代码中\",{\"1\":{\"11\":1}}],[\"从空闲列表中拿到\",{\"1\":{\"11\":1}}],[\"从空闲列表中获取\",{\"1\":{\"11\":1}}],[\"从磁盘中读取\",{\"1\":{\"11\":1}}],[\"从磁盘中读取页数据并缓存在内存中\",{\"1\":{\"5\":1}}],[\"从缓存中删除一个页\",{\"1\":{\"11\":1}}],[\"从\",{\"1\":{\"10\":1,\"11\":1,\"19\":1,\"58\":2,\"62\":2,\"64\":2}}],[\"从链表尾部得到淘汰页\",{\"1\":{\"10\":1}}],[\"新建\",{\"1\":{\"18\":1,\"65\":1}}],[\"新建数据页\",{\"1\":{\"11\":2}}],[\"新建一个页\",{\"1\":{\"11\":1}}],[\"新访问\",{\"1\":{\"10\":1}}],[\"新增\",{\"1\":{\"10\":1}}],[\"选择合适的数据结构就能解决这个问题\",{\"1\":{\"10\":1}}],[\"然后干净地关闭连接\",{\"1\":{\"65\":2}}],[\"然后向\",{\"1\":{\"65\":1}}],[\"然后适配到\",{\"1\":{\"65\":1}}],[\"然后新建客户端连接\",{\"1\":{\"65\":1}}],[\"然后从\",{\"1\":{\"65\":1}}],[\"然后从磁盘上读取新的数据页\",{\"1\":{\"10\":1}}],[\"然后通过\",{\"1\":{\"65\":1}}],[\"然后通过谓词判断记录是否符合查询条件\",{\"1\":{\"26\":1}}],[\"然后设置\",{\"1\":{\"64\":2}}],[\"然后判断重试次数\",{\"1\":{\"64\":1}}],[\"然后判断事务之间是否存在循环依赖\",{\"1\":{\"35\":1}}],[\"然后再\",{\"1\":{\"64\":1}}],[\"然后再更改\",{\"1\":{\"33\":1}}],[\"然后发送报文\",{\"1\":{\"63\":1}}],[\"然后尝试去合并二者\",{\"1\":{\"61\":1}}],[\"然后更新\",{\"1\":{\"60\":1}}],[\"然后将数据加入到\",{\"1\":{\"60\":1}}],[\"然后将页数据视为叶子\",{\"1\":{\"18\":1}}],[\"然后在另一个窗口中连接该端口\",{\"1\":{\"56\":1}}],[\"然后在判断子节点安全后\",{\"1\":{\"20\":1}}],[\"然后\",{\"1\":{\"31\":2}}],[\"然后初始化该执行器\",{\"1\":{\"25\":1}}],[\"然后获取节点\",{\"1\":{\"20\":4}}],[\"然后升级为独占锁\",{\"1\":{\"20\":1}}],[\"然后移动另外一条\",{\"1\":{\"20\":1}}],[\"然后删除旧的根节点\",{\"1\":{\"19\":1}}],[\"然后调用\",{\"1\":{\"17\":1,\"41\":1}}],[\"然后以事务的方式请求缓存管理器获取数据页\",{\"1\":{\"5\":1}}],[\"算法会选择最近最少使用的页淘汰\",{\"1\":{\"10\":1}}],[\"算法\",{\"1\":{\"10\":1}}],[\"算法实现\",{\"1\":{\"6\":1}}],[\"和窗口大小\",{\"1\":{\"63\":1}}],[\"和加锁模式加入到队列\",{\"1\":{\"35\":1}}],[\"和\",{\"1\":{\"10\":1,\"11\":2,\"16\":7,\"18\":4,\"26\":1,\"29\":1,\"51\":1,\"56\":1,\"57\":1,\"58\":2,\"60\":2,\"61\":2,\"62\":3,\"63\":1,\"64\":4}}],[\"和精益创业\",{\"1\":{\"0\":1}}],[\"function\",{\"1\":{\"72\":2}}],[\"fully\",{\"1\":{\"64\":3,\"65\":2}}],[\"full\",{\"1\":{\"49\":1,\"70\":1,\"72\":1}}],[\"fdadapterconfig\",{\"1\":{\"65\":2}}],[\"fsm\",{\"1\":{\"65\":4}}],[\"flag\",{\"1\":{\"64\":2}}],[\"flight\",{\"1\":{\"63\":19,\"64\":3,\"65\":2}}],[\"float\",{\"1\":{\"45\":3}}],[\"flush\",{\"1\":{\"40\":4}}],[\"flushallpages\",{\"1\":{\"11\":1}}],[\"flushallpagesimpl\",{\"1\":{\"11\":2}}],[\"flushpage\",{\"1\":{\"11\":4}}],[\"flushpageimpl\",{\"1\":{\"11\":2}}],[\"failure\",{\"1\":{\"65\":2}}],[\"fact\",{\"1\":{\"64\":1,\"74\":1}}],[\"factory\",{\"1\":{\"26\":1,\"45\":1}}],[\"fall\",{\"1\":{\"67\":1}}],[\"fall2020\",{\"1\":{\"7\":1}}],[\"false\",{\"1\":{\"10\":1,\"11\":10,\"18\":1,\"26\":2,\"35\":3,\"36\":3,\"62\":1,\"63\":2,\"64\":13,\"65\":5}}],[\"f\",{\"1\":{\"19\":3}}],[\"force\",{\"1\":{\"39\":1,\"40\":1}}],[\"for\",{\"1\":{\"11\":1,\"34\":2,\"35\":7,\"45\":1,\"62\":1,\"63\":3,\"64\":1,\"65\":6,\"70\":1,\"72\":1,\"73\":1,\"74\":2}}],[\"fixed\",{\"1\":{\"64\":1}}],[\"finished\",{\"1\":{\"65\":6}}],[\"finish\",{\"1\":{\"64\":6}}],[\"fin\",{\"1\":{\"61\":2,\"62\":22,\"63\":12,\"64\":3,\"65\":1}}],[\"findsiblingnode\",{\"1\":{\"19\":1}}],[\"findparentnode\",{\"1\":{\"19\":1}}],[\"findleafpagebyoperation\",{\"1\":{\"20\":1}}],[\"findleafpage\",{\"1\":{\"17\":3,\"18\":1,\"19\":1}}],[\"findxxx\",{\"1\":{\"16\":1}}],[\"find\",{\"1\":{\"11\":4,\"72\":1}}],[\"filt\",{\"1\":{\"65\":7}}],[\"filling\",{\"1\":{\"63\":1}}],[\"fill\",{\"1\":{\"58\":1,\"63\":2,\"64\":1}}],[\"filed\",{\"1\":{\"45\":2}}],[\"field\",{\"1\":{\"45\":28}}],[\"fielddescriptor\",{\"1\":{\"45\":5}}],[\"firstly\",{\"1\":{\"72\":2,\"73\":1}}],[\"first\",{\"1\":{\"18\":1,\"62\":7,\"63\":3,\"65\":4}}],[\"firstkey\",{\"1\":{\"18\":3}}],[\"fifo\",{\"1\":{\"10\":1}}],[\"fetchpage\",{\"1\":{\"11\":10,\"17\":1}}],[\"fetchpageimpl\",{\"1\":{\"11\":2}}],[\"from\",{\"1\":{\"56\":2,\"65\":16,\"73\":2}}],[\"front\",{\"1\":{\"10\":3,\"11\":2,\"63\":7,\"64\":1}}],[\"free\",{\"1\":{\"11\":22}}],[\"frame\",{\"1\":{\"10\":23,\"11\":30}}],[\"相比于sgd可以显著提高收敛速度\",{\"1\":{\"78\":1}}],[\"相对于传统的csv\",{\"1\":{\"45\":1}}],[\"相较于\",{\"1\":{\"63\":1}}],[\"相较于查询\",{\"1\":{\"18\":1}}],[\"相较于磁盘而言\",{\"1\":{\"10\":1}}],[\"相信你能从中自己发掘出答案\",{\"1\":{\"3\":1}}],[\"淘汰\",{\"1\":{\"11\":1}}],[\"淘汰一个页\",{\"1\":{\"10\":1}}],[\"淘汰策略中删除一个页\",{\"1\":{\"10\":1}}],[\"淘汰策略\",{\"0\":{\"10\":1},\"1\":{\"10\":1}}],[\"淘汰算法lru\",{\"1\":{\"6\":1}}],[\"但必须发送一个空包\",{\"1\":{\"64\":1}}],[\"但必须包含\",{\"1\":{\"62\":1}}],[\"但也是最容易忽略的一部分\",{\"1\":{\"60\":1}}],[\"但也导致了单位时间内只有一个线程能够访问该索引\",{\"1\":{\"20\":1}}],[\"但仍然不能保证完美的可靠性\",{\"1\":{\"52\":1}}],[\"但却是值得的\",{\"1\":{\"52\":1}}],[\"但却没有理解\",{\"1\":{\"49\":1}}],[\"但很显然\",{\"1\":{\"36\":1}}],[\"但二阶段事务却有\",{\"1\":{\"32\":1}}],[\"但同样的\",{\"1\":{\"31\":1}}],[\"但如果是多线程\",{\"1\":{\"20\":1}}],[\"但不可能只保存键值对\",{\"1\":{\"16\":1}}],[\"但不可能将所有页都保存在内存中\",{\"1\":{\"9\":1}}],[\"但是可能对端没有完全确认\",{\"1\":{\"64\":1}}],[\"但是本端可能没有数据回复\",{\"1\":{\"64\":1}}],[\"但是本文的重点聚焦在\",{\"1\":{\"49\":1}}],[\"但是如果提前判读包的大小\",{\"1\":{\"63\":1}}],[\"但是前提是内部已经关闭\",{\"1\":{\"62\":1}}],[\"但是不能包括\",{\"1\":{\"62\":1}}],[\"但是在后面的测试中\",{\"1\":{\"60\":1}}],[\"但是一些复杂的特性暂时不支持\",{\"1\":{\"57\":1}}],[\"但是这不影响我们以此来学习一个简单可靠的类\",{\"1\":{\"57\":1}}],[\"但是却屏蔽了大量信息\",{\"1\":{\"56\":1}}],[\"但是普遍集中在\",{\"1\":{\"49\":1}}],[\"但是整体运行效率也越低\",{\"1\":{\"31\":1}}],[\"但是数据库还有更加重要的数据部分\",{\"1\":{\"29\":1}}],[\"但是付出是值得的\",{\"1\":{\"21\":1}}],[\"但是删除元素\",{\"1\":{\"20\":1}}],[\"但是\",{\"1\":{\"19\":1,\"20\":1,\"53\":1,\"62\":1}}],[\"但是对于叶子结点\",{\"1\":{\"15\":1}}],[\"但是被加载到内存\",{\"1\":{\"11\":1}}],[\"但是由于涉及到课程实验作业\",{\"1\":{\"3\":1}}],[\"但是大部分书籍和博文都在教开发者如何去使用一款数据库\",{\"1\":{\"3\":1}}],[\"最重要的函数\",{\"1\":{\"61\":1}}],[\"最重要的关系数据库\",{\"1\":{\"3\":1}}],[\"最终会实现一个全栈的网络协议栈\",{\"1\":{\"49\":1}}],[\"最后\",{\"1\":{\"66\":1}}],[\"最后报文接受到现在时间间隔\",{\"1\":{\"64\":1}}],[\"最后一个\",{\"1\":{\"63\":1}}],[\"最后访问\",{\"1\":{\"33\":1}}],[\"最后找到\",{\"1\":{\"20\":1}}],[\"最后重置页数据\",{\"1\":{\"11\":1}}],[\"最少只需要两个节点\",{\"1\":{\"19\":1}}],[\"最少要拥有\",{\"1\":{\"18\":1}}],[\"最少得有\",{\"1\":{\"15\":1}}],[\"最少两个字\",{\"1\":{\"10\":1}}],[\"最大包长度等\",{\"1\":{\"64\":1}}],[\"最大数量为\",{\"1\":{\"62\":1}}],[\"最大的功能点\",{\"1\":{\"52\":1}}],[\"最大子节点个数和父节点\",{\"1\":{\"16\":1}}],[\"最大子节点个数是根据页大小\",{\"1\":{\"16\":1}}],[\"最大页数量\",{\"1\":{\"10\":1}}],[\"最大限度地提高在内存中处理数据查询的机会\",{\"1\":{\"9\":1}}],[\"improvement\",{\"0\":{\"74\":1},\"1\":{\"73\":1}}],[\"important\",{\"1\":{\"72\":1}}],[\"implementation\",{\"1\":{\"62\":1}}],[\"icpc\",{\"1\":{\"69\":1}}],[\"ignored\",{\"1\":{\"64\":2}}],[\"ipv4\",{\"1\":{\"58\":1,\"66\":1}}],[\"ip\",{\"1\":{\"57\":1}}],[\"i++\",{\"1\":{\"45\":1,\"65\":1}}],[\"ii\",{\"1\":{\"22\":1,\"27\":1}}],[\"i\",{\"1\":{\"22\":1,\"27\":1,\"45\":3,\"64\":1,\"65\":2,\"70\":1,\"73\":2}}],[\"isn\",{\"1\":{\"62\":12,\"63\":4,\"64\":2}}],[\"islockcompatible\",{\"1\":{\"35\":1}}],[\"isleafpage\",{\"1\":{\"17\":1,\"19\":1,\"20\":1}}],[\"isolationlevel\",{\"1\":{\"35\":2,\"36\":3}}],[\"isolation\",{\"1\":{\"30\":1}}],[\"issafety\",{\"1\":{\"20\":1}}],[\"isrootpage\",{\"1\":{\"18\":1,\"19\":1}}],[\"isempty\",{\"1\":{\"17\":1,\"18\":1,\"19\":1}}],[\"isdirty\",{\"1\":{\"11\":4}}],[\"is\",{\"1\":{\"11\":10,\"35\":1,\"62\":2,\"64\":3,\"70\":2,\"72\":3,\"73\":1,\"74\":1}}],[\"its\",{\"1\":{\"64\":2}}],[\"iterator\",{\"1\":{\"25\":1,\"26\":4,\"36\":3}}],[\"iterator>\",{\"1\":{\"10\":1}}],[\"it\",{\"1\":{\"10\":2,\"35\":1,\"64\":1,\"73\":1}}],[\"if\",{\"1\":{\"10\":3,\"11\":15,\"17\":3,\"18\":5,\"19\":7,\"20\":3,\"25\":1,\"26\":1,\"35\":6,\"36\":4,\"45\":2,\"60\":1,\"61\":7,\"62\":10,\"63\":13,\"64\":24,\"65\":4}}],[\"id\",{\"1\":{\"10\":26,\"11\":67,\"16\":11,\"17\":1,\"18\":2,\"19\":2,\"26\":4,\"32\":1,\"35\":12}}],[\"io\",{\"1\":{\"9\":2,\"16\":2}}],[\"indicator\",{\"1\":{\"72\":1}}],[\"indexes\",{\"1\":{\"22\":2}}],[\"indexpagetype\",{\"1\":{\"16\":1}}],[\"index\",{\"1\":{\"6\":1,\"16\":2,\"19\":1,\"26\":2,\"61\":28,\"62\":21}}],[\"info\",{\"1\":{\"65\":22}}],[\"influxdb\",{\"1\":{\"3\":1}}],[\"including\",{\"1\":{\"64\":1}}],[\"include\",{\"1\":{\"6\":1}}],[\"incoming\",{\"1\":{\"64\":1,\"65\":1}}],[\"inbound\",{\"1\":{\"64\":3,\"65\":2}}],[\"input\",{\"1\":{\"61\":1,\"62\":3,\"64\":2}}],[\"inline\",{\"1\":{\"40\":4}}],[\"invalid\",{\"1\":{\"19\":1,\"40\":1}}],[\"initiate\",{\"1\":{\"65\":1}}],[\"initialization\",{\"1\":{\"73\":1}}],[\"initial\",{\"1\":{\"63\":4}}],[\"init\",{\"1\":{\"18\":2,\"26\":4}}],[\"inserter\",{\"1\":{\"26\":1,\"36\":1}}],[\"insertnewkey\",{\"1\":{\"18\":1}}],[\"insertintoparent\",{\"1\":{\"18\":3}}],[\"insertintoleaf\",{\"1\":{\"18\":2}}],[\"insert\",{\"1\":{\"18\":4,\"26\":1,\"31\":1,\"35\":2,\"61\":1}}],[\"introduction\",{\"1\":{\"67\":1}}],[\"integers\",{\"1\":{\"59\":2}}],[\"interested\",{\"1\":{\"62\":1}}],[\"interval\",{\"1\":{\"35\":1}}],[\"internal\",{\"1\":{\"16\":4,\"18\":1,\"19\":3}}],[\"internalpage\",{\"1\":{\"16\":8}}],[\"int64\",{\"1\":{\"45\":3}}],[\"int32\",{\"1\":{\"45\":2}}],[\"int\",{\"1\":{\"16\":5,\"17\":1,\"26\":1,\"45\":4,\"63\":4,\"65\":4}}],[\"in\",{\"0\":{\"69\":1},\"1\":{\"11\":1,\"61\":1,\"62\":3,\"63\":22,\"64\":12,\"65\":2,\"72\":1,\"73\":2,\"74\":1}}],[\"2^64\",{\"1\":{\"62\":1}}],[\"2^32−1\",{\"1\":{\"62\":1}}],[\"2^32−2\",{\"1\":{\"62\":2}}],[\"2^32\",{\"1\":{\"62\":1}}],[\"2pl\",{\"1\":{\"32\":4}}],[\"2023\",{\"1\":{\"69\":1}}],[\"2020\",{\"1\":{\"67\":1}}],[\"200\",{\"1\":{\"31\":1}}],[\"20\",{\"1\":{\"26\":2}}],[\"2\",{\"0\":{\"8\":1,\"71\":1,\"72\":1,\"73\":2,\"77\":1},\"1\":{\"11\":2,\"15\":3,\"17\":1,\"18\":2,\"19\":4,\"20\":1,\"22\":1,\"31\":2,\"36\":2,\"62\":3,\"63\":2,\"64\":3,\"65\":1,\"74\":2}}],[\"eur\",{\"1\":{\"69\":1}}],[\"error\",{\"1\":{\"64\":3}}],[\"erase\",{\"1\":{\"10\":3,\"11\":1,\"61\":3}}],[\"equal\",{\"1\":{\"63\":1}}],[\"element\",{\"1\":{\"62\":1}}],[\"else\",{\"1\":{\"11\":2,\"17\":1,\"20\":2,\"61\":1,\"63\":1,\"64\":1}}],[\"eof\",{\"1\":{\"61\":12,\"63\":2,\"64\":2,\"65\":1}}],[\"evicted\",{\"1\":{\"73\":1}}],[\"evict\",{\"1\":{\"70\":1,\"72\":1}}],[\"every\",{\"1\":{\"35\":1,\"73\":1}}],[\"evaluate\",{\"1\":{\"26\":1,\"36\":1}}],[\"emplace\",{\"1\":{\"35\":1}}],[\"empty\",{\"1\":{\"10\":1,\"11\":2,\"61\":2,\"62\":1,\"63\":4,\"64\":12,\"65\":2}}],[\"enter\",{\"1\":{\"73\":1}}],[\"entry\",{\"1\":{\"19\":1}}],[\"environment\",{\"0\":{\"69\":1}}],[\"enum\",{\"1\":{\"45\":3}}],[\"enable\",{\"1\":{\"35\":2}}],[\"endl\",{\"1\":{\"65\":5}}],[\"ends\",{\"1\":{\"64\":1}}],[\"ended\",{\"1\":{\"62\":3,\"64\":6}}],[\"end\",{\"1\":{\"26\":1,\"36\":1,\"61\":2,\"64\":1}}],[\"e\",{\"1\":{\"19\":4,\"25\":1,\"64\":1,\"65\":5}}],[\"edge\",{\"1\":{\"62\":1}}],[\"ed\",{\"1\":{\"17\":4}}],[\"edition\",{\"1\":{\"7\":1}}],[\"experience\",{\"1\":{\"72\":1}}],[\"explicit\",{\"1\":{\"16\":1,\"26\":1,\"40\":1}}],[\"exit\",{\"1\":{\"65\":4}}],[\"exclusive\",{\"1\":{\"35\":1}}],[\"exception\",{\"1\":{\"25\":1,\"65\":4}}],[\"exec\",{\"1\":{\"25\":3,\"26\":10,\"36\":11}}],[\"execute\",{\"1\":{\"25\":3}}],[\"executionengine\",{\"1\":{\"25\":3,\"26\":2}}],[\"execution\",{\"1\":{\"6\":2,\"26\":1,\"27\":3}}],[\"executorfactory\",{\"1\":{\"25\":2}}],[\"executorcontext\",{\"1\":{\"25\":1,\"26\":4}}],[\"executor\",{\"1\":{\"5\":1,\"25\":4,\"26\":10}}],[\"我们下一个系列再见～\",{\"1\":{\"66\":1}}],[\"我们在\",{\"1\":{\"61\":1}}],[\"我们必须有序的组装\",{\"1\":{\"61\":1}}],[\"我们就以先整体后局部的方式来详细介绍\",{\"1\":{\"58\":1}}],[\"我们很轻易的就建立起了\",{\"1\":{\"56\":1}}],[\"我们可以快速的使用\",{\"1\":{\"56\":1}}],[\"我们可以发现\",{\"1\":{\"11\":1}}],[\"我们将在实现部分详细介绍\",{\"1\":{\"54\":1}}],[\"我们将在后面的实现中详细介绍\",{\"1\":{\"52\":1}}],[\"我们将实现部分详细介绍\",{\"1\":{\"53\":1}}],[\"我们以一个具体场景为例\",{\"1\":{\"45\":1}}],[\"我们要明确为什么pb为什么需要反射\",{\"1\":{\"45\":1}}],[\"我们介绍了\",{\"1\":{\"36\":1}}],[\"我们实现了支持并发访问的\",{\"1\":{\"29\":1}}],[\"我们只需实现一个简单的执行器就能领略到数据库执行器的风采\",{\"1\":{\"26\":1}}],[\"我们先来看看其精美的代码设计\",{\"1\":{\"16\":1}}],[\"我们来一起看看\",{\"1\":{\"17\":1}}],[\"我们来看看\",{\"1\":{\"16\":1}}],[\"我们来依次详细介绍这些模块的作用和实现\",{\"1\":{\"6\":1}}],[\"我们需要去使用一下该协议\",{\"1\":{\"65\":1}}],[\"我们需要及时的回复\",{\"1\":{\"64\":1}}],[\"我们需要一种机制来保证所有事务执行是正确的\",{\"1\":{\"33\":1}}],[\"我们需要一个管理内存与磁盘数据的中介组件\",{\"1\":{\"9\":1}}],[\"我们需要删除\",{\"1\":{\"20\":1}}],[\"我们需要明确\",{\"1\":{\"15\":1}}],[\"我们一起来看一下其代码结构\",{\"1\":{\"6\":1}}],[\"我们一起来看看\",{\"1\":{\"5\":1,\"59\":1}}],[\"目录\",{\"1\":{\"6\":5,\"26\":1}}],[\"目前最著名的当属\",{\"1\":{\"57\":1}}],[\"目前\",{\"1\":{\"3\":1}}],[\"每当调用\",{\"1\":{\"64\":1}}],[\"每当计时\",{\"1\":{\"64\":1}}],[\"每次超时重发\",{\"1\":{\"63\":1}}],[\"每次发送一个包\",{\"1\":{\"63\":1}}],[\"每次调用\",{\"1\":{\"25\":1}}],[\"每访问一个节点都必须先加独占锁\",{\"1\":{\"20\":1}}],[\"每个\",{\"1\":{\"61\":1}}],[\"每个报文中的每个字节都有唯一的序号\",{\"1\":{\"58\":1}}],[\"每个报文都有校验和字段\",{\"1\":{\"52\":1}}],[\"每个人都有能力去理解和实现\",{\"1\":{\"57\":1}}],[\"每个事务当需要时向锁管理器请求锁\",{\"1\":{\"32\":1}}],[\"每个非叶子节点\",{\"1\":{\"15\":1}}],[\"每个节点最多只有\",{\"1\":{\"15\":1}}],[\"每个目录后面用注释说明了当前模块的作用和功能\",{\"1\":{\"6\":1}}],[\"每一条数据记录都由\",{\"1\":{\"35\":1}}],[\"每一类查询\",{\"1\":{\"26\":1}}],[\"每一个执行器都实现\",{\"1\":{\"25\":1}}],[\"每一个箭头指向一个孩子节点\",{\"1\":{\"15\":1}}],[\"每一项对应的数组序号称为\",{\"1\":{\"11\":1}}],[\"每一页在磁盘上都有一个副本\",{\"1\":{\"9\":1}}],[\"每执行一次查询\",{\"1\":{\"5\":1}}],[\"tick\",{\"1\":{\"63\":10,\"64\":8}}],[\"timeout\",{\"1\":{\"63\":8,\"64\":4}}],[\"timer\",{\"1\":{\"63\":6}}],[\"time\",{\"1\":{\"35\":1,\"63\":6,\"64\":8,\"73\":2}}],[\"tun\",{\"1\":{\"57\":1}}],[\"tup\",{\"1\":{\"26\":6,\"36\":13}}],[\"tuples\",{\"1\":{\"36\":1}}],[\"tuple\",{\"1\":{\"25\":6,\"26\":11,\"29\":2,\"36\":8}}],[\"tenant\",{\"0\":{\"69\":1}}],[\"tell\",{\"1\":{\"64\":1}}],[\"telnet\",{\"1\":{\"56\":2}}],[\"template\",{\"1\":{\"16\":4}}],[\"tcpoverudpsocketadapter\",{\"1\":{\"65\":2}}],[\"tcpstate\",{\"1\":{\"64\":3,\"65\":1}}],[\"tcpsegment\",{\"1\":{\"58\":1,\"62\":1,\"63\":4,\"64\":3,\"65\":2}}],[\"tcpsender\",{\"0\":{\"63\":1},\"1\":{\"58\":6,\"59\":2,\"63\":8,\"64\":4}}],[\"tcpconfig\",{\"1\":{\"63\":1,\"64\":3,\"65\":2}}],[\"tcpconnection\",{\"0\":{\"64\":1},\"1\":{\"58\":6,\"59\":3,\"60\":1,\"63\":1,\"64\":21,\"65\":5}}],[\"tcp发送者\",{\"1\":{\"59\":1}}],[\"tcp接收者\",{\"1\":{\"59\":1}}],[\"tcp连接\",{\"1\":{\"59\":1}}],[\"tcpreceiver\",{\"0\":{\"62\":1},\"1\":{\"58\":6,\"59\":2,\"62\":6,\"63\":1,\"64\":2}}],[\"tcp\",{\"0\":{\"48\":1,\"49\":1,\"50\":1},\"1\":{\"49\":7,\"50\":1,\"51\":3,\"52\":5,\"53\":6,\"54\":2,\"56\":3,\"57\":5,\"58\":6,\"59\":6,\"60\":1,\"61\":8,\"62\":5,\"63\":1,\"64\":4,\"65\":15,\"67\":1}}],[\"two\",{\"1\":{\"37\":1,\"73\":1}}],[\"through\",{\"1\":{\"72\":1}}],[\"throughput\",{\"1\":{\"65\":2}}],[\"thread\",{\"1\":{\"35\":2,\"65\":1}}],[\"than\",{\"1\":{\"64\":1,\"73\":1}}],[\"that\",{\"1\":{\"16\":1,\"63\":2,\"64\":3,\"72\":2}}],[\"their\",{\"1\":{\"74\":1}}],[\"them\",{\"1\":{\"74\":1}}],[\"then\",{\"1\":{\"72\":2}}],[\"theory\",{\"1\":{\"37\":1,\"73\":1}}],[\"the\",{\"0\":{\"72\":1,\"73\":1},\"1\":{\"35\":1,\"61\":2,\"62\":13,\"63\":5,\"64\":27,\"70\":4,\"72\":12,\"73\":14,\"74\":3}}],[\"this\",{\"1\":{\"35\":2,\"61\":1,\"62\":1,\"64\":1,\"65\":1,\"70\":1,\"73\":1}}],[\"task\",{\"0\":{\"70\":1},\"1\":{\"70\":1}}],[\"tap\",{\"1\":{\"57\":1}}],[\"talk\",{\"0\":{\"46\":1}}],[\"take\",{\"1\":{\"35\":1}}],[\"table\",{\"1\":{\"6\":1,\"11\":12,\"26\":20,\"35\":4,\"36\":8}}],[\"total\",{\"1\":{\"61\":5}}],[\"todo\",{\"1\":{\"36\":1}}],[\"to\",{\"0\":{\"72\":2,\"73\":1},\"1\":{\"35\":1,\"62\":1,\"63\":2,\"64\":7,\"65\":17,\"67\":1,\"70\":2,\"72\":2,\"73\":4,\"74\":2}}],[\"t3\",{\"1\":{\"34\":2}}],[\"t2\",{\"1\":{\"33\":2,\"34\":4}}],[\"t1\",{\"1\":{\"33\":4,\"34\":4}}],[\"txn\",{\"1\":{\"25\":2,\"35\":33}}],[\"track\",{\"1\":{\"74\":1}}],[\"transform\",{\"1\":{\"26\":1,\"36\":1}}],[\"transactionstate\",{\"1\":{\"35\":4}}],[\"transactionmanager\",{\"1\":{\"29\":1,\"35\":2}}],[\"transaction\",{\"1\":{\"5\":1,\"18\":1,\"25\":1,\"35\":4}}],[\"treat\",{\"1\":{\"63\":1}}],[\"tree\",{\"1\":{\"22\":1}}],[\"trees\",{\"1\":{\"22\":2}}],[\"tries\",{\"1\":{\"35\":1}}],[\"try\",{\"1\":{\"25\":1,\"65\":2}}],[\"true\",{\"1\":{\"10\":1,\"11\":4,\"18\":3,\"25\":1,\"26\":1,\"35\":5,\"36\":2,\"61\":3,\"62\":3,\"63\":6,\"64\":8,\"65\":1}}],[\"t>\",{\"1\":{\"10\":2,\"11\":2,\"63\":1}}],[\"t\",{\"1\":{\"10\":9,\"11\":15,\"16\":5,\"26\":3,\"35\":1,\"40\":4,\"45\":3,\"60\":8,\"61\":9,\"62\":10,\"63\":12,\"64\":5,\"65\":1,\"69\":1}}],[\"typename\",{\"1\":{\"16\":2}}],[\"type\",{\"1\":{\"6\":1,\"16\":1,\"20\":4,\"45\":13}}],[\"└──\",{\"1\":{\"6\":2,\"26\":1,\"59\":1}}],[\"索引元数据\",{\"1\":{\"26\":1}}],[\"索引数据都会通过缓存管理器来管理\",{\"1\":{\"11\":1}}],[\"索引\",{\"1\":{\"6\":1}}],[\"│\",{\"1\":{\"6\":4}}],[\"存储在\",{\"1\":{\"61\":1}}],[\"存储表\",{\"1\":{\"26\":1}}],[\"存储页数据的唯一途径\",{\"1\":{\"16\":1}}],[\"存储模块\",{\"1\":{\"6\":1}}],[\"存储管理和磁盘存储三大部分\",{\"1\":{\"5\":1}}],[\"头文件\",{\"1\":{\"6\":1,\"59\":6}}],[\"执行\",{\"1\":{\"26\":1,\"36\":1}}],[\"执行计划\",{\"0\":{\"26\":1}}],[\"执行上下文\",{\"1\":{\"25\":1}}],[\"执行期实现\",{\"1\":{\"6\":1}}],[\"执行模块\",{\"1\":{\"6\":1}}],[\"执行器运行流程图如图\",{\"1\":{\"26\":1}}],[\"执行器执行时从上下文中获取查询所需的环境\",{\"1\":{\"26\":1}}],[\"执行器需访问数据页\",{\"1\":{\"26\":1}}],[\"执行器上下文上保存了执行器所需的环境\",{\"1\":{\"26\":1}}],[\"执行器可以拥有子执行器\",{\"1\":{\"25\":1}}],[\"执行器都会返回一条数据记录\",{\"1\":{\"25\":1}}],[\"执行器根据执行计划中过滤条件筛选数据返回给应用程序\",{\"1\":{\"5\":1}}],[\"执行器根据执行计划\",{\"1\":{\"5\":1}}],[\"执行器\",{\"0\":{\"23\":1,\"24\":1,\"36\":1},\"1\":{\"5\":1,\"6\":1,\"26\":1}}],[\"执行器究竟是如何实现的\",{\"1\":{\"3\":1}}],[\"并向服务器发送\",{\"1\":{\"65\":1}}],[\"并关闭连接\",{\"1\":{\"64\":1}}],[\"并填充到报文中\",{\"1\":{\"64\":1}}],[\"并放入自己的队列\",{\"1\":{\"64\":1}}],[\"并做如下处理\",{\"1\":{\"64\":1}}],[\"并设置到\",{\"1\":{\"63\":1}}],[\"并在超时后重新发送\",{\"1\":{\"63\":1}}],[\"并与\",{\"1\":{\"62\":1}}],[\"并重组后交给应用程序\",{\"1\":{\"58\":1}}],[\"并没有什么高深莫测的技术\",{\"1\":{\"57\":1}}],[\"并提供\",{\"1\":{\"56\":1}}],[\"并提交了\",{\"1\":{\"33\":1}}],[\"并领略它的风采\",{\"1\":{\"56\":1}}],[\"并对外暴露\",{\"1\":{\"56\":1}}],[\"并对子节点加上共享锁后\",{\"1\":{\"20\":1}}],[\"并通过重组器\",{\"1\":{\"58\":1}}],[\"并通过\",{\"1\":{\"41\":1,\"62\":1}}],[\"并通过判断节点是否安全来决定是否释放祖先节点上的锁\",{\"1\":{\"20\":1}}],[\"并能解锁\",{\"1\":{\"36\":1}}],[\"并启动一个后台线程专门用于检查事务之间的依赖关系\",{\"1\":{\"35\":1}}],[\"并决定如何打破它\",{\"1\":{\"34\":1}}],[\"并包装为表记录返回给执行引擎\",{\"1\":{\"26\":1}}],[\"并不会发包\",{\"1\":{\"64\":1}}],[\"并不断调用\",{\"1\":{\"25\":1}}],[\"并不单单指数据查询\",{\"1\":{\"24\":1}}],[\"并获取查询结果\",{\"1\":{\"25\":1}}],[\"并释放锁\",{\"1\":{\"20\":1}}],[\"并插入\",{\"1\":{\"18\":1}}],[\"并且该问题二阶可导\",{\"1\":{\"78\":1}}],[\"并且我们可以使用pytorch中自带的优化器\",{\"1\":{\"78\":1}}],[\"并且已经全部发送到对端\",{\"1\":{\"64\":1}}],[\"并且涉及到不同的连接关闭方式\",{\"1\":{\"64\":1}}],[\"并且关闭连接\",{\"1\":{\"64\":1}}],[\"并且调用\",{\"1\":{\"64\":1}}],[\"并且永久关闭连接\",{\"1\":{\"64\":1}}],[\"并且推出队列\",{\"1\":{\"63\":1}}],[\"并且打包后直接发送\",{\"1\":{\"63\":1}}],[\"并且查询字节数量不能超过当前缓冲区字节的数量\",{\"1\":{\"60\":1}}],[\"并且发生了环等待\",{\"1\":{\"34\":1}}],[\"并且尽可能的提高并发性能\",{\"1\":{\"20\":1}}],[\"并且更新\",{\"1\":{\"19\":1,\"60\":1}}],[\"并且更新父节点\",{\"1\":{\"19\":1}}],[\"并且设置指向子节点的指针\",{\"1\":{\"18\":1}}],[\"并且\",{\"1\":{\"18\":1}}],[\"并且能够一直保持完美的自平衡\",{\"1\":{\"15\":1}}],[\"并且页最后能否被删除取决于\",{\"1\":{\"11\":1}}],[\"并刷回磁盘\",{\"1\":{\"11\":1}}],[\"并刷到磁盘中\",{\"1\":{\"10\":1}}],[\"并从中删除\",{\"1\":{\"19\":1}}],[\"并从磁盘中读取新页\",{\"1\":{\"11\":1}}],[\"并从哈希表中删除\",{\"1\":{\"10\":1}}],[\"并增加\",{\"1\":{\"11\":1}}],[\"并将报文数据\",{\"1\":{\"62\":1}}],[\"并将报文中的\",{\"1\":{\"58\":2}}],[\"并将流数据交付给应用程序\",{\"1\":{\"58\":1}}],[\"并将其包装成报文并发送\",{\"1\":{\"58\":1}}],[\"并将字节流写入到\",{\"1\":{\"58\":1}}],[\"并将接收到的报文交给\",{\"1\":{\"58\":1}}],[\"并将淘汰页的\",{\"1\":{\"10\":1}}],[\"并将执行计划交给执行器\",{\"1\":{\"5\":1}}],[\"并写入哈希表供快速查询\",{\"1\":{\"10\":1}}],[\"并发送给远端\",{\"1\":{\"58\":1}}],[\"并发访问控制和数据库事务的\",{\"1\":{\"29\":1}}],[\"并发访问索引是极其常见的\",{\"1\":{\"20\":1}}],[\"并发的\",{\"1\":{\"21\":1}}],[\"并发b+树\",{\"0\":{\"13\":1}}],[\"并发\",{\"0\":{\"14\":1},\"1\":{\"6\":1}}],[\"并发控制\",{\"0\":{\"28\":1,\"29\":1},\"1\":{\"6\":2}}],[\"公共模块\",{\"1\":{\"6\":1}}],[\"├──\",{\"1\":{\"6\":11,\"26\":9,\"59\":11}}],[\"代码地址\",{\"1\":{\"78\":1}}],[\"代码上有详细的注释\",{\"1\":{\"64\":1}}],[\"代码结构\",{\"0\":{\"6\":1}}],[\"代码虽然开源\",{\"1\":{\"3\":1}}],[\"锁升级和解锁等操作\",{\"1\":{\"35\":1}}],[\"锁多的先淘汰\",{\"1\":{\"34\":1}}],[\"锁可分为如下两种类型\",{\"1\":{\"33\":1}}],[\"锁是为了解决不同事务并发操作的隔离性问题\",{\"1\":{\"33\":1}}],[\"锁的\",{\"1\":{\"20\":1}}],[\"锁管理器维护了一个\",{\"1\":{\"35\":1}}],[\"锁管理器会赋予事务锁\",{\"1\":{\"35\":1}}],[\"锁管理器在内部维护一个名为\",{\"1\":{\"34\":1}}],[\"锁管理器在内部维护了事务锁表\",{\"1\":{\"33\":1}}],[\"锁管理器授予事务锁\",{\"1\":{\"33\":1}}],[\"锁管理器的执行机制如下\",{\"1\":{\"33\":1}}],[\"锁管理器负责向事务授予锁\",{\"1\":{\"32\":1}}],[\"锁管理器实现\",{\"1\":{\"6\":1}}],[\"锁管理器\",{\"0\":{\"33\":1},\"1\":{\"6\":1,\"29\":1,\"35\":1}}],[\"锁\",{\"1\":{\"5\":1,\"10\":1,\"11\":1,\"33\":1}}],[\"不应该\",{\"1\":{\"64\":1}}],[\"不用我们再手动求导\",{\"1\":{\"78\":1}}],[\"不用再确认\",{\"1\":{\"63\":1}}],[\"不用发送\",{\"1\":{\"63\":1}}],[\"不用分裂\",{\"1\":{\"18\":1}}],[\"不填充\",{\"1\":{\"63\":1}}],[\"不算\",{\"1\":{\"62\":2}}],[\"不含\",{\"1\":{\"61\":1}}],[\"不支持转换repeated字段\",{\"1\":{\"45\":1}}],[\"不仅结构体积小\",{\"1\":{\"45\":1}}],[\"不能立马关闭\",{\"1\":{\"61\":1}}],[\"不能超过\",{\"1\":{\"60\":1}}],[\"不能加读锁后\",{\"1\":{\"36\":1}}],[\"不能访问\",{\"1\":{\"33\":1}}],[\"不能删除\",{\"1\":{\"11\":2}}],[\"不可直接写入字节流\",{\"1\":{\"61\":1}}],[\"不可写\",{\"1\":{\"33\":1}}],[\"不可重复读\",{\"1\":{\"31\":3}}],[\"不可能为负\",{\"1\":{\"11\":1}}],[\"不安全\",{\"1\":{\"20\":1}}],[\"不会重发所有报文\",{\"1\":{\"63\":1}}],[\"不会发生重组\",{\"1\":{\"20\":1}}],[\"不会再淘汰\",{\"1\":{\"11\":1}}],[\"不满足半满性质\",{\"1\":{\"19\":2}}],[\"不是根节点\",{\"1\":{\"18\":1}}],[\"不同的查询计划对应不同的执行器\",{\"1\":{\"26\":1}}],[\"不同于二叉树\",{\"1\":{\"15\":1}}],[\"不同级别又是如何实现\",{\"1\":{\"3\":1}}],[\"不再使用\",{\"1\":{\"11\":1}}],[\"不存在\",{\"1\":{\"11\":1}}],[\"不存在则调用文件管理器读取对应页然后再返回\",{\"1\":{\"5\":1}}],[\"不过需要注意以下两点\",{\"1\":{\"10\":1}}],[\"不受淘汰约束\",{\"1\":{\"10\":1}}],[\"请求成功后\",{\"1\":{\"35\":1}}],[\"请求锁\",{\"1\":{\"35\":1}}],[\"请求事务管理器获取事务\",{\"1\":{\"5\":1}}],[\"请你先尝试回答如下几个问题\",{\"1\":{\"3\":1}}],[\"或者被析构\",{\"1\":{\"64\":1}}],[\"或者已经\",{\"1\":{\"63\":1}}],[\"或者已经包含了\",{\"1\":{\"10\":1}}],[\"或者当前锁请求与队列中的其它锁兼容\",{\"1\":{\"35\":1}}],[\"或者当前表记录\",{\"1\":{\"26\":1}}],[\"或者阻塞事务执行\",{\"1\":{\"33\":1}}],[\"或者阻塞事物\",{\"1\":{\"32\":1}}],[\"或者升级\",{\"1\":{\"33\":1}}],[\"或者协议\",{\"1\":{\"20\":1}}],[\"或者将\",{\"1\":{\"19\":1}}],[\"或者\",{\"1\":{\"16\":1,\"19\":1,\"61\":1,\"63\":1}}],[\"或者从磁盘读数据页\",{\"1\":{\"5\":1}}],[\"或更新\",{\"1\":{\"5\":1}}],[\"在这里我们选择torch\",{\"1\":{\"78\":1}}],[\"在这个例子中\",{\"1\":{\"19\":1}}],[\"在这个架构下\",{\"1\":{\"5\":1}}],[\"在完成\",{\"1\":{\"66\":1}}],[\"在互联网普及的今天\",{\"1\":{\"66\":1}}],[\"在代码中是这样发生\",{\"1\":{\"65\":1}}],[\"在收到\",{\"1\":{\"64\":1}}],[\"在刚才的代码中\",{\"1\":{\"64\":1}}],[\"在推入报文到队列之前\",{\"1\":{\"64\":1}}],[\"在队列清空后停止\",{\"1\":{\"63\":1}}],[\"在没有\",{\"1\":{\"63\":1}}],[\"在被设置\",{\"1\":{\"63\":1}}],[\"在初始化时\",{\"1\":{\"60\":1}}],[\"在上面也谈到了\",{\"1\":{\"60\":1}}],[\"在上一讲中\",{\"1\":{\"36\":1}}],[\"在介绍\",{\"1\":{\"59\":1}}],[\"在粗略介绍\",{\"1\":{\"59\":1}}],[\"在用户态上实现协议是一个很有趣且很有挑战的事情\",{\"1\":{\"57\":1}}],[\"在一个窗口中通过\",{\"1\":{\"56\":1}}],[\"在可靠性上做了很多努力\",{\"1\":{\"52\":1}}],[\"在三次握手的过程中\",{\"1\":{\"51\":1}}],[\"在正式数据传输之前\",{\"1\":{\"51\":1}}],[\"在正式介绍数据库设计和实现之前\",{\"1\":{\"3\":1}}],[\"在重做期间记录正在活跃的事务\",{\"1\":{\"41\":1}}],[\"在重做期间恢复历史数据\",{\"1\":{\"39\":1}}],[\"在重新启动时\",{\"1\":{\"39\":1}}],[\"在并发\",{\"1\":{\"29\":1}}],[\"在实现上其实是非常复杂的\",{\"1\":{\"21\":1}}],[\"在实际的数据库场景中\",{\"1\":{\"20\":1}}],[\"在节点\",{\"1\":{\"19\":1}}],[\"在删除的过程中\",{\"1\":{\"19\":1}}],[\"在基本情况的基础上\",{\"1\":{\"18\":1}}],[\"在\",{\"1\":{\"18\":2,\"20\":1,\"29\":1,\"32\":2,\"36\":1,\"40\":1,\"57\":1,\"62\":1,\"65\":1}}],[\"在对\",{\"1\":{\"17\":1}}],[\"在内部通过调用\",{\"1\":{\"16\":1}}],[\"在具体的\",{\"1\":{\"16\":1}}],[\"在数据组织和索引组织上几乎都选择了\",{\"1\":{\"14\":1}}],[\"在不同场景中选择合适的淘汰策略\",{\"1\":{\"10\":1}}],[\"磁盘之间的数据通道\",{\"1\":{\"11\":1}}],[\"磁盘之间的数据交换\",{\"1\":{\"11\":1}}],[\"磁盘\",{\"1\":{\"11\":1}}],[\"磁盘上的副本可能是老数据\",{\"1\":{\"9\":1}}],[\"磁盘上保存的数据实则是缓存池数据的副本\",{\"1\":{\"9\":1}}],[\"磁盘存储\",{\"1\":{\"5\":1,\"6\":1}}],[\"磁盘管理器\",{\"1\":{\"5\":1,\"6\":1,\"11\":1}}],[\"lbfgs作为优化器\",{\"1\":{\"78\":1}}],[\"last\",{\"1\":{\"62\":1,\"63\":2,\"64\":10}}],[\"latch\",{\"1\":{\"11\":2,\"35\":9}}],[\"ll\",{\"1\":{\"62\":2}}],[\"left\",{\"1\":{\"62\":1}}],[\"length\",{\"1\":{\"60\":6,\"62\":1,\"63\":3,\"64\":1}}],[\"len\",{\"1\":{\"60\":14,\"63\":3}}],[\"leaf\",{\"1\":{\"16\":8,\"17\":2,\"18\":8,\"19\":3}}],[\"leafpage\",{\"1\":{\"16\":7}}],[\"least\",{\"1\":{\"10\":1,\"64\":1}}],[\"lean\",{\"1\":{\"0\":1}}],[\"l\",{\"1\":{\"56\":2}}],[\"like\",{\"1\":{\"74\":1}}],[\"lingering\",{\"1\":{\"65\":1}}],[\"linger\",{\"1\":{\"64\":6}}],[\"libsponge\",{\"1\":{\"59\":1}}],[\"limited\",{\"1\":{\"65\":2}}],[\"limit\",{\"1\":{\"24\":1,\"26\":1,\"64\":1,\"73\":1}}],[\"listen\",{\"1\":{\"64\":8,\"65\":1}}],[\"listening\",{\"1\":{\"56\":2,\"65\":1}}],[\"list\",{\"1\":{\"10\":4,\"11\":9}}],[\"list<frame\",{\"1\":{\"10\":2,\"11\":1}}],[\"lsn\",{\"1\":{\"16\":2,\"40\":12,\"41\":1}}],[\"lossytcpoverudpsocketadapter\",{\"1\":{\"65\":3}}],[\"lossytcpoverudpspongesocket\",{\"1\":{\"65\":2}}],[\"lower\",{\"1\":{\"61\":4}}],[\"long\",{\"1\":{\"61\":4}}],[\"local\",{\"1\":{\"64\":1}}],[\"localhost\",{\"1\":{\"56\":1}}],[\"locking\",{\"1\":{\"37\":1}}],[\"locked\",{\"1\":{\"35\":2}}],[\"lockexclusive\",{\"1\":{\"35\":1}}],[\"lockupgrade\",{\"1\":{\"35\":1}}],[\"lockmode\",{\"1\":{\"35\":1}}],[\"lockmanager\",{\"1\":{\"29\":1,\"35\":5}}],[\"lock<std\",{\"1\":{\"35\":3}}],[\"lockshared\",{\"1\":{\"35\":4}}],[\"locks\",{\"1\":{\"34\":1}}],[\"lock\",{\"1\":{\"10\":3,\"11\":6,\"35\":20}}],[\"loop\",{\"1\":{\"26\":1}}],[\"lookup\",{\"1\":{\"17\":4,\"20\":1}}],[\"logging\",{\"1\":{\"42\":1}}],[\"logrecovery\",{\"1\":{\"41\":2}}],[\"logrecord\",{\"1\":{\"40\":1,\"41\":1}}],[\"logmanager\",{\"1\":{\"11\":1,\"40\":3}}],[\"log\",{\"1\":{\"5\":1,\"11\":1,\"16\":1,\"40\":7,\"41\":5}}],[\"lfu\",{\"1\":{\"10\":1,\"74\":1}}],[\"lrureplacer\",{\"1\":{\"10\":9,\"11\":1}}],[\"lru\",{\"1\":{\"6\":1,\"10\":10,\"11\":1,\"17\":1,\"70\":1,\"73\":4}}],[\"一一对应\",{\"1\":{\"62\":1}}],[\"一般使用\",{\"1\":{\"45\":1}}],[\"一致性和持久性\",{\"1\":{\"39\":1}}],[\"一致性\",{\"1\":{\"30\":1}}],[\"一致性等\",{\"1\":{\"5\":1}}],[\"一下\",{\"1\":{\"17\":1}}],[\"一个是待优化变量维数较高\",{\"1\":{\"76\":1}}],[\"一个是正常的\",{\"1\":{\"62\":1}}],[\"一个输入流\",{\"1\":{\"58\":1}}],[\"一个输出流\",{\"1\":{\"54\":1,\"58\":1}}],[\"一个事务访问数据库时\",{\"1\":{\"32\":1}}],[\"一个事务执行过程中看到的数据\",{\"1\":{\"31\":1}}],[\"一个事务提交之后\",{\"1\":{\"31\":1}}],[\"一个事务还没提交\",{\"1\":{\"31\":1}}],[\"一个事务的执行不应影响其他事务的执行\",{\"1\":{\"30\":1}}],[\"一个\",{\"1\":{\"26\":1,\"36\":1,\"54\":1,\"58\":1,\"60\":1,\"61\":1}}],[\"一个具体的\",{\"1\":{\"16\":1}}],[\"一个内部节点有\",{\"1\":{\"15\":1}}],[\"一个页\",{\"1\":{\"11\":1}}],[\"一颗\",{\"1\":{\"15\":2}}],[\"一定记得\",{\"1\":{\"11\":1}}],[\"一旦将报文推入\",{\"1\":{\"63\":1}}],[\"一旦超时\",{\"1\":{\"63\":1}}],[\"一旦计算机故障就容易引起运行其内的数据库丢失数据\",{\"1\":{\"39\":1}}],[\"一旦你调用了\",{\"1\":{\"11\":1}}],[\"一旦\",{\"1\":{\"11\":1,\"63\":1}}],[\"一经删除后\",{\"1\":{\"10\":1}}],[\"一大堆外行或者并没有深刻理解软件工程的从业者\",{\"1\":{\"0\":1}}],[\"日志和恢复\",{\"0\":{\"38\":1,\"39\":1}}],[\"日志记录\",{\"1\":{\"6\":1}}],[\"日志管理器\",{\"1\":{\"5\":1,\"6\":1,\"11\":1}}],[\"日志\",{\"0\":{\"40\":1},\"1\":{\"5\":3,\"65\":1}}],[\"负责将消耗时间告诉\",{\"1\":{\"64\":1}}],[\"负责将队列中的报文拿出来\",{\"1\":{\"64\":1}}],[\"负责将\",{\"1\":{\"64\":1}}],[\"负责从输出流中读取数据并打包为\",{\"1\":{\"63\":1}}],[\"负责从输出流中读取数据并打包发送\",{\"1\":{\"63\":1}}],[\"负责接收和缓存\",{\"1\":{\"63\":1}}],[\"负责接收报文工作\",{\"1\":{\"64\":1}}],[\"负责接收报文\",{\"1\":{\"58\":1,\"62\":1}}],[\"负责对报文数据进行重组\",{\"1\":{\"58\":1}}],[\"负责对维护事务与数据表记录之间的锁联系\",{\"1\":{\"35\":1}}],[\"负责重组\",{\"1\":{\"58\":1}}],[\"负责发送报文\",{\"1\":{\"58\":1}}],[\"负责维护连接\",{\"1\":{\"58\":1}}],[\"负责维护\",{\"1\":{\"11\":1}}],[\"负责缓存数据页\",{\"1\":{\"11\":1}}],[\"负责分配缓存池的组件被称为缓存管理器\",{\"1\":{\"9\":1}}],[\"负责向磁盘写数据页\",{\"1\":{\"5\":1}}],[\"负责执行查询\",{\"1\":{\"5\":1}}],[\"due\",{\"1\":{\"73\":1}}],[\"duplex\",{\"1\":{\"49\":1}}],[\"durability\",{\"1\":{\"30\":1}}],[\"dbms\",{\"1\":{\"39\":1}}],[\"doesn\",{\"1\":{\"64\":1}}],[\"done\",{\"1\":{\"65\":2}}],[\"don\",{\"1\":{\"63\":1}}],[\"double\",{\"1\":{\"45\":3,\"63\":1}}],[\"do\",{\"1\":{\"26\":1,\"36\":1}}],[\"d\",{\"1\":{\"19\":5,\"20\":3}}],[\"data\",{\"1\":{\"16\":1,\"17\":1,\"41\":1,\"60\":4,\"61\":10,\"62\":3,\"64\":4,\"73\":2,\"74\":1}}],[\"database\",{\"0\":{\"69\":1,\"79\":1},\"1\":{\"3\":1,\"7\":1,\"12\":1,\"22\":2,\"27\":1,\"37\":1,\"42\":2}}],[\"derivative\",{\"1\":{\"72\":2}}],[\"demand\",{\"0\":{\"70\":1}}],[\"debug\",{\"1\":{\"60\":1,\"65\":20}}],[\"designate\",{\"1\":{\"72\":1}}],[\"destination\",{\"1\":{\"65\":1}}],[\"destroyed\",{\"1\":{\"35\":1}}],[\"desc\",{\"1\":{\"45\":3}}],[\"descriptorpool\",{\"1\":{\"45\":1}}],[\"descriptor\",{\"1\":{\"45\":8}}],[\"descript\",{\"1\":{\"45\":1}}],[\"deserializelogrecord\",{\"1\":{\"41\":1}}],[\"detection\",{\"1\":{\"35\":3}}],[\"deadlock\",{\"1\":{\"35\":1}}],[\"default\",{\"1\":{\"26\":2,\"36\":1,\"45\":1}}],[\"define\",{\"1\":{\"16\":3,\"45\":3}}],[\"delete\",{\"1\":{\"26\":1,\"40\":2,\"41\":1}}],[\"deleteoldrootpage\",{\"1\":{\"19\":1}}],[\"deletepage\",{\"1\":{\"11\":3}}],[\"deletepageimpl\",{\"1\":{\"11\":2}}],[\"deletion\",{\"1\":{\"19\":1}}],[\"different\",{\"1\":{\"74\":1}}],[\"difficult\",{\"1\":{\"70\":1}}],[\"divide\",{\"1\":{\"73\":1}}],[\"didn\",{\"1\":{\"69\":1}}],[\"dispatched\",{\"1\":{\"72\":1}}],[\"dispatch\",{\"0\":{\"72\":1},\"1\":{\"73\":1}}],[\"distance\",{\"1\":{\"62\":1}}],[\"diskmanager\",{\"1\":{\"11\":1,\"40\":1,\"41\":1}}],[\"disk\",{\"1\":{\"5\":1,\"6\":1,\"11\":8,\"40\":3,\"41\":3}}],[\"dirty\",{\"1\":{\"11\":10,\"31\":1}}],[\"避免被\",{\"1\":{\"11\":1}}],[\"避免每次查询\",{\"1\":{\"5\":1}}],[\"避免抄袭\",{\"1\":{\"3\":1}}],[\"缓冲池策略\",{\"1\":{\"39\":1}}],[\"缓冲池管理器\",{\"1\":{\"26\":1}}],[\"缓冲池是如何实现的\",{\"1\":{\"3\":1}}],[\"缓存发送但没有被确认的报文\",{\"1\":{\"63\":1}}],[\"缓存的淘汰策略就名存实亡了\",{\"1\":{\"11\":1}}],[\"缓存中没有\",{\"1\":{\"11\":1}}],[\"缓存中已有\",{\"1\":{\"11\":1}}],[\"缓存池中的页\",{\"1\":{\"11\":1}}],[\"缓存池中的基本单位是页\",{\"1\":{\"9\":1}}],[\"缓存池大小\",{\"1\":{\"11\":2}}],[\"缓存池\",{\"0\":{\"8\":1,\"9\":1},\"1\":{\"6\":2,\"9\":1}}],[\"缓存模块\",{\"1\":{\"6\":1}}],[\"缓存淘汰等操作\",{\"1\":{\"5\":1}}],[\"缓存管理器是内存\",{\"1\":{\"11\":1}}],[\"缓存管理器内存\",{\"1\":{\"11\":1}}],[\"缓存管理器负责将新数据页刷新到磁盘中\",{\"1\":{\"11\":1}}],[\"缓存管理器负责协同内存\",{\"1\":{\"11\":1}}],[\"缓存管理器会调用\",{\"1\":{\"10\":1}}],[\"缓存管理器会将其从缓存池中淘汰\",{\"1\":{\"10\":1}}],[\"缓存管理器判断数据页是否已在缓存中\",{\"1\":{\"5\":1}}],[\"缓存管理器\",{\"0\":{\"11\":1},\"1\":{\"5\":1}}],[\"中还有\",{\"1\":{\"66\":1}}],[\"中定时写入数据\",{\"1\":{\"65\":1}}],[\"中读取数据\",{\"1\":{\"65\":1}}],[\"中拿出包\",{\"1\":{\"64\":1}}],[\"中无数据发送且也无需发送空包\",{\"1\":{\"64\":1}}],[\"中有\",{\"1\":{\"64\":1}}],[\"中有多少页\",{\"1\":{\"10\":1}}],[\"中最复杂\",{\"1\":{\"61\":1}}],[\"中最重要的\",{\"1\":{\"60\":1}}],[\"中交付给应用程序\",{\"1\":{\"61\":1}}],[\"中几个重要的实现方法加以说明\",{\"1\":{\"60\":1}}],[\"中通过\",{\"1\":{\"40\":1}}],[\"中保存了\",{\"1\":{\"35\":1}}],[\"中也可以通过\",{\"1\":{\"32\":1}}],[\"中不会实现\",{\"1\":{\"24\":1}}],[\"中指向\",{\"1\":{\"19\":1}}],[\"中新增了指向\",{\"1\":{\"18\":1}}],[\"中用于保存键值对的字段是\",{\"1\":{\"16\":1}}],[\"中删除\",{\"1\":{\"11\":1,\"19\":1}}],[\"中没有则淘汰一个页\",{\"1\":{\"11\":2}}],[\"中由\",{\"1\":{\"11\":1}}],[\"中\",{\"1\":{\"10\":1,\"11\":2,\"16\":1,\"18\":1,\"19\":2,\"29\":1,\"32\":1,\"58\":2,\"61\":1,\"62\":1,\"65\":1}}],[\"中加入需要被淘汰的页\",{\"1\":{\"10\":1}}],[\"中的包\",{\"1\":{\"63\":2}}],[\"中的报文如何被确认\",{\"1\":{\"63\":1}}],[\"中的报文\",{\"1\":{\"63\":1}}],[\"中的报文需要通过接受到的\",{\"1\":{\"63\":1}}],[\"中的字节数\",{\"1\":{\"62\":1}}],[\"中的一些选项均不支持\",{\"1\":{\"57\":1}}],[\"中的三个核心方法伪代码如下\",{\"1\":{\"10\":1}}],[\"中的\",{\"1\":{\"10\":1,\"11\":1,\"26\":1,\"58\":2,\"61\":1,\"62\":1,\"63\":1}}],[\"中的箭头所示\",{\"1\":{\"5\":1}}],[\"中的查询处理\",{\"1\":{\"5\":1}}],[\"中文名\",{\"1\":{\"3\":1}}],[\"其实很简单\",{\"1\":{\"64\":1}}],[\"其实就是字节流还能接收多少字节\",{\"1\":{\"62\":1}}],[\"其他异常类型\",{\"1\":{\"45\":1}}],[\"其他操作\",{\"1\":{\"20\":1}}],[\"其代码如下\",{\"1\":{\"45\":1}}],[\"其对比如下图所示\",{\"1\":{\"45\":1}}],[\"其变更才能被其它事务看到\",{\"1\":{\"31\":1}}],[\"其变更就能被其它事务看到\",{\"1\":{\"31\":1}}],[\"其定义如下\",{\"1\":{\"25\":1,\"26\":1}}],[\"其核心\",{\"1\":{\"26\":1}}],[\"其核心实现如下\",{\"1\":{\"26\":1}}],[\"其核心其实都是\",{\"1\":{\"26\":1}}],[\"其核心字段有两个\",{\"1\":{\"26\":1}}],[\"其核心思想是\",{\"1\":{\"25\":1}}],[\"其核心伪代码如下\",{\"1\":{\"20\":1}}],[\"其父节点\",{\"1\":{\"19\":1}}],[\"其兄弟节点\",{\"1\":{\"19\":1}}],[\"其大小为\",{\"1\":{\"19\":1}}],[\"其内部的\",{\"1\":{\"16\":1}}],[\"其中\",{\"1\":{\"16\":1,\"63\":1}}],[\"其\",{\"1\":{\"15\":1}}],[\"其它情况下\",{\"1\":{\"63\":1}}],[\"其它事物不可读\",{\"1\":{\"33\":1}}],[\"其它事务可读\",{\"1\":{\"33\":1}}],[\"其它执行器的实现这里就不再赘述了\",{\"1\":{\"26\":1}}],[\"其它\",{\"1\":{\"24\":1}}],[\"其它方法\",{\"1\":{\"11\":1}}],[\"其它部分只会用画图的方式来说明\",{\"1\":{\"3\":1}}],[\"其本质为一个\",{\"1\":{\"11\":1}}],[\"其着重点在于数据库后端部分\",{\"1\":{\"5\":1}}],[\"架构图\",{\"1\":{\"5\":1}}],[\"图中的节点是事务\",{\"1\":{\"34\":1}}],[\"图\",{\"1\":{\"5\":1,\"11\":2,\"15\":4,\"16\":1,\"18\":5,\"19\":6,\"20\":2,\"26\":1,\"34\":1}}],[\"图数据库\",{\"1\":{\"3\":1}}],[\"模块之间如何协调\",{\"1\":{\"5\":1}}],[\"究竟有哪些模块\",{\"1\":{\"5\":1}}],[\"整体架构后\",{\"1\":{\"6\":1}}],[\"整体架构图如下\",{\"1\":{\"5\":1}}],[\"整体架构\",{\"0\":{\"5\":1}}],[\"为对\",{\"1\":{\"65\":1}}],[\"为空\",{\"1\":{\"63\":1}}],[\"为最后一个重组的字节序号\",{\"1\":{\"62\":1}}],[\"为什么需要看做为\",{\"1\":{\"63\":1}}],[\"为什么会存在脏读\",{\"1\":{\"32\":1}}],[\"为什么要这么设计\",{\"1\":{\"3\":1}}],[\"为例\",{\"1\":{\"26\":1}}],[\"为内部节点\",{\"1\":{\"18\":1}}],[\"为叶子节点\",{\"1\":{\"18\":1}}],[\"为\",{\"1\":{\"11\":1,\"16\":3,\"31\":1,\"61\":2,\"64\":5}}],[\"为参数调用\",{\"1\":{\"11\":1}}],[\"为了解决这个问题\",{\"1\":{\"62\":1}}],[\"为了解决这些问题\",{\"1\":{\"31\":1,\"61\":1}}],[\"为了避免引入\",{\"1\":{\"57\":1}}],[\"为了与其它协议进行区分\",{\"1\":{\"57\":1}}],[\"为了保证数据传输的可靠性\",{\"1\":{\"52\":1}}],[\"为了保护课程\",{\"1\":{\"3\":1}}],[\"为了支持各类查询计划\",{\"1\":{\"26\":1}}],[\"为了仍然保证\",{\"1\":{\"18\":1}}],[\"为了达到这个目标\",{\"1\":{\"9\":1}}],[\"为避免物理机突然崩溃\",{\"1\":{\"5\":1}}],[\"课程实验\",{\"1\":{\"3\":1}}],[\"是比较麻烦\",{\"1\":{\"64\":1}}],[\"是比较简单的\",{\"1\":{\"64\":1}}],[\"是窗口中待确认的字节数量大小\",{\"1\":{\"63\":1}}],[\"是接收者最复杂的函数\",{\"1\":{\"62\":1}}],[\"是发送者随机生成的数字\",{\"1\":{\"62\":1}}],[\"是第一个\",{\"1\":{\"61\":1}}],[\"是按照\",{\"1\":{\"61\":1}}],[\"是学习\",{\"1\":{\"49\":1}}],[\"是如何来支持事务的呢\",{\"1\":{\"36\":1}}],[\"是通过\",{\"1\":{\"29\":1,\"32\":1}}],[\"是字段名称\",{\"1\":{\"26\":1,\"36\":1}}],[\"是字段值\",{\"1\":{\"26\":1,\"36\":1}}],[\"是一门好课\",{\"1\":{\"66\":1}}],[\"是一个可读且可写且有容量限制的数据流\",{\"1\":{\"60\":1}}],[\"是一个可靠的\",{\"1\":{\"49\":1}}],[\"是一个基于内存\",{\"1\":{\"60\":1}}],[\"是一种常见的数据序列化方式\",{\"1\":{\"45\":1}}],[\"是一种并发控制协议\",{\"1\":{\"32\":1}}],[\"是一条记录\",{\"1\":{\"26\":1,\"36\":1}}],[\"是一棵\",{\"1\":{\"18\":1,\"19\":1}}],[\"是所有执行计划的父类\",{\"1\":{\"25\":1}}],[\"是叶子结点\",{\"1\":{\"19\":1}}],[\"是根节点\",{\"1\":{\"19\":2}}],[\"是右半部分\",{\"1\":{\"18\":1}}],[\"是内部节点\",{\"1\":{\"16\":1,\"19\":1}}],[\"是对叶子节点和内部节点的抽象\",{\"1\":{\"16\":1}}],[\"是否需要发送空包\",{\"1\":{\"64\":1}}],[\"是否需要合并或者重组\",{\"1\":{\"19\":1}}],[\"是否在数据流结束后等待\",{\"1\":{\"64\":1}}],[\"是否处于激活状态\",{\"1\":{\"64\":1}}],[\"是否收到了\",{\"1\":{\"61\":1}}],[\"是否为\",{\"1\":{\"11\":1}}],[\"是否脏页\",{\"1\":{\"11\":2}}],[\"是页在内存中暂时的\",{\"1\":{\"11\":1}}],[\"是空闲页列表\",{\"1\":{\"11\":1}}],[\"是数据列\",{\"1\":{\"26\":1,\"36\":1}}],[\"是数据页在磁盘上的标识\",{\"1\":{\"11\":1}}],[\"是数据页在内存中的标识\",{\"1\":{\"11\":1}}],[\"是数据库性能提升的核心组件\",{\"1\":{\"5\":1}}],[\"是目前最常见的页面置换算法\",{\"1\":{\"10\":1}}],[\"是\",{\"1\":{\"3\":1,\"16\":1,\"19\":1,\"58\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1}}],[\"注意定时器在包进入\",{\"1\":{\"63\":1}}],[\"注意不是所有过期的包\",{\"1\":{\"63\":1}}],[\"注意报文大小是有限制的\",{\"1\":{\"63\":1}}],[\"注意是尝试\",{\"1\":{\"64\":1}}],[\"注意是\",{\"1\":{\"62\":1}}],[\"注意是字节流的序号\",{\"1\":{\"61\":1}}],[\"注意所有数据都被合并到了\",{\"1\":{\"61\":1}}],[\"注意写入数据的大小和当前缓冲区的大小加起来不能超过容量大小\",{\"1\":{\"60\":1}}],[\"注意\",{\"1\":{\"3\":1,\"11\":1,\"20\":1,\"24\":1,\"60\":1,\"62\":1,\"63\":3,\"64\":1}}],[\"想要尝试从源码级别上来搞懂这几个问题\",{\"1\":{\"3\":1}}],[\"的一个字条件\",{\"1\":{\"64\":1}}],[\"的队列中拿出\",{\"1\":{\"64\":1}}],[\"的包\",{\"1\":{\"64\":2}}],[\"的字段比较少\",{\"1\":{\"64\":1}}],[\"的时候\",{\"1\":{\"63\":1}}],[\"的实现稍微复杂一些\",{\"1\":{\"63\":1}}],[\"的真正关闭条件\",{\"1\":{\"62\":1}}],[\"的真正长度由\",{\"1\":{\"16\":1}}],[\"的核心函数有三个\",{\"1\":{\"62\":1}}],[\"的核心点在于最近\",{\"1\":{\"10\":1}}],[\"的定义中添加了\",{\"1\":{\"61\":1}}],[\"的定义如下\",{\"1\":{\"20\":1}}],[\"的长度不能超过\",{\"1\":{\"60\":1}}],[\"的数据流图如下所示\",{\"1\":{\"58\":1}}],[\"的数组实则可以任意扩容\",{\"1\":{\"16\":1}}],[\"的课程带领下\",{\"1\":{\"57\":1}}],[\"的特点\",{\"1\":{\"50\":1}}],[\"的资料很多\",{\"1\":{\"49\":1}}],[\"的函数\",{\"1\":{\"45\":1}}],[\"的函数获取\",{\"1\":{\"16\":1}}],[\"的进程间通信结构\",{\"1\":{\"45\":1}}],[\"的崩溃恢复必须先\",{\"1\":{\"41\":1}}],[\"的处理其实是比较粗糙的\",{\"1\":{\"41\":1}}],[\"的图\",{\"1\":{\"34\":1}}],[\"的同时\",{\"1\":{\"33\":1}}],[\"的锁\",{\"1\":{\"20\":4}}],[\"的开始项移到\",{\"1\":{\"19\":1}}],[\"的最前面\",{\"1\":{\"19\":1}}],[\"的叶子结点\",{\"1\":{\"19\":1,\"20\":1}}],[\"的兄弟节点\",{\"1\":{\"19\":1}}],[\"的节点数据写入字节流中\",{\"1\":{\"61\":1}}],[\"的节点\",{\"1\":{\"19\":1,\"61\":3}}],[\"的情况下\",{\"1\":{\"63\":2,\"64\":1,\"65\":1}}],[\"的情况\",{\"1\":{\"19\":1}}],[\"的子节点个数+1\",{\"1\":{\"18\":1}}],[\"的指针\",{\"1\":{\"18\":1,\"19\":2}}],[\"的末尾\",{\"1\":{\"18\":1}}],[\"的插入点正好在节点\",{\"1\":{\"18\":1}}],[\"的父节点\",{\"1\":{\"18\":3,\"19\":1}}],[\"的父节点子节点个数\",{\"1\":{\"18\":1}}],[\"的父类\",{\"1\":{\"16\":1}}],[\"的基本单位是页\",{\"1\":{\"16\":1}}],[\"的基本单位也是页\",{\"1\":{\"9\":1}}],[\"的值类型为\",{\"1\":{\"16\":1}}],[\"的含义\",{\"1\":{\"15\":1}}],[\"的元数据\",{\"1\":{\"11\":2}}],[\"的页是脏的\",{\"1\":{\"11\":2}}],[\"的主要作用点在于操作数据页\",{\"1\":{\"11\":1}}],[\"的意义在于\",{\"1\":{\"11\":1}}],[\"的流程就如图\",{\"1\":{\"5\":1}}],[\"的\",{\"1\":{\"3\":1,\"17\":1,\"18\":1,\"20\":1,\"35\":1,\"63\":1,\"64\":1}}],[\"block\",{\"0\":{\"73\":1},\"1\":{\"70\":1,\"72\":2,\"73\":7}}],[\"blocked\",{\"1\":{\"35\":1}}],[\"bind\",{\"1\":{\"65\":1}}],[\"bdwms\",{\"1\":{\"37\":1}}],[\"break\",{\"1\":{\"35\":1,\"36\":6,\"45\":3,\"61\":4,\"63\":1}}],[\"best\",{\"1\":{\"74\":2}}],[\"benchmark\",{\"1\":{\"65\":2}}],[\"before\",{\"1\":{\"64\":1}}],[\"between\",{\"1\":{\"62\":1}}],[\"been\",{\"1\":{\"62\":1,\"63\":1,\"64\":3,\"65\":2}}],[\"be\",{\"0\":{\"72\":1},\"1\":{\"35\":3,\"63\":1,\"64\":3,\"70\":2,\"72\":1,\"73\":4}}],[\"begin\",{\"1\":{\"26\":1,\"32\":2,\"36\":1,\"60\":4,\"61\":14}}],[\"bytes\",{\"1\":{\"60\":4,\"61\":5,\"62\":2,\"63\":3,\"64\":2}}],[\"bytestream\",{\"0\":{\"60\":1},\"1\":{\"58\":2,\"59\":3,\"60\":15,\"61\":2,\"63\":1}}],[\"byte\",{\"1\":{\"49\":1,\"59\":2,\"61\":1,\"62\":2,\"63\":1,\"64\":1,\"65\":2}}],[\"by\",{\"1\":{\"34\":2,\"64\":2,\"65\":1,\"69\":1}}],[\"base\",{\"1\":{\"73\":1}}],[\"based\",{\"1\":{\"70\":1,\"72\":1,\"73\":1}}],[\"batch\",{\"1\":{\"25\":1}}],[\"back\",{\"1\":{\"10\":1,\"11\":1,\"25\":1,\"26\":1,\"35\":2,\"36\":1,\"63\":1}}],[\"b1\",{\"1\":{\"18\":2}}],[\"b\",{\"1\":{\"18\":7,\"19\":9,\"20\":8,\"26\":1,\"31\":3,\"61\":6,\"64\":1}}],[\"bound\",{\"1\":{\"61\":4}}],[\"both\",{\"1\":{\"16\":1,\"64\":2}}],[\"bool\",{\"1\":{\"10\":2,\"11\":8,\"18\":2,\"25\":1,\"26\":3,\"35\":1,\"36\":1,\"40\":1,\"41\":1,\"45\":4,\"61\":2,\"62\":1,\"63\":1,\"64\":6}}],[\"bool类型等\",{\"1\":{\"6\":1}}],[\"bplustreepage\",{\"1\":{\"16\":3}}],[\"bplustreeinternalpage\",{\"1\":{\"16\":3}}],[\"bplustreeinternalpage<keytype\",{\"1\":{\"16\":1}}],[\"bplustreeleafpage\",{\"1\":{\"16\":2}}],[\"bplustreeleafpage<keytype\",{\"1\":{\"16\":1}}],[\"bplustree<generickey<8>\",{\"1\":{\"16\":1}}],[\"bplustree\",{\"1\":{\"16\":11,\"20\":1}}],[\"b+tree\",{\"1\":{\"22\":1}}],[\"b+操作中最复杂的一部分\",{\"1\":{\"19\":1}}],[\"b+的一条性质\",{\"1\":{\"15\":1}}],[\"b+\",{\"1\":{\"15\":2,\"22\":1}}],[\"b+树可用于存储索引\",{\"1\":{\"29\":1}}],[\"b+树可以满足单线程下任意读写\",{\"1\":{\"20\":1}}],[\"b+树可以拥有多个子节点\",{\"1\":{\"15\":1}}],[\"b+树这一节中\",{\"1\":{\"29\":1}}],[\"b+树支持多线程并发访问\",{\"1\":{\"20\":1}}],[\"b+树该如何支持并发访问了\",{\"1\":{\"20\":1}}],[\"b+树已被清空\",{\"1\":{\"19\":1}}],[\"b+树删除是\",{\"1\":{\"19\":1}}],[\"b+树删除\",{\"0\":{\"19\":1}}],[\"b+树性质\",{\"1\":{\"18\":1}}],[\"b+树节点最多只能拥有\",{\"1\":{\"18\":1}}],[\"b+树节点可分为内部节点\",{\"1\":{\"16\":1}}],[\"b+树插入对外暴露\",{\"1\":{\"18\":1}}],[\"b+树插入伪代码如下\",{\"1\":{\"18\":1}}],[\"b+树插入会复杂一些\",{\"1\":{\"18\":1}}],[\"b+树插入\",{\"0\":{\"18\":1}}],[\"b+树将所有值存储在了叶子结点中\",{\"1\":{\"17\":1}}],[\"b+树中查询\",{\"1\":{\"20\":1}}],[\"b+树中插入数据\",{\"1\":{\"18\":1}}],[\"b+树中搜索函数\",{\"1\":{\"17\":1}}],[\"b+树中最简单的部分\",{\"1\":{\"17\":1}}],[\"b+树中只有叶子结点才会存储真正的数据\",{\"1\":{\"15\":1}}],[\"b+树一番介绍后\",{\"1\":{\"17\":1}}],[\"b+树一个节点究竟能存储多少项\",{\"1\":{\"3\":1}}],[\"b+树搜索是如何实现的\",{\"1\":{\"17\":1}}],[\"b+树搜索\",{\"0\":{\"17\":1}}],[\"b+树类图\",{\"1\":{\"16\":1}}],[\"b+树结构类图如图\",{\"1\":{\"16\":1}}],[\"b+树在插入数据时\",{\"1\":{\"18\":1}}],[\"b+树在搜索时\",{\"1\":{\"17\":1}}],[\"b+树在代码中被抽象定义为\",{\"1\":{\"16\":1}}],[\"b+树在关系数据库上的重要性不言而喻\",{\"1\":{\"14\":1}}],[\"b+树的搜索\",{\"1\":{\"16\":1}}],[\"b+树的抽象非常优美\",{\"1\":{\"16\":1}}],[\"b+树的实现\",{\"1\":{\"16\":1}}],[\"b+树实现之前\",{\"1\":{\"16\":1}}],[\"b+树实现花了大量篇幅\",{\"1\":{\"16\":1}}],[\"b+树实现及并发\",{\"1\":{\"6\":1}}],[\"b+树后\",{\"1\":{\"16\":1}}],[\"b+树设计\",{\"0\":{\"16\":1}}],[\"b+树查询数据\",{\"1\":{\"15\":1}}],[\"b+树包括根节点\",{\"1\":{\"15\":1}}],[\"b+树是一种多路自平衡树\",{\"1\":{\"15\":1}}],[\"b+树定义\",{\"0\":{\"15\":1}}],[\"b+树或其变种\",{\"1\":{\"14\":1}}],[\"b+树\",{\"0\":{\"14\":1},\"1\":{\"6\":2,\"14\":1,\"15\":4,\"18\":2,\"19\":1,\"21\":2,\"24\":1,\"29\":1}}],[\"b+树又是如何支持并发访问的\",{\"1\":{\"3\":1}}],[\"b+树似乎是数据库组织数据的最常用数据结构\",{\"1\":{\"3\":1}}],[\"but\",{\"1\":{\"63\":1}}],[\"buildwaitsforgraph\",{\"1\":{\"35\":2}}],[\"built\",{\"1\":{\"35\":1}}],[\"bug\",{\"1\":{\"21\":1}}],[\"bufferlist\",{\"1\":{\"60\":3}}],[\"bufferpoolmanager\",{\"1\":{\"11\":12,\"16\":3,\"26\":1,\"41\":1}}],[\"buffer\",{\"0\":{\"68\":1,\"69\":1},\"1\":{\"5\":1,\"6\":2,\"9\":1,\"12\":2,\"16\":1,\"17\":2,\"18\":2,\"40\":9,\"41\":7,\"60\":13,\"62\":2,\"63\":1,\"70\":1,\"72\":1,\"73\":1}}],[\"bustub\",{\"1\":{\"3\":4,\"5\":8,\"6\":1,\"10\":1,\"11\":1,\"16\":1,\"24\":1,\"25\":2,\"26\":4,\"29\":1,\"32\":2,\"36\":1,\"40\":1,\"41\":3}}],[\"它表示流结束后是否需要等待\",{\"1\":{\"64\":1}}],[\"它接受三个参数\",{\"1\":{\"61\":1}}],[\"它能保证数据库即使在故障发生的情况下\",{\"1\":{\"39\":1}}],[\"它会选择一个事务回滚以打破循环等待\",{\"1\":{\"34\":1}}],[\"它可由多个数据库操作组成\",{\"1\":{\"30\":1}}],[\"它包括如下几类操作\",{\"1\":{\"24\":1}}],[\"它最少只需有\",{\"1\":{\"15\":1}}],[\"它有何作用\",{\"1\":{\"3\":1}}],[\"它又是如何实现的\",{\"1\":{\"3\":2}}],[\"这是三次握手的第一步\",{\"1\":{\"65\":1}}],[\"这表示远端已经发送了\",{\"1\":{\"64\":1}}],[\"这两个函数都与连接关闭有直接关系\",{\"1\":{\"64\":1}}],[\"这两个工具\",{\"1\":{\"56\":1}}],[\"这才是\",{\"1\":{\"62\":1}}],[\"这几乎是不可能达成的目标\",{\"1\":{\"62\":1}}],[\"这代表\",{\"1\":{\"62\":1}}],[\"这段代码展示了\",{\"1\":{\"60\":1}}],[\"这主要取决于滑动窗口大下\",{\"1\":{\"53\":1}}],[\"这门课\",{\"1\":{\"49\":1}}],[\"这也导致了\",{\"1\":{\"49\":1}}],[\"这也有今天的主角\",{\"1\":{\"3\":1}}],[\"这取决于具体情况\",{\"1\":{\"34\":1}}],[\"这个变量需要额外说明一下\",{\"1\":{\"64\":1}}],[\"这个包可能为空包\",{\"1\":{\"64\":1}}],[\"这个地方的\",{\"1\":{\"62\":1}}],[\"这个过程被称为\",{\"1\":{\"35\":1}}],[\"这个概念\",{\"1\":{\"31\":1}}],[\"这个精巧的关系数据库来告诉你\",{\"1\":{\"3\":1}}],[\"这次删除操作才能释放所有节点上的锁\",{\"1\":{\"20\":1}}],[\"这样就能保证一个叶子节点数据刚好能够存储在一个页中\",{\"1\":{\"16\":1}}],[\"这样就能最大程度的利用缓存\",{\"1\":{\"11\":1}}],[\"这样\",{\"1\":{\"16\":1}}],[\"这条规则被称为半满\",{\"1\":{\"15\":1}}],[\"这棵\",{\"1\":{\"15\":1}}],[\"这里额外说明几点\",{\"1\":{\"63\":1}}],[\"这里额外说明一下\",{\"1\":{\"62\":1,\"64\":1}}],[\"这里的\",{\"1\":{\"62\":1}}],[\"这里的查询操作\",{\"1\":{\"24\":1}}],[\"这里需要额外说明一点\",{\"1\":{\"62\":1}}],[\"这里需要额外说明的是\",{\"1\":{\"11\":1}}],[\"这里摘出\",{\"1\":{\"60\":1}}],[\"这里先给出\",{\"1\":{\"59\":1}}],[\"这里也不做介绍\",{\"1\":{\"24\":1}}],[\"这里就不展开讲了\",{\"1\":{\"66\":1}}],[\"这里就不展示相关的伪代码了\",{\"1\":{\"20\":1}}],[\"这里就不再赘述了\",{\"1\":{\"11\":1}}],[\"这里利用了\",{\"1\":{\"16\":1}}],[\"这里我们先简单的来介绍一下\",{\"1\":{\"14\":1}}],[\"这里我们来详细介绍\",{\"1\":{\"10\":1}}],[\"这里贴出笔者实现的伪代码\",{\"1\":{\"11\":1}}],[\"这里\",{\"1\":{\"10\":1,\"11\":1}}],[\"这些细节后面会在实现中详细介绍\",{\"1\":{\"51\":1}}],[\"这些本文不做讨论\",{\"1\":{\"20\":1}}],[\"这些元数据被抽象为了\",{\"1\":{\"16\":1}}],[\"这些模块将按照如下顺序依次介绍\",{\"1\":{\"6\":1}}],[\"这些模块负责哪些功能\",{\"1\":{\"5\":1}}],[\"这些将在后面详细介绍\",{\"1\":{\"5\":1}}],[\"这三部分又包含了数据库很多模块\",{\"1\":{\"5\":1}}],[\"如默认超时时间\",{\"1\":{\"64\":1}}],[\"如磁盘故障\",{\"1\":{\"39\":1}}],[\"如全表扫描\",{\"1\":{\"26\":1}}],[\"如数据更新\",{\"1\":{\"24\":1}}],[\"如数据列\",{\"1\":{\"6\":1}}],[\"如表遍历\",{\"1\":{\"24\":1}}],[\"如需对\",{\"1\":{\"15\":1}}],[\"如图所示\",{\"1\":{\"34\":1}}],[\"如图中内部节点的第一个空键\",{\"1\":{\"15\":1}}],[\"如图\",{\"1\":{\"15\":1,\"18\":4,\"19\":4,\"20\":3}}],[\"如有直接获取空闲页\",{\"1\":{\"11\":1}}],[\"如缓存中没有\",{\"1\":{\"11\":1}}],[\"如缓存管理器\",{\"1\":{\"6\":1}}],[\"如\",{\"1\":{\"11\":1,\"14\":1,\"16\":2,\"24\":1,\"26\":3,\"31\":1,\"57\":1,\"58\":1,\"64\":1}}],[\"如果填充后仍然为空\",{\"1\":{\"64\":1}}],[\"如果处于\",{\"1\":{\"64\":2}}],[\"如果报文重试次数超过了\",{\"1\":{\"64\":1}}],[\"如果报文头部中含有\",{\"1\":{\"64\":1}}],[\"如果报文头部含有\",{\"1\":{\"64\":1}}],[\"如果报文头部序号\",{\"1\":{\"63\":1}}],[\"如果收到的报文的长度\",{\"1\":{\"64\":1}}],[\"如果定时器没有开启\",{\"1\":{\"63\":1}}],[\"如果发生了超时那么重新发送报文\",{\"1\":{\"63\":1}}],[\"如果发生问题\",{\"1\":{\"32\":1}}],[\"如果新的包被确认\",{\"1\":{\"63\":1}}],[\"如果输出流已经关闭\",{\"1\":{\"63\":1}}],[\"如果包头部序号\",{\"1\":{\"63\":1}}],[\"如果包头部没有\",{\"1\":{\"62\":1}}],[\"如果包长度为\",{\"1\":{\"63\":1}}],[\"如果包的大小小于窗口大小\",{\"1\":{\"63\":1}}],[\"如果该\",{\"1\":{\"62\":1}}],[\"如果该页是脏页\",{\"1\":{\"11\":1}}],[\"如果标记了结束\",{\"1\":{\"61\":1}}],[\"如果超过了默认重试次数\",{\"1\":{\"64\":1}}],[\"如果超过了重试次数\",{\"1\":{\"64\":1}}],[\"如果超过了窗口阈值\",{\"1\":{\"62\":1}}],[\"如果超过了\",{\"1\":{\"61\":1}}],[\"如果超过了最大数量\",{\"1\":{\"10\":1}}],[\"如果数据超过了窗口大小\",{\"1\":{\"60\":1}}],[\"如果使用get\",{\"1\":{\"45\":1}}],[\"如果存在则将事务的状态设置为\",{\"1\":{\"35\":1}}],[\"如果事务\",{\"1\":{\"35\":1}}],[\"如果没有\",{\"1\":{\"64\":1}}],[\"如果没有则返回空\",{\"1\":{\"25\":1}}],[\"如果没有空闲页\",{\"1\":{\"11\":1}}],[\"如果不是叶子节点\",{\"1\":{\"20\":1}}],[\"如果不安全\",{\"1\":{\"20\":1}}],[\"如果在\",{\"1\":{\"64\":1}}],[\"如果在删除的过程中\",{\"1\":{\"20\":1}}],[\"如果在重组或者合并后\",{\"1\":{\"19\":1}}],[\"如果子节点是\",{\"1\":{\"20\":1}}],[\"如果我们在\",{\"1\":{\"20\":1}}],[\"如果为空树则直接返回\",{\"1\":{\"19\":1}}],[\"如果是第一次填充\",{\"1\":{\"63\":1}}],[\"如果是可重复读\",{\"1\":{\"35\":1}}],[\"如果是读未提交\",{\"1\":{\"35\":1}}],[\"如果是查询\",{\"1\":{\"20\":1}}],[\"如果是删除操作\",{\"1\":{\"20\":2}}],[\"如果是插入操作\",{\"1\":{\"20\":1}}],[\"如果是真实环境\",{\"1\":{\"20\":1}}],[\"如果是根节点\",{\"1\":{\"19\":1}}],[\"如果是根节点不必满足半满这个条件\",{\"1\":{\"15\":1}}],[\"如果是一棵空树\",{\"1\":{\"19\":1}}],[\"如果节点之间有数据重合\",{\"1\":{\"61\":1}}],[\"如果节点安全\",{\"1\":{\"20\":1}}],[\"如果节点与兄弟节点加起来大于\",{\"1\":{\"19\":1}}],[\"如果节点\",{\"1\":{\"19\":3}}],[\"如果当前树不为空\",{\"1\":{\"18\":1}}],[\"如果当前仍是空树\",{\"1\":{\"18\":1}}],[\"如果再次分裂后\",{\"1\":{\"18\":1}}],[\"如果根不是叶节点\",{\"1\":{\"15\":1}}],[\"如果\",{\"1\":{\"11\":7,\"19\":2,\"34\":1,\"35\":1,\"61\":2,\"62\":3,\"64\":2}}],[\"如果缓存中已有该页\",{\"1\":{\"11\":1}}],[\"如果你能迅速回答出这几个问题\",{\"1\":{\"3\":1}}],[\"如整型\",{\"1\":{\"6\":1}}],[\"如b+树索引页\",{\"1\":{\"6\":1}}],[\"如快照管理器\",{\"1\":{\"6\":1}}],[\"如查询执行器\",{\"1\":{\"6\":1}}],[\"如事务管理器\",{\"1\":{\"6\":1}}],[\"如下表\",{\"1\":{\"31\":1}}],[\"如下图\",{\"1\":{\"11\":1,\"15\":1,\"19\":1}}],[\"如下\",{\"1\":{\"6\":1,\"16\":2,\"17\":1,\"18\":2,\"19\":2,\"20\":1,\"26\":1,\"33\":2,\"35\":1,\"36\":1,\"51\":1,\"52\":1,\"56\":1,\"61\":3,\"62\":1,\"63\":3,\"64\":2}}],[\"如已在\",{\"1\":{\"5\":1}}],[\"如何随机生成的\",{\"1\":{\"62\":1}}],[\"如何通过执行器来执行\",{\"1\":{\"36\":1}}],[\"如何比较\",{\"1\":{\"16\":1}}],[\"如何数据备份\",{\"1\":{\"3\":1}}],[\"如何用索引\",{\"1\":{\"3\":1}}],[\"如内存数据库\",{\"1\":{\"3\":1}}],[\"甚至去实现一个小巧的数据库\",{\"1\":{\"3\":1}}],[\"掌握数据库系统设计\",{\"1\":{\"3\":1}}],[\"cs\",{\"1\":{\"67\":1}}],[\"cs144\",{\"1\":{\"49\":2,\"57\":2,\"66\":1}}],[\"cpu\",{\"1\":{\"65\":2}}],[\"cpptype\",{\"1\":{\"45\":5}}],[\"cpp\",{\"1\":{\"26\":10}}],[\"cerr\",{\"1\":{\"65\":5}}],[\"cfg\",{\"1\":{\"64\":9}}],[\"c++菜的要死\",{\"1\":{\"62\":1}}],[\"current\",{\"1\":{\"63\":5}}],[\"cur\",{\"1\":{\"61\":20}}],[\"cc\",{\"1\":{\"59\":6}}],[\"client\",{\"1\":{\"65\":1}}],[\"closed\",{\"1\":{\"65\":2}}],[\"cleanly\",{\"1\":{\"64\":1,\"65\":4}}],[\"clean\",{\"1\":{\"64\":5,\"65\":2}}],[\"clear\",{\"1\":{\"35\":2}}],[\"class\",{\"1\":{\"10\":1,\"11\":1,\"16\":4,\"25\":1,\"26\":3,\"40\":1,\"41\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1}}],[\"cycle\",{\"1\":{\"35\":4}}],[\"cv\",{\"1\":{\"35\":2}}],[\"createexecutor\",{\"1\":{\"25\":2}}],[\"crabbing\",{\"0\":{\"20\":1},\"1\":{\"20\":6,\"21\":1}}],[\"ctx\",{\"1\":{\"25\":3,\"26\":10,\"36\":11}}],[\"choose\",{\"0\":{\"72\":1,\"73\":1},\"1\":{\"72\":2,\"73\":1,\"74\":1}}],[\"chosen\",{\"1\":{\"70\":1}}],[\"challenge\",{\"1\":{\"69\":1}}],[\"char\",{\"1\":{\"40\":3,\"41\":2,\"65\":2}}],[\"chrono\",{\"1\":{\"65\":1}}],[\"children\",{\"1\":{\"26\":5}}],[\"child\",{\"1\":{\"20\":6}}],[\"checkpoint\",{\"1\":{\"5\":1,\"62\":2}}],[\"c\",{\"1\":{\"16\":1,\"18\":3,\"19\":8,\"20\":9,\"62\":1,\"65\":11}}],[\"caluculate\",{\"1\":{\"72\":1}}],[\"calculate\",{\"1\":{\"72\":1}}],[\"can\",{\"1\":{\"72\":5,\"73\":2,\"74\":1}}],[\"capacity\",{\"1\":{\"60\":6,\"61\":2,\"62\":3,\"64\":2}}],[\"case\",{\"1\":{\"36\":3,\"45\":15,\"62\":1,\"63\":4,\"64\":7}}],[\"cast<internalpage>\",{\"1\":{\"18\":2}}],[\"cast<internalpage\",{\"1\":{\"16\":1}}],[\"cast<leafpage>\",{\"1\":{\"17\":1,\"18\":2,\"19\":1}}],[\"cast<leafpage\",{\"1\":{\"16\":1}}],[\"cast\",{\"1\":{\"16\":2}}],[\"cat\",{\"1\":{\"62\":1}}],[\"catch\",{\"1\":{\"25\":1,\"65\":2}}],[\"catalog\",{\"1\":{\"6\":1,\"26\":1}}],[\"code\",{\"1\":{\"74\":1}}],[\"cout\",{\"1\":{\"65\":2}}],[\"count\",{\"1\":{\"11\":18,\"45\":1,\"61\":6}}],[\"corresponding\",{\"1\":{\"62\":1}}],[\"corner\",{\"1\":{\"62\":1,\"63\":4,\"64\":6}}],[\"copy\",{\"1\":{\"62\":1}}],[\"cold\",{\"1\":{\"70\":1,\"73\":4}}],[\"col\",{\"1\":{\"26\":2,\"36\":2}}],[\"column\",{\"1\":{\"26\":2,\"36\":2}}],[\"coalesceorredistribute\",{\"1\":{\"19\":3}}],[\"coalesce\",{\"1\":{\"19\":4}}],[\"compared\",{\"1\":{\"72\":1}}],[\"comparator\",{\"1\":{\"16\":2}}],[\"competitors\",{\"1\":{\"70\":1}}],[\"computer\",{\"1\":{\"67\":1}}],[\"com\",{\"1\":{\"37\":2}}],[\"committed\",{\"1\":{\"36\":1}}],[\"commited\",{\"1\":{\"32\":1}}],[\"commit\",{\"1\":{\"32\":2}}],[\"common\",{\"1\":{\"6\":1}}],[\"connected\",{\"1\":{\"65\":1}}],[\"connecting\",{\"1\":{\"65\":1}}],[\"connection\",{\"1\":{\"49\":1,\"56\":2,\"59\":2,\"63\":1,\"64\":3,\"65\":5}}],[\"connect\",{\"1\":{\"65\":5}}],[\"control\",{\"1\":{\"37\":3}}],[\"contains\",{\"1\":{\"10\":2}}],[\"consecutive\",{\"1\":{\"63\":3,\"64\":2}}],[\"consistency\",{\"1\":{\"30\":1}}],[\"construct\",{\"1\":{\"25\":1}}],[\"const\",{\"1\":{\"16\":1,\"25\":1,\"26\":12,\"35\":2,\"36\":1,\"41\":1,\"45\":10,\"60\":8,\"61\":6,\"62\":3,\"63\":3,\"64\":3,\"65\":5}}],[\"concept\",{\"1\":{\"73\":1}}],[\"concepts\",{\"1\":{\"3\":1,\"7\":1,\"12\":1,\"22\":2,\"27\":1,\"37\":1,\"42\":1}}],[\"concatenate\",{\"1\":{\"60\":1}}],[\"concurrency\",{\"1\":{\"6\":2,\"37\":3}}],[\"cmu\",{\"1\":{\"3\":1}}],[\"cmu15445\",{\"1\":{\"3\":2,\"7\":1}}],[\"而输出流没有结束时\",{\"1\":{\"64\":1}}],[\"而在说明具体实现时\",{\"1\":{\"59\":1}}],[\"而在重组\",{\"1\":{\"20\":1}}],[\"而非\",{\"1\":{\"58\":1}}],[\"而这两个工具本身都是在调用\",{\"1\":{\"56\":1}}],[\"而这恰好也是本文主题\",{\"1\":{\"3\":1}}],[\"而planning\",{\"1\":{\"45\":1}}],[\"而且解析速度快\",{\"1\":{\"45\":1}}],[\"而且执行\",{\"1\":{\"36\":1}}],[\"而且锁的粒度可能很大\",{\"1\":{\"20\":1}}],[\"而对于死锁检测\",{\"1\":{\"35\":1}}],[\"而当前事务还未提交\",{\"1\":{\"32\":1}}],[\"而不可重读等问题实际上出现的并不多\",{\"1\":{\"31\":1}}],[\"而串行化能够解决它们\",{\"1\":{\"31\":1}}],[\"而执行器的作用就是按照查询计划来执行查询操作\",{\"1\":{\"24\":1}}],[\"而如果是删除\",{\"1\":{\"20\":1}}],[\"而叶子结点的值类型与\",{\"1\":{\"16\":1}}],[\"而已\",{\"1\":{\"11\":1}}],[\"而\",{\"1\":{\"11\":2,\"16\":1,\"20\":2,\"31\":1,\"34\":1,\"57\":1,\"63\":1,\"64\":1}}],[\"而是希望通过剖许\",{\"1\":{\"3\":1}}],[\"而恰好也有这么一门课程\",{\"1\":{\"3\":1}}],[\"而忽视了从起点出发前\",{\"1\":{\"0\":1}}],[\"slabase\",{\"1\":{\"72\":2}}],[\"sla\",{\"1\":{\"72\":2}}],[\"sleep\",{\"1\":{\"35\":1,\"65\":1}}],[\"smallest\",{\"1\":{\"70\":1,\"72\":1}}],[\"so\",{\"1\":{\"72\":1}}],[\"solution\",{\"0\":{\"71\":1}}],[\"sock\",{\"1\":{\"65\":5}}],[\"socket\",{\"0\":{\"56\":1},\"1\":{\"56\":4,\"65\":13}}],[\"source\",{\"1\":{\"65\":2,\"74\":1}}],[\"successfully\",{\"1\":{\"65\":1}}],[\"success\",{\"1\":{\"65\":2}}],[\"sure\",{\"1\":{\"64\":1}}],[\"substr\",{\"1\":{\"61\":1}}],[\"substring\",{\"1\":{\"61\":2,\"62\":1}}],[\"specific\",{\"1\":{\"73\":1}}],[\"spring\",{\"1\":{\"69\":1}}],[\"space\",{\"1\":{\"62\":1,\"63\":3,\"64\":1}}],[\"spong\",{\"1\":{\"60\":1}}],[\"sponge\",{\"0\":{\"55\":1,\"58\":1,\"59\":1,\"65\":1},\"1\":{\"57\":5,\"58\":6,\"59\":4,\"60\":2,\"61\":1,\"62\":1,\"65\":3,\"66\":2,\"67\":1}}],[\"split\",{\"1\":{\"18\":2}}],[\"syn+ack\",{\"1\":{\"51\":2}}],[\"syn\",{\"1\":{\"51\":3,\"58\":1,\"62\":26,\"63\":11,\"64\":5,\"65\":17}}],[\"system\",{\"1\":{\"3\":1,\"7\":1,\"12\":1,\"22\":2,\"27\":1,\"37\":1,\"42\":1}}],[\"switch\",{\"1\":{\"36\":1,\"45\":1,\"74\":1}}],[\"s\",{\"1\":{\"33\":1,\"62\":1,\"65\":2,\"73\":1}}],[\"shadow\",{\"1\":{\"70\":1,\"72\":1}}],[\"sharing\",{\"0\":{\"68\":1,\"69\":1},\"1\":{\"70\":1}}],[\"shared\",{\"1\":{\"35\":2}}],[\"share\",{\"1\":{\"16\":1,\"35\":1}}],[\"shold\",{\"1\":{\"70\":1}}],[\"should\",{\"1\":{\"35\":4,\"64\":3,\"70\":1,\"72\":2,\"73\":4}}],[\"shutdown\",{\"1\":{\"64\":10,\"65\":2}}],[\"shrinkong\",{\"1\":{\"32\":1}}],[\"shrinking\",{\"1\":{\"32\":3,\"35\":4}}],[\"score\",{\"1\":{\"72\":1}}],[\"scoring\",{\"1\":{\"72\":1}}],[\"scheduling\",{\"1\":{\"70\":2}}],[\"schema\",{\"1\":{\"26\":11,\"36\":1}}],[\"scan\",{\"1\":{\"26\":2}}],[\"simulate\",{\"1\":{\"74\":1}}],[\"since\",{\"1\":{\"63\":2,\"64\":10}}],[\"sibling\",{\"1\":{\"18\":3,\"19\":4}}],[\"sizeof\",{\"1\":{\"16\":1}}],[\"size\",{\"1\":{\"10\":4,\"11\":4,\"16\":12,\"18\":5,\"19\":4,\"20\":3,\"40\":2,\"41\":1,\"58\":2,\"60\":22,\"61\":14,\"62\":10,\"63\":25,\"64\":10,\"65\":1,\"72\":1,\"73\":1}}],[\"server\",{\"1\":{\"65\":1}}],[\"sending\",{\"1\":{\"65\":1}}],[\"send\",{\"1\":{\"63\":2,\"64\":20,\"65\":4}}],[\"sender\",{\"1\":{\"54\":2,\"58\":1,\"59\":2,\"63\":3,\"64\":28,\"65\":1}}],[\"sent\",{\"1\":{\"63\":3,\"64\":3,\"65\":2}}],[\"seg\",{\"1\":{\"62\":8,\"63\":9,\"64\":16,\"65\":2}}],[\"segments\",{\"1\":{\"63\":22,\"64\":9,\"65\":1}}],[\"segment\",{\"1\":{\"58\":2,\"62\":4,\"63\":2,\"64\":29,\"65\":5}}],[\"seqo\",{\"1\":{\"62\":1}}],[\"seqno\",{\"1\":{\"61\":1,\"62\":31,\"63\":12,\"64\":2}}],[\"seq\",{\"1\":{\"26\":1}}],[\"seqscanexecutor\",{\"1\":{\"26\":5,\"36\":2}}],[\"seqscan\",{\"1\":{\"26\":1}}],[\"seqscanplannode\",{\"1\":{\"26\":5}}],[\"sequence\",{\"1\":{\"16\":1,\"62\":1,\"63\":5,\"64\":2}}],[\"select\",{\"1\":{\"26\":2,\"73\":2}}],[\"search\",{\"1\":{\"20\":2}}],[\"sets\",{\"1\":{\"64\":1}}],[\"set<node>\",{\"1\":{\"61\":1}}],[\"set<rid>\",{\"1\":{\"35\":1}}],[\"set读写这些特征\",{\"1\":{\"45\":1}}],[\"setpersistentlsn\",{\"1\":{\"40\":1}}],[\"setparentpageid\",{\"1\":{\"18\":3}}],[\"set\",{\"1\":{\"25\":3,\"35\":4,\"61\":19,\"62\":1,\"64\":5}}],[\"setkeyat\",{\"1\":{\"19\":1}}],[\"sz\",{\"1\":{\"17\":2,\"60\":7,\"61\":6,\"62\":2,\"63\":2,\"64\":2}}],[\"step\",{\"1\":{\"73\":1}}],[\"steal\",{\"1\":{\"39\":1}}],[\"still\",{\"1\":{\"65\":2}}],[\"status\",{\"1\":{\"73\":1}}],[\"state\",{\"1\":{\"64\":7,\"65\":2}}],[\"stay\",{\"1\":{\"64\":1}}],[\"startnewtree\",{\"1\":{\"18\":3}}],[\"startup\",{\"1\":{\"0\":1}}],[\"store\",{\"1\":{\"62\":1}}],[\"storage\",{\"1\":{\"6\":2}}],[\"stopflushthread\",{\"1\":{\"40\":1}}],[\"structure\",{\"1\":{\"62\":1}}],[\"struct\",{\"1\":{\"61\":1}}],[\"streams\",{\"1\":{\"64\":8}}],[\"streambyte\",{\"1\":{\"62\":1}}],[\"streamindex\",{\"1\":{\"62\":1}}],[\"streamreassembler\",{\"0\":{\"61\":1},\"1\":{\"58\":5,\"59\":2,\"61\":7,\"62\":2}}],[\"stream\",{\"1\":{\"49\":1,\"59\":4,\"60\":4,\"61\":1,\"62\":15,\"63\":4,\"64\":12,\"65\":17}}],[\"str\",{\"1\":{\"45\":2,\"60\":3}}],[\"strict\",{\"1\":{\"32\":1}}],[\"string>\",{\"1\":{\"45\":1}}],[\"string\",{\"1\":{\"16\":2,\"45\":6,\"60\":8,\"61\":2,\"62\":2,\"63\":1,\"64\":1,\"65\":1}}],[\"strong\",{\"1\":{\"32\":1}}],[\"st\",{\"1\":{\"17\":6}}],[\"std\",{\"1\":{\"10\":4,\"11\":3,\"16\":2,\"25\":1,\"26\":7,\"35\":5,\"36\":3,\"45\":6,\"60\":1,\"61\":2,\"62\":4,\"63\":4,\"64\":1,\"65\":2}}],[\"src\",{\"1\":{\"6\":1,\"26\":1}}],[\"sql\",{\"1\":{\"3\":2,\"5\":3,\"24\":2,\"26\":1,\"36\":1}}],[\"鲜有去教开发者如何去弄懂数据库系统架构设计\",{\"1\":{\"3\":1}}],[\"博文都数不胜数\",{\"1\":{\"3\":1}}],[\"书籍\",{\"1\":{\"3\":1}}],[\"对数据进行裁剪\",{\"1\":{\"61\":1}}],[\"对报文数据进行重组\",{\"1\":{\"58\":1}}],[\"对超时未确认的报文进行重发\",{\"1\":{\"58\":1}}],[\"对队列加锁\",{\"1\":{\"35\":1}}],[\"对外只暴露一个\",{\"1\":{\"25\":1}}],[\"对语句解析\",{\"1\":{\"24\":1}}],[\"对子节点加独占锁后\",{\"1\":{\"20\":1}}],[\"对其初始化\",{\"1\":{\"18\":1}}],[\"对的最大数量\",{\"1\":{\"16\":1}}],[\"对的数量\",{\"1\":{\"16\":1}}],[\"对\",{\"1\":{\"16\":1,\"20\":2,\"57\":1}}],[\"对于发送但位确认的报文\",{\"1\":{\"63\":1}}],[\"对于可靠性的细节\",{\"1\":{\"52\":1}}],[\"对于超时未能确认的豹纹\",{\"1\":{\"52\":1}}],[\"对于三个事务隔离级别的处理方式如下\",{\"1\":{\"36\":1}}],[\"对于\",{\"1\":{\"20\":1}}],[\"对于重组\",{\"1\":{\"20\":1}}],[\"对于条件\",{\"1\":{\"15\":1}}],[\"对于关系数据库\",{\"1\":{\"3\":1}}],[\"对应的\",{\"1\":{\"62\":1}}],[\"对应的队列\",{\"1\":{\"35\":1}}],[\"对应的锁队列\",{\"1\":{\"35\":1}}],[\"对应的值\",{\"1\":{\"17\":1}}],[\"对应的页数据到\",{\"1\":{\"11\":1}}],[\"对应图中节点里面的数字\",{\"1\":{\"15\":1}}],[\"对应图中的箭头\",{\"1\":{\"15\":1}}],[\"对应\",{\"1\":{\"11\":1}}],[\"对应操作系统\",{\"1\":{\"9\":1}}],[\"对项目整体有一个基本认识\",{\"1\":{\"6\":1}}],[\"对软件社区最大的负面影响就是\",{\"1\":{\"0\":1}}],[\"pedro\",{\"1\":{\"65\":23}}],[\"peer\",{\"1\":{\"64\":3,\"65\":1}}],[\"peek\",{\"1\":{\"60\":7}}],[\"performing\",{\"1\":{\"74\":1}}],[\"permanently\",{\"1\":{\"64\":1}}],[\"persistent\",{\"1\":{\"40\":3}}],[\"pdescriptor\",{\"1\":{\"45\":1}}],[\"pmessage\",{\"1\":{\"45\":2}}],[\"pbtomap\",{\"1\":{\"45\":1}}],[\"pb反射流程如下\",{\"1\":{\"45\":1}}],[\"pb在缩小可读性的基础上\",{\"1\":{\"45\":1}}],[\"pb\",{\"1\":{\"45\":2}}],[\"p=741\",{\"1\":{\"37\":1}}],[\"phase\",{\"1\":{\"37\":1}}],[\"phantom\",{\"1\":{\"31\":1}}],[\"passage\",{\"1\":{\"64\":1}}],[\"payload\",{\"1\":{\"58\":3,\"62\":4,\"63\":4}}],[\"parent\",{\"1\":{\"16\":1,\"18\":11,\"19\":10}}],[\"pair<keytype\",{\"1\":{\"16\":1}}],[\"pages\",{\"1\":{\"10\":2,\"11\":9}}],[\"page\",{\"1\":{\"6\":1,\"11\":102,\"16\":21,\"17\":12,\"18\":12,\"19\":4,\"20\":12,\"70\":1,\"72\":1}}],[\"p\",{\"1\":{\"11\":2,\"37\":1,\"56\":1}}],[\"push\",{\"1\":{\"10\":1,\"11\":1,\"61\":2,\"62\":2,\"63\":1,\"64\":3}}],[\"public\",{\"1\":{\"10\":2,\"11\":1,\"16\":2,\"25\":1,\"26\":4,\"40\":1,\"41\":1}}],[\"practice\",{\"1\":{\"72\":1}}],[\"price\",{\"1\":{\"70\":1,\"72\":1}}],[\"private\",{\"1\":{\"10\":1,\"16\":1,\"26\":2,\"61\":1,\"63\":1,\"64\":1}}],[\"previous\",{\"1\":{\"72\":1}}],[\"prefix\",{\"1\":{\"60\":1}}],[\"preflection\",{\"1\":{\"45\":1}}],[\"predicate\",{\"1\":{\"26\":7,\"36\":2}}],[\"prepare\",{\"1\":{\"25\":1}}],[\"problem\",{\"1\":{\"70\":1}}],[\"protobuf\",{\"1\":{\"45\":18}}],[\"protobuf应用及反射\",{\"0\":{\"45\":1}}],[\"protected\",{\"1\":{\"11\":1,\"26\":1}}],[\"project\",{\"1\":{\"12\":1,\"22\":1,\"27\":1,\"37\":1,\"42\":1}}],[\"product\",{\"1\":{\"0\":1}}],[\"pin\",{\"1\":{\"10\":3,\"11\":20}}],[\"posts\",{\"0\":{\"80\":1}}],[\"postgresql\",{\"1\":{\"3\":1,\"14\":1,\"31\":1}}],[\"pointed\",{\"1\":{\"73\":1}}],[\"powered\",{\"1\":{\"69\":1}}],[\"pop\",{\"1\":{\"10\":1,\"11\":2,\"60\":7,\"63\":1,\"64\":1}}],[\"pools\",{\"1\":{\"12\":1}}],[\"pool\",{\"1\":{\"5\":1,\"11\":2,\"12\":1,\"16\":1,\"17\":2,\"18\":2,\"41\":3,\"45\":1}}],[\"plantype\",{\"1\":{\"26\":2}}],[\"plan\",{\"1\":{\"5\":1,\"25\":4,\"26\":9,\"36\":5}}],[\"等适配器将其适配适配到\",{\"1\":{\"65\":1}}],[\"等字段到达对端同步信息\",{\"1\":{\"64\":1}}],[\"等因素\",{\"1\":{\"53\":1}}],[\"等方法分别用于互斥锁\",{\"1\":{\"35\":1}}],[\"等待超时\",{\"1\":{\"65\":1}}],[\"等待时间为\",{\"1\":{\"64\":1}}],[\"等待被发送\",{\"1\":{\"64\":1}}],[\"等待重组器中数据为空时再关闭输入流\",{\"1\":{\"61\":1}}],[\"等待列表\",{\"1\":{\"35\":1}}],[\"等待\",{\"1\":{\"34\":2}}],[\"等等\",{\"1\":{\"26\":1,\"34\":1,\"52\":1}}],[\"等\",{\"1\":{\"3\":2,\"10\":1,\"14\":1,\"24\":1,\"26\":1,\"58\":1,\"63\":1}}],[\"1s\",{\"1\":{\"65\":1}}],[\"19\",{\"1\":{\"20\":3}}],[\"18\",{\"1\":{\"20\":4}}],[\"17\",{\"1\":{\"19\":2}}],[\"16\",{\"1\":{\"19\":2,\"42\":1}}],[\"144\",{\"1\":{\"67\":1}}],[\"14\",{\"1\":{\"19\":2}}],[\"13\",{\"1\":{\"19\":2}}],[\"127\",{\"1\":{\"56\":2,\"65\":11}}],[\"12\",{\"1\":{\"19\":2,\"27\":1}}],[\"118\",{\"1\":{\"69\":1}}],[\"11\",{\"1\":{\"18\":2,\"22\":1}}],[\"15\",{\"1\":{\"18\":4,\"19\":5,\"22\":1,\"37\":1}}],[\"1000\",{\"1\":{\"65\":1}}],[\"100\",{\"1\":{\"31\":1}}],[\"10\",{\"1\":{\"12\":1,\"18\":2,\"19\":4,\"22\":1,\"64\":4,\"65\":2}}],[\"1\",{\"0\":{\"2\":1,\"70\":1,\"72\":1,\"76\":1},\"1\":{\"5\":3,\"11\":3,\"12\":1,\"15\":2,\"17\":5,\"18\":1,\"19\":2,\"20\":1,\"26\":1,\"31\":4,\"36\":2,\"45\":2,\"56\":2,\"62\":12,\"63\":5,\"64\":4,\"65\":14}}],[\"mfu\",{\"1\":{\"74\":1}}],[\"ms\",{\"1\":{\"63\":2,\"64\":3}}],[\"msg\",{\"1\":{\"45\":2}}],[\"mtu\",{\"1\":{\"53\":1}}],[\"measure\",{\"1\":{\"72\":1}}],[\"merged\",{\"1\":{\"61\":6}}],[\"merge\",{\"1\":{\"61\":3}}],[\"method\",{\"1\":{\"45\":2}}],[\"metadata\",{\"1\":{\"26\":7,\"36\":5}}],[\"messagefactory\",{\"1\":{\"45\":1}}],[\"message\",{\"1\":{\"45\":12}}],[\"message成员变量类图\",{\"1\":{\"45\":1}}],[\"member\",{\"1\":{\"16\":1}}],[\"more\",{\"1\":{\"64\":1,\"73\":1}}],[\"model\",{\"1\":{\"25\":3}}],[\"move\",{\"1\":{\"26\":1,\"60\":1,\"63\":1,\"65\":2}}],[\"movelasttofrontof\",{\"1\":{\"19\":1}}],[\"moveallto\",{\"1\":{\"19\":1}}],[\"mongodb\",{\"1\":{\"3\":1}}],[\"milliseconds\",{\"1\":{\"64\":1,\"65\":1}}],[\"min\",{\"1\":{\"20\":1,\"63\":1}}],[\"minimum\",{\"1\":{\"0\":1}}],[\"mid\",{\"1\":{\"17\":4}}],[\"m\",{\"1\":{\"15\":5,\"18\":6}}],[\"multi\",{\"0\":{\"69\":1}}],[\"mu\",{\"1\":{\"10\":1}}],[\"mutex>\",{\"1\":{\"35\":3}}],[\"mutex\",{\"1\":{\"10\":1,\"11\":1}}],[\"main\",{\"1\":{\"65\":2}}],[\"maintaining\",{\"1\":{\"35\":1}}],[\"makes\",{\"1\":{\"64\":1}}],[\"make\",{\"1\":{\"26\":1,\"62\":1,\"63\":1,\"70\":1}}],[\"materialization\",{\"1\":{\"25\":1}}],[\"maximum\",{\"1\":{\"61\":1,\"62\":1}}],[\"max\",{\"1\":{\"16\":5,\"18\":2,\"19\":3,\"20\":2,\"63\":1,\"64\":3}}],[\"mappingtype\",{\"1\":{\"16\":3}}],[\"map<std\",{\"1\":{\"45\":1}}],[\"map<page\",{\"1\":{\"11\":1}}],[\"map<frame\",{\"1\":{\"10\":1}}],[\"map\",{\"1\":{\"10\":8}}],[\"manager\",{\"1\":{\"5\":5,\"9\":1,\"11\":9,\"16\":1,\"17\":2,\"18\":2,\"40\":3,\"41\":6}}],[\"manifesto\",{\"1\":{\"0\":1}}],[\"mysql\",{\"1\":{\"3\":1,\"14\":1,\"31\":1,\"73\":1}}],[\"mvp\",{\"1\":{\"0\":1}}],[\"过\",{\"1\":{\"62\":1,\"64\":1}}],[\"过度曲解\",{\"1\":{\"0\":1}}],[\"过分追求速度\",{\"1\":{\"0\":1}}],[\"过去二十年时间\",{\"1\":{\"0\":1}}],[\"敏捷宣言\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
